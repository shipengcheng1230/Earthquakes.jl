{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JuEQ.jl Documentation \u00b6 Overview \u00b6 This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Law Boundary Element Method (Quasi-dynamic) Features to be implemented: Viscoelastic relaxation Fully elastodynamics Finite element method Installation \u00b6 Get the latest version with Julia's package manager: 1 ] add https :// github . com / shipengcheng1230 / JuEQ . jl To load the package: 1 using JuEQ","title":"Home"},{"location":"#jueqjl-documentation","text":"","title":"JuEQ.jl Documentation"},{"location":"#overview","text":"This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Law Boundary Element Method (Quasi-dynamic) Features to be implemented: Viscoelastic relaxation Fully elastodynamics Finite element method","title":"Overview"},{"location":"#installation","text":"Get the latest version with Julia's package manager: 1 ] add https :// github . com / shipengcheng1230 / JuEQ . jl To load the package: 1 using JuEQ","title":"Installation"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2018 Shi Pengcheng Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"private_interface/","text":"Private Interface \u00b6 Index \u00b6 JuEQ.HomogeneousElasticProperties JuEQ.ODEStateVariable JuEQ.applied_unit_dislocation JuEQ.shear_traction JuEQ.stiffness_periodic_boundary_condition! Interfaces \u00b6 # JuEQ.HomogeneousElasticProperties \u2014 Type . Okada's dc3d only applies on isotropic materials, therefore, elastic modulus are constrained to be scalars. source # JuEQ.ODEStateVariable \u2014 Type . Intermediate variable in solving ODEs aimed to avoid allocation overheads. # JuEQ.applied_unit_dislocation \u2014 Method . For noraml fault, it should of course be [0., -1., 0.]. However, in term of force balance, it is quivalent to thrust fault if dip angle are constrained within [0, \u03c0/2] in fact. The unit of unit dislocation below is the same of v * t at set by user so to avoid normalization step. # JuEQ.shear_traction \u2014 Method . 1 shear_traction(::Type{<:PlaneFault}, u, \u03bb, \u03bc, dip) Calculate the shear traction on the fault plane w.r.t. fault types. Arguments u::AbstractArray{<:Number, 1} : the output from dc3d_okada \u03bb::Number : Lam\u00e9's first parameter \u03bc::Number : shear modulus dip::Number : plane dip angle Reference A good reference is at Displacement & Strain & Stress . # JuEQ.stiffness_periodic_boundary_condition! \u2014 Method . Periodic boundary condition for 2D faults. Arguments u::AbstractVector : In-place output which is a 12-elements vector (exactly the output of dc3d_okada ). No assertion here imposed. same as dc3d_okada , see dc3d for details. nrept::Integer : (half) number of repetition, as denoted by -npret: nrept lrept::Number : length of repetition interval, see Note below Note The buffer block length is ( buffer_ratio - 1) multipled by along-strike length.","title":"Private"},{"location":"private_interface/#private-interface","text":"","title":"Private Interface"},{"location":"private_interface/#index","text":"JuEQ.HomogeneousElasticProperties JuEQ.ODEStateVariable JuEQ.applied_unit_dislocation JuEQ.shear_traction JuEQ.stiffness_periodic_boundary_condition!","title":"Index"},{"location":"private_interface/#interfaces","text":"# JuEQ.HomogeneousElasticProperties \u2014 Type . Okada's dc3d only applies on isotropic materials, therefore, elastic modulus are constrained to be scalars. source # JuEQ.ODEStateVariable \u2014 Type . Intermediate variable in solving ODEs aimed to avoid allocation overheads. # JuEQ.applied_unit_dislocation \u2014 Method . For noraml fault, it should of course be [0., -1., 0.]. However, in term of force balance, it is quivalent to thrust fault if dip angle are constrained within [0, \u03c0/2] in fact. The unit of unit dislocation below is the same of v * t at set by user so to avoid normalization step. # JuEQ.shear_traction \u2014 Method . 1 shear_traction(::Type{<:PlaneFault}, u, \u03bb, \u03bc, dip) Calculate the shear traction on the fault plane w.r.t. fault types. Arguments u::AbstractArray{<:Number, 1} : the output from dc3d_okada \u03bb::Number : Lam\u00e9's first parameter \u03bc::Number : shear modulus dip::Number : plane dip angle Reference A good reference is at Displacement & Strain & Stress . # JuEQ.stiffness_periodic_boundary_condition! \u2014 Method . Periodic boundary condition for 2D faults. Arguments u::AbstractVector : In-place output which is a 12-elements vector (exactly the output of dc3d_okada ). No assertion here imposed. same as dc3d_okada , see dc3d for details. nrept::Integer : (half) number of repetition, as denoted by -npret: nrept lrept::Number : length of repetition interval, see Note below Note The buffer block length is ( buffer_ratio - 1) multipled by along-strike length.","title":"Interfaces"},{"location":"public_interface/","text":"Public Interface \u00b6 Index \u00b6 JuEQ.DieterichStateLaw JuEQ.PrzStateLaw JuEQ.RuinaStateLaw JuEQ.DECallbackSaveToFile JuEQ.EarthquakeCycleProblem JuEQ.dc3d_okada JuEQ.discretize JuEQ.discretize JuEQ.fault JuEQ.friction JuEQ.max_velocity JuEQ.moment_magnitude JuEQ.properties JuEQ.stiffness_tensor Interfaces \u00b6 # JuEQ.DieterichStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}$ # JuEQ.PrzStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - (\\frac{V \u03b8}{2L})^2$ # JuEQ.RuinaStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\frac{V \u03b8}{L}}$ # JuEQ.DECallbackSaveToFile \u2014 Method . 1 DECallbackSaveToFile(iot::IOStream, iou::IOStream) Construct a functional callback to write ODESolution ( t & u ) into file. The reason to separate t and u is for more easily reshape u w.r.t grids specification. It right now falls on users' memory on what the type of solution is for accurately retrieving results. Arguments iot::IOStream : stream pointing to solution of time iou::IOStream : stream pointing to solution of domain Note It is strongly not recommended to use \"skipping\" scheme (by defining thrd and dts(a) for each case) when solution is too oscillated. # JuEQ.EarthquakeCycleProblem \u2014 Method . 1 EarthquakeCycleProblem(p::PlaneMaterialProperties, u0, tspan; se=DieterichStateLaw(), fform=CForm()) Return an ODEProblem that encapsulate all the parameters and functions required for simulation. For the entailing usage, please refer DifferentialEquations.jl Arguments gd::BoundaryElementGrid : grids for fault domain. p::PlaneMaterialProperties : material profile. u0::AbstractArray : initial condition, should be organized such that the first of last dim is velocity while the 2nd of last dim is state. tspan::NTuple : time interval to be simulated. se::StateEvolutionLaw : state evolution law to be applied. fform::FrictionLawForm : forms of frictional law to be applied. # JuEQ.dc3d_okada \u2014 Method . Calculate displacements and gradient of displacements due to a dislocation in an elastic isotropic halfspace. See dc3d for details. test/test_okada.dat is obtained using DC3dfortran An example wrapper for DC3D in julia as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function dc3d_fortran ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al1 :: T , al2 :: T , aw1 :: T , aw2 :: T , disl1 :: T , disl2 :: T , disl3 :: T ) where { T <: AbstractFloat } # initial return values # `RefValue{T}` may be also viable other than `Array{T, 1}` ux = Array { Float64 }( 1 ) uy = Array { Float64 }( 1 ) uz = Array { Float64 }( 1 ) uxx = Array { Float64 }( 1 ) uyx = Array { Float64 }( 1 ) uzx = Array { Float64 }( 1 ) uxy = Array { Float64 }( 1 ) uyy = Array { Float64 }( 1 ) uzy = Array { Float64 }( 1 ) uxz = Array { Float64 }( 1 ) uyz = Array { Float64 }( 1 ) uzz = Array { Float64 }( 1 ) iret = Array { Int64 }( 1 ) # call okada's code which is renamed as \"__dc3d__\" (see binding rename shown below) # input args tuple must be syntactically written instead of a variable assigned # macros could be used to simplify this in the future ccall (( : __dc3d__ , \"dc3d.so\" ), Void , ( Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ref { Int64 }, ), \u03b1 , x , y , z , dep , dip , al1 , al2 , aw1 , aw2 , disl1 , disl2 , disl3 , ux , uy , uz , uxx , uyx , uzx , uxy , uyy , uzy , uxz , uyz , uzz , iret , ) # results valid iff iret[1] == 0 return ( iret [ 1 ], ux [ 1 ], uy [ 1 ], uz [ 1 ], uxx [ 1 ], uyx [ 1 ], uzx [ 1 ], uxy [ 1 ], uyy [ 1 ], uzy [ 1 ], uxz [ 1 ], uyz [ 1 ], uzz [ 1 ] ) end The corresponding fortran module is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 MODULE okada USE , INTRINSIC :: iso_c_binding IMPLICIT NONE CONTAINS SUBROUTINE dc3d_wrapper (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) BIND ( C , NAME = '__dc3d__' ) REAL * 8 :: & & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz INTEGER * 8 :: iret CALL dc3d (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) END SUBROUTINE dc3d_wrapper END MODULE okada A sample of makefile is as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Build Okada's code for calculating deformation due to a fault model # CC = gfortran CFLAGS = -fPIC -w -O3 LDFLAGS = -shared SRCS = dc3d.f okada.f90 OBJS = $( SRCS:.c = .o ) TARGET = dc3d.so $(TARGET) : $( OBJS ) $( CC ) $( CFLAGS ) $( LDFLAGS ) -o $( TARGET ) $( OBJS ) # JuEQ.discretize \u2014 Method . 1 discretize(fa::PlaneFaultDomain{ftype, 1}, \u0394\u03be::T; ax_ratio=12.5) Generate the grid for given 1D fault domain. The grids will be forced to start at (x=0, y=0, z=0). Arguments \u0394\u03be : grid space along-downdip ax_ratio::Number : ration of along-strike length agsinst along-downdip length for mimicing an extended 2d (x & \u03be) fault represented by 1d (\u03be) domain. Default ax_ratio=12.5 is more than enough for producing consistent results. # JuEQ.discretize \u2014 Method . 1 discretize(fa::PlaneFaultDomain{ftype, 2}, \u0394x, \u0394\u03be; buffer=:auto) where {ftype <: PlaneFault} Generate the grid for given 2D fault domain. The grids will be forced to start at (z=0) and spread symmetrically along x-axis w.r.t y-z plane. By such setting, we would be able to utilize the symmetry properties of stiffness tensor for performance speed up. Arguments \u0394x, \u0394\u03be : grid space along-strike and along-downdip respectively `buffer_ratio::Number: ration of buffer size against along-strike length for introducing zero-dislocation area at along-strike edges of defined fault domain. # JuEQ.fault \u2014 Method . 1 fault(ftype::Type{<:PlaneFault}, dip, span) Generate a fault given the fault type, dip angle and its spatial span. Arguments ftype::Type{<:PlaneFault} : type of plane fault dip : dip angle in degree span : spatial span of fault size # JuEQ.friction \u2014 Method . 1 friction(::FrictionLawForm, v::T, \u03b8::T, L::T, a::T, b::T, f0::T, v0::T) where {T<:Number} Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} # JuEQ.max_velocity \u2014 Method . 1 max_velocity(t::AbstractVector, u::AbstractArray, getu::Function) Return max velocity across the fault at each time step. A number of convenient interfaces for common output are implemented. Arguments t::AbstractVector : vector of time steps u::AbstractArray : array of solution getu::Function : method for retrieving velocity section at each time step # JuEQ.moment_magnitude \u2014 Method . Calculate moment magnitude. # JuEQ.properties \u2014 Method . 1 properties(fa::PlaneFaultDomain, gd::BoundaryElementGrid{dim}; _kwargs...) where {dim} Establishing a material-properties-profile given by the fault domain and grids. User must provide the necessary parameters in according to the grid size specified or just a scalar for broadcasting. Arguments that are required: a : contrib from velocity. b : contrib from state. L : critical distance. \u03c3 : effective normal stress. \u03b7 : radiation damping. It is recommended to set as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity. vpl : plate rate. f0 : ref. frictional coeff. v0 : ref. velocity. Arguments that need options k : stiffness tensor. (1) Providing shear modulus denoted as \u03bc and Lam\u00e9's first parameter denoted as \u03bb (same as \u03bc if missing), then calculate it based on grid and fault domain, choosing parallel scheme if nprocs() != 1 . (2) an AbstractArray represent the pre-calculated stiffness tensor. No verification will be performed here. # JuEQ.stiffness_tensor \u2014 Method . 1 stiffness_tensor(fa::PlaneFaultDomain, gd::BoundaryElementGrid, ep::HomogeneousElasticProperties) Calculate the reduced stiffness tensor. For 2D fault, the final result will be dimensionally reduced to a 3D array due to the translational & reflective & perodic symmetry, such that the tensor contraction will be equivalent to convolution, hence we could use FFT for better performace. Note Faults are originated from surface and extends downwards, thus dep = 0","title":"Public"},{"location":"public_interface/#public-interface","text":"","title":"Public Interface"},{"location":"public_interface/#index","text":"JuEQ.DieterichStateLaw JuEQ.PrzStateLaw JuEQ.RuinaStateLaw JuEQ.DECallbackSaveToFile JuEQ.EarthquakeCycleProblem JuEQ.dc3d_okada JuEQ.discretize JuEQ.discretize JuEQ.fault JuEQ.friction JuEQ.max_velocity JuEQ.moment_magnitude JuEQ.properties JuEQ.stiffness_tensor","title":"Index"},{"location":"public_interface/#interfaces","text":"# JuEQ.DieterichStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}$ # JuEQ.PrzStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - (\\frac{V \u03b8}{2L})^2$ # JuEQ.RuinaStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\frac{V \u03b8}{L}}$ # JuEQ.DECallbackSaveToFile \u2014 Method . 1 DECallbackSaveToFile(iot::IOStream, iou::IOStream) Construct a functional callback to write ODESolution ( t & u ) into file. The reason to separate t and u is for more easily reshape u w.r.t grids specification. It right now falls on users' memory on what the type of solution is for accurately retrieving results. Arguments iot::IOStream : stream pointing to solution of time iou::IOStream : stream pointing to solution of domain Note It is strongly not recommended to use \"skipping\" scheme (by defining thrd and dts(a) for each case) when solution is too oscillated. # JuEQ.EarthquakeCycleProblem \u2014 Method . 1 EarthquakeCycleProblem(p::PlaneMaterialProperties, u0, tspan; se=DieterichStateLaw(), fform=CForm()) Return an ODEProblem that encapsulate all the parameters and functions required for simulation. For the entailing usage, please refer DifferentialEquations.jl Arguments gd::BoundaryElementGrid : grids for fault domain. p::PlaneMaterialProperties : material profile. u0::AbstractArray : initial condition, should be organized such that the first of last dim is velocity while the 2nd of last dim is state. tspan::NTuple : time interval to be simulated. se::StateEvolutionLaw : state evolution law to be applied. fform::FrictionLawForm : forms of frictional law to be applied. # JuEQ.dc3d_okada \u2014 Method . Calculate displacements and gradient of displacements due to a dislocation in an elastic isotropic halfspace. See dc3d for details. test/test_okada.dat is obtained using DC3dfortran An example wrapper for DC3D in julia as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function dc3d_fortran ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al1 :: T , al2 :: T , aw1 :: T , aw2 :: T , disl1 :: T , disl2 :: T , disl3 :: T ) where { T <: AbstractFloat } # initial return values # `RefValue{T}` may be also viable other than `Array{T, 1}` ux = Array { Float64 }( 1 ) uy = Array { Float64 }( 1 ) uz = Array { Float64 }( 1 ) uxx = Array { Float64 }( 1 ) uyx = Array { Float64 }( 1 ) uzx = Array { Float64 }( 1 ) uxy = Array { Float64 }( 1 ) uyy = Array { Float64 }( 1 ) uzy = Array { Float64 }( 1 ) uxz = Array { Float64 }( 1 ) uyz = Array { Float64 }( 1 ) uzz = Array { Float64 }( 1 ) iret = Array { Int64 }( 1 ) # call okada's code which is renamed as \"__dc3d__\" (see binding rename shown below) # input args tuple must be syntactically written instead of a variable assigned # macros could be used to simplify this in the future ccall (( : __dc3d__ , \"dc3d.so\" ), Void , ( Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ref { Int64 }, ), \u03b1 , x , y , z , dep , dip , al1 , al2 , aw1 , aw2 , disl1 , disl2 , disl3 , ux , uy , uz , uxx , uyx , uzx , uxy , uyy , uzy , uxz , uyz , uzz , iret , ) # results valid iff iret[1] == 0 return ( iret [ 1 ], ux [ 1 ], uy [ 1 ], uz [ 1 ], uxx [ 1 ], uyx [ 1 ], uzx [ 1 ], uxy [ 1 ], uyy [ 1 ], uzy [ 1 ], uxz [ 1 ], uyz [ 1 ], uzz [ 1 ] ) end The corresponding fortran module is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 MODULE okada USE , INTRINSIC :: iso_c_binding IMPLICIT NONE CONTAINS SUBROUTINE dc3d_wrapper (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) BIND ( C , NAME = '__dc3d__' ) REAL * 8 :: & & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz INTEGER * 8 :: iret CALL dc3d (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) END SUBROUTINE dc3d_wrapper END MODULE okada A sample of makefile is as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Build Okada's code for calculating deformation due to a fault model # CC = gfortran CFLAGS = -fPIC -w -O3 LDFLAGS = -shared SRCS = dc3d.f okada.f90 OBJS = $( SRCS:.c = .o ) TARGET = dc3d.so $(TARGET) : $( OBJS ) $( CC ) $( CFLAGS ) $( LDFLAGS ) -o $( TARGET ) $( OBJS ) # JuEQ.discretize \u2014 Method . 1 discretize(fa::PlaneFaultDomain{ftype, 1}, \u0394\u03be::T; ax_ratio=12.5) Generate the grid for given 1D fault domain. The grids will be forced to start at (x=0, y=0, z=0). Arguments \u0394\u03be : grid space along-downdip ax_ratio::Number : ration of along-strike length agsinst along-downdip length for mimicing an extended 2d (x & \u03be) fault represented by 1d (\u03be) domain. Default ax_ratio=12.5 is more than enough for producing consistent results. # JuEQ.discretize \u2014 Method . 1 discretize(fa::PlaneFaultDomain{ftype, 2}, \u0394x, \u0394\u03be; buffer=:auto) where {ftype <: PlaneFault} Generate the grid for given 2D fault domain. The grids will be forced to start at (z=0) and spread symmetrically along x-axis w.r.t y-z plane. By such setting, we would be able to utilize the symmetry properties of stiffness tensor for performance speed up. Arguments \u0394x, \u0394\u03be : grid space along-strike and along-downdip respectively `buffer_ratio::Number: ration of buffer size against along-strike length for introducing zero-dislocation area at along-strike edges of defined fault domain. # JuEQ.fault \u2014 Method . 1 fault(ftype::Type{<:PlaneFault}, dip, span) Generate a fault given the fault type, dip angle and its spatial span. Arguments ftype::Type{<:PlaneFault} : type of plane fault dip : dip angle in degree span : spatial span of fault size # JuEQ.friction \u2014 Method . 1 friction(::FrictionLawForm, v::T, \u03b8::T, L::T, a::T, b::T, f0::T, v0::T) where {T<:Number} Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} # JuEQ.max_velocity \u2014 Method . 1 max_velocity(t::AbstractVector, u::AbstractArray, getu::Function) Return max velocity across the fault at each time step. A number of convenient interfaces for common output are implemented. Arguments t::AbstractVector : vector of time steps u::AbstractArray : array of solution getu::Function : method for retrieving velocity section at each time step # JuEQ.moment_magnitude \u2014 Method . Calculate moment magnitude. # JuEQ.properties \u2014 Method . 1 properties(fa::PlaneFaultDomain, gd::BoundaryElementGrid{dim}; _kwargs...) where {dim} Establishing a material-properties-profile given by the fault domain and grids. User must provide the necessary parameters in according to the grid size specified or just a scalar for broadcasting. Arguments that are required: a : contrib from velocity. b : contrib from state. L : critical distance. \u03c3 : effective normal stress. \u03b7 : radiation damping. It is recommended to set as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity. vpl : plate rate. f0 : ref. frictional coeff. v0 : ref. velocity. Arguments that need options k : stiffness tensor. (1) Providing shear modulus denoted as \u03bc and Lam\u00e9's first parameter denoted as \u03bb (same as \u03bc if missing), then calculate it based on grid and fault domain, choosing parallel scheme if nprocs() != 1 . (2) an AbstractArray represent the pre-calculated stiffness tensor. No verification will be performed here. # JuEQ.stiffness_tensor \u2014 Method . 1 stiffness_tensor(fa::PlaneFaultDomain, gd::BoundaryElementGrid, ep::HomogeneousElasticProperties) Calculate the reduced stiffness tensor. For 2D fault, the final result will be dimensionally reduced to a 3D array due to the translational & reflective & perodic symmetry, such that the tensor contraction will be equivalent to convolution, hence we could use FFT for better performace. Note Faults are originated from surface and extends downwards, thus dep = 0","title":"Interfaces"},{"location":"quasi_dynamic_intro/","text":"Quasi-dynamic Simulation using BEM \u00b6 Basic Theory \u00b6 The governing equation is that at every time step, shear stress across the fault plane equals to frictional force plus a radiation damping term for approximating wave propagation effect: \u03c4 = \u03c3f + \u03b7V Here $\u03bc$ is shear stress across the fault plain. Using Okada's dislocation theory , it can be shown as: \u03c4 = \\mathrm{K} \u2297 \u03b4 where $\\mathrm{K}$ is the so-called stiffness tensor, depicting relationship between displacements at one position regarding to dislocations somewhere else. $\u03b4$ is the dislocation, i.e. displacement at everywhere on the fault. $\u2297$ denotes tensor contraction. Back to $f$, we use rate-and-state frictional law to calculate its value, specifically as below: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} where $f_0$ and $V_0$ are reference friction coefficient and velocity, $V$ and $\u03b8$ are velocity and state variable based on which frictional force is. $a$ and $b$ are two frictional parameters denoting contributions each of which comes from velocity and state variable respectively. $L$ is critical distance after which frictional force return to new steady state. Sometimes people use regularized form to avoid infinity when $V \u2248 0$, namely: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} There are many state evolution law that describes how state variable $\u03b8$ changes with time, one of which that most widely used is Dieterich law: \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} Further, $\u03b7$ is a damping coefficient whose value is often chosen as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity and $\u03c3$ is the effective normal stress. To simulate how fault evolves with time, we then take the derivative of the governing equation: \\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\frac{\\mathrm{d} f(V, \u03b8)}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\mathrm{d} f}{\\mathrm{d} V} \\frac{\\mathrm{d} V}{\\mathrm{d} t} + \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} Thus we arrive at: \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} - \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t}}{\\frac{\\mathrm{d} f}{\\mathrm{d} V} + \u03b7} where $\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\mathrm{K} \u2297 (\\mathrm{V_{pl}} - V)$ where $\\mathrm{V_{pl}}$ is the plate rate. Note The direction of relative velocity, namely $\\mathrm{V_{pl} - V}$, must be in accordance to the direction of $\\mathrm{K}$ which, here, we use the same meaning as Rice, J. (1993). Hence, with both derivatives of velocity $V$ and state variable $\u03b8$, we are able to discover how fault evolves with various parameters settings.","title":"Basic Theory"},{"location":"quasi_dynamic_intro/#quasi-dynamic-simulation-using-bem","text":"","title":"Quasi-dynamic Simulation using BEM"},{"location":"quasi_dynamic_intro/#basic-theory","text":"The governing equation is that at every time step, shear stress across the fault plane equals to frictional force plus a radiation damping term for approximating wave propagation effect: \u03c4 = \u03c3f + \u03b7V Here $\u03bc$ is shear stress across the fault plain. Using Okada's dislocation theory , it can be shown as: \u03c4 = \\mathrm{K} \u2297 \u03b4 where $\\mathrm{K}$ is the so-called stiffness tensor, depicting relationship between displacements at one position regarding to dislocations somewhere else. $\u03b4$ is the dislocation, i.e. displacement at everywhere on the fault. $\u2297$ denotes tensor contraction. Back to $f$, we use rate-and-state frictional law to calculate its value, specifically as below: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} where $f_0$ and $V_0$ are reference friction coefficient and velocity, $V$ and $\u03b8$ are velocity and state variable based on which frictional force is. $a$ and $b$ are two frictional parameters denoting contributions each of which comes from velocity and state variable respectively. $L$ is critical distance after which frictional force return to new steady state. Sometimes people use regularized form to avoid infinity when $V \u2248 0$, namely: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} There are many state evolution law that describes how state variable $\u03b8$ changes with time, one of which that most widely used is Dieterich law: \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} Further, $\u03b7$ is a damping coefficient whose value is often chosen as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity and $\u03c3$ is the effective normal stress. To simulate how fault evolves with time, we then take the derivative of the governing equation: \\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\frac{\\mathrm{d} f(V, \u03b8)}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\mathrm{d} f}{\\mathrm{d} V} \\frac{\\mathrm{d} V}{\\mathrm{d} t} + \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} Thus we arrive at: \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} - \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t}}{\\frac{\\mathrm{d} f}{\\mathrm{d} V} + \u03b7} where $\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\mathrm{K} \u2297 (\\mathrm{V_{pl}} - V)$ where $\\mathrm{V_{pl}}$ is the plate rate. Note The direction of relative velocity, namely $\\mathrm{V_{pl} - V}$, must be in accordance to the direction of $\\mathrm{K}$ which, here, we use the same meaning as Rice, J. (1993). Hence, with both derivatives of velocity $V$ and state variable $\u03b8$, we are able to discover how fault evolves with various parameters settings.","title":"Basic Theory"},{"location":"references/","text":"Acknowledgements & References \u00b6 Acknowledgements \u00b6 The simulation of episodic seismic and slow slip events using boundary-element-method is largely benifit from Yajing Liu original Fortran code. References \u00b6 Please consider to cite the following papers if you find this package useful. Boundary element method (quasi-dynamic) \u00b6 Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., & Rice, J. R. (2005). Aseismic slip transients emerge spontaneously in three-dimensional rate and state modeling of subduction earthquake sequences. Journal of Geophysical Research: Solid Earth, 110(B8). https://doi.org/10.1029/2004JB003424","title":"References"},{"location":"references/#acknowledgements-references","text":"","title":"Acknowledgements &amp; References"},{"location":"references/#acknowledgements","text":"The simulation of episodic seismic and slow slip events using boundary-element-method is largely benifit from Yajing Liu original Fortran code.","title":"Acknowledgements"},{"location":"references/#references","text":"Please consider to cite the following papers if you find this package useful.","title":"References"},{"location":"references/#boundary-element-method-quasi-dynamic","text":"Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., & Rice, J. R. (2005). Aseismic slip transients emerge spontaneously in three-dimensional rate and state modeling of subduction earthquake sequences. Journal of Geophysical Research: Solid Earth, 110(B8). https://doi.org/10.1029/2004JB003424","title":"Boundary element method (quasi-dynamic)"},{"location":"examples/generated/bp1/","text":"Note This example is from Benchmark Problem 1 (hence referred as BP1). Define Parameters \u00b6 First, we load the package 1 2 using JuEQ using Plots Instead of using SI unit, we refactor ours into the follow: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ms2mmyr = 365 * 86400 * 1e3 # convert velocity from m/s to mm/yr \u03c1 = 2670.0 # density [kg/m\u00b3] vs = 3464.0 # shear wave velocity [m/s] \u03c3 = 500.0 # effective normal stress [bar] a0 = 0.010 # frictional paramter `a` in vw zone amax = 0.025 # frictional paramter `a` in vs zone b0 = 0.015 # frictional paramter `b` L = 8.0 # critical distance [mm] vpl = 1e-9 * ms2mmyr # plate rate [mm/yr] vinit = 1e-9 * ms2mmyr # initial velocity [mm/yr] v0 = 1e-6 * ms2mmyr # reference velocity [mm/yr] f0 = 0.6 # reference frictional coefficient H = 15.0 # vw zone [km] h = 3.0 # vw-vs changing zone [km] Wf = 40.0 # fault depth [km] \u0394z = 100.0e-3 # grid size interval [km] tf = 400.0 ; # simulation time [yr] Warning Make sure your units are consistent across the whole variable space. Pontenial imporvement may incoporate Unitful.jl package. Then we arrive at some parameters that are implicit by above: 1 2 3 4 \u03bc = vs ^ 2 * \u03c1 / 1e5 / 1e6 # shear modulus [bar\u00b7km/mm] \u03bb = \u03bc # poisson material \u03b7 = \u03bc / 2 ( vs * 1e-3 * 365 * 86400 ) ngrid = round ( Int , Wf / \u0394z ); # number of grids Now, we start to construct our model using parameters above. First, we create a 'fault' by specifying fault type and depth: Tip Here, we do not need to provide dip for strike-slip fault as it automatically choose 90 . See fault . Construct Model \u00b6 1 fa = fault ( StrikeSlipFault , Wf ); Next, we generate the grid regarding the fault we just created by giving number of grids: Note This package use \u03be for denoting downdip coordinate and x for along-strike one. See discretize . 1 gd = discretize ( fa ; n\u03be = ngrid ); Next, we construct the required frictional parameter profile: 1 2 3 4 z = - gd . \u03be az = fill ( a0 , size ( z )) az [ z .\u2265 ( H + h )] .= amax az [ H .< z .< H + h ] = a0 .+ ( amax - a0 ) / ( h / \u0394z ) * collect ( 1 : Int ( h / \u0394z )); Then, we provide the required initial condition satisfying uniform slip distribution over the depth: 1 2 3 4 5 \u03c40 = \u03c3 * amax * asinh ( vinit / 2 v0 * exp (( f0 + b0 * log ( v0 / vinit )) / amax )) + \u03b7 * vinit \u03c4z = fill ( \u03c40 , size ( z )) \u03b8z = @ . L / v0 * exp ( az / b0 * log ( 2 v0 / vinit * sinh (( \u03c4z - \u03b7 * vinit ) / az / \u03c3 )) - f0 / b0 ) vz = fill ( vinit , size ( z )) u0 = hcat ( vz , \u03b8z ); Let's simulate only the first 200 years: 1 tspan = ( 0. , 200. ); Finally, we provide the material properties w.r.t. our 'fault', 'grid' as well as other necessary parameters predefined using the same grid size & dimension: 1 mp = properties (; fault = fa , grid = gd , parameters = [ : a => az , : b => b0 , : L => L , : \u03c3 => \u03c3 , : \u03b7 => \u03b7 , : k => [ : \u03bb => \u03bb , : \u03bc => \u03bc ], : vpl => vpl , : f0 => f0 , : v0 => v0 ]); 1 2 [ Info: Calculating stiffness tensor ... [ Info: Fault material properties establised. Tip Check properties for extended options. Check our profile now: 1 plot ([ mp . a , mp . b ], z , label = [ \"a\" , \"b\" ], yflip = true , ylabel = \"Depth (km)\" ) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 0.012 \\n \\n \\n 0.015 \\n \\n \\n 0.018 \\n \\n \\n 0.021 \\n \\n \\n 0.024 \\n \\n \\n 0 \\n \\n \\n 10 \\n \\n \\n 20 \\n \\n \\n 30 \\n \\n \\n 40 \\n \\n \\n Depth (km) \\n \\n \\n \\n \\n \\n \\n \\n a \\n \\n \\n \\n b \\n \\n \\n\") We then contruct the ODEProblem as following by stating which state evolution law to use and frcitonal law form, plus initial condition and simulation time: 1 prob = EarthquakeCycleProblem ( gd , mp , u0 , tspan ; se = DieterichStateLaw (), fform = RForm ()); Solve Model \u00b6 We then solve the ODEs: 1 sol = solve ( prob , Tsit5 (), reltol = 1e-6 , abstol = 1e-6 ); Tip For details of solving options, see here . Tip Raise the accuracy option if you get instability when solving these ODEs. Results \u00b6 The first event happens at around 196 year: 1 2 maxv = max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , xlims = ( 190 , 200 ), label = \"\" ) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 190.0 \\n \\n \\n 192.5 \\n \\n \\n 195.0 \\n \\n \\n 197.5 \\n \\n \\n 200.0 \\n \\n \\n -8 \\n \\n \\n -6 \\n \\n \\n -4 \\n \\n \\n -2 \\n \\n \\n 0 \\n \\n \\n Time (year) \\n \\n \\n Max Velocity (log10 (m/s)) \\n \\n \\n \\n\") Note Click here for the slip evolution over 3000 years simulation. It may need some time to load the page. This page was generated using Literate.jl .","title":"Example 1D"},{"location":"examples/generated/bp1/#define-parameters","text":"First, we load the package 1 2 using JuEQ using Plots Instead of using SI unit, we refactor ours into the follow: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ms2mmyr = 365 * 86400 * 1e3 # convert velocity from m/s to mm/yr \u03c1 = 2670.0 # density [kg/m\u00b3] vs = 3464.0 # shear wave velocity [m/s] \u03c3 = 500.0 # effective normal stress [bar] a0 = 0.010 # frictional paramter `a` in vw zone amax = 0.025 # frictional paramter `a` in vs zone b0 = 0.015 # frictional paramter `b` L = 8.0 # critical distance [mm] vpl = 1e-9 * ms2mmyr # plate rate [mm/yr] vinit = 1e-9 * ms2mmyr # initial velocity [mm/yr] v0 = 1e-6 * ms2mmyr # reference velocity [mm/yr] f0 = 0.6 # reference frictional coefficient H = 15.0 # vw zone [km] h = 3.0 # vw-vs changing zone [km] Wf = 40.0 # fault depth [km] \u0394z = 100.0e-3 # grid size interval [km] tf = 400.0 ; # simulation time [yr] Warning Make sure your units are consistent across the whole variable space. Pontenial imporvement may incoporate Unitful.jl package. Then we arrive at some parameters that are implicit by above: 1 2 3 4 \u03bc = vs ^ 2 * \u03c1 / 1e5 / 1e6 # shear modulus [bar\u00b7km/mm] \u03bb = \u03bc # poisson material \u03b7 = \u03bc / 2 ( vs * 1e-3 * 365 * 86400 ) ngrid = round ( Int , Wf / \u0394z ); # number of grids Now, we start to construct our model using parameters above. First, we create a 'fault' by specifying fault type and depth: Tip Here, we do not need to provide dip for strike-slip fault as it automatically choose 90 . See fault .","title":"Define Parameters"},{"location":"examples/generated/bp1/#construct-model","text":"1 fa = fault ( StrikeSlipFault , Wf ); Next, we generate the grid regarding the fault we just created by giving number of grids: Note This package use \u03be for denoting downdip coordinate and x for along-strike one. See discretize . 1 gd = discretize ( fa ; n\u03be = ngrid ); Next, we construct the required frictional parameter profile: 1 2 3 4 z = - gd . \u03be az = fill ( a0 , size ( z )) az [ z .\u2265 ( H + h )] .= amax az [ H .< z .< H + h ] = a0 .+ ( amax - a0 ) / ( h / \u0394z ) * collect ( 1 : Int ( h / \u0394z )); Then, we provide the required initial condition satisfying uniform slip distribution over the depth: 1 2 3 4 5 \u03c40 = \u03c3 * amax * asinh ( vinit / 2 v0 * exp (( f0 + b0 * log ( v0 / vinit )) / amax )) + \u03b7 * vinit \u03c4z = fill ( \u03c40 , size ( z )) \u03b8z = @ . L / v0 * exp ( az / b0 * log ( 2 v0 / vinit * sinh (( \u03c4z - \u03b7 * vinit ) / az / \u03c3 )) - f0 / b0 ) vz = fill ( vinit , size ( z )) u0 = hcat ( vz , \u03b8z ); Let's simulate only the first 200 years: 1 tspan = ( 0. , 200. ); Finally, we provide the material properties w.r.t. our 'fault', 'grid' as well as other necessary parameters predefined using the same grid size & dimension: 1 mp = properties (; fault = fa , grid = gd , parameters = [ : a => az , : b => b0 , : L => L , : \u03c3 => \u03c3 , : \u03b7 => \u03b7 , : k => [ : \u03bb => \u03bb , : \u03bc => \u03bc ], : vpl => vpl , : f0 => f0 , : v0 => v0 ]); 1 2 [ Info: Calculating stiffness tensor ... [ Info: Fault material properties establised. Tip Check properties for extended options. Check our profile now: 1 plot ([ mp . a , mp . b ], z , label = [ \"a\" , \"b\" ], yflip = true , ylabel = \"Depth (km)\" ) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 0.012 \\n \\n \\n 0.015 \\n \\n \\n 0.018 \\n \\n \\n 0.021 \\n \\n \\n 0.024 \\n \\n \\n 0 \\n \\n \\n 10 \\n \\n \\n 20 \\n \\n \\n 30 \\n \\n \\n 40 \\n \\n \\n Depth (km) \\n \\n \\n \\n \\n \\n \\n \\n a \\n \\n \\n \\n b \\n \\n \\n\") We then contruct the ODEProblem as following by stating which state evolution law to use and frcitonal law form, plus initial condition and simulation time: 1 prob = EarthquakeCycleProblem ( gd , mp , u0 , tspan ; se = DieterichStateLaw (), fform = RForm ());","title":"Construct Model"},{"location":"examples/generated/bp1/#solve-model","text":"We then solve the ODEs: 1 sol = solve ( prob , Tsit5 (), reltol = 1e-6 , abstol = 1e-6 ); Tip For details of solving options, see here . Tip Raise the accuracy option if you get instability when solving these ODEs.","title":"Solve Model"},{"location":"examples/generated/bp1/#results","text":"The first event happens at around 196 year: 1 2 maxv = max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , xlims = ( 190 , 200 ), label = \"\" ) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 190.0 \\n \\n \\n 192.5 \\n \\n \\n 195.0 \\n \\n \\n 197.5 \\n \\n \\n 200.0 \\n \\n \\n -8 \\n \\n \\n -6 \\n \\n \\n -4 \\n \\n \\n -2 \\n \\n \\n 0 \\n \\n \\n Time (year) \\n \\n \\n Max Velocity (log10 (m/s)) \\n \\n \\n \\n\") Note Click here for the slip evolution over 3000 years simulation. It may need some time to load the page. This page was generated using Literate.jl .","title":"Results"},{"location":"examples/generated/otfsync/","text":"Note This example is adapted from Wei, 2016 AGU Tip It will automatically use parallel scheme if nprocs() \u2242\u0338 1 when building stiffness tensor. To do so: 1 2 3 using Distributed addprocs ( 4 ); # add # of cores you desire using JuEQ Define Parameters \u00b6 First, we load the package and define some basic parameters: 1 2 3 4 5 6 7 8 9 using JuEQ using Plots ms2mmyr = 365 * 86400 * 1e3 \u03c1 = 2670.0 # kg/m\u00b3 cs = 3044.0 # m/s vpl = 100.0 # mm/yr v0 = 3.2e4 # mm/yr f0 = 0.6 ; Then we come to parameters implicit by above: 1 2 3 4 \u03bc = 0.3 # Bar\u00b7km/mm \u03bb = \u03bc # poisson material \u03b1 = ( \u03bb + \u03bc ) / ( \u03bb + 2 \u03bc ) \u03b7 = \u03bc / 2 ( cs * 1e-3 * 365 * 86400 ); # Bar\u00b7yr/mm Create a fault: 1 fa = fault ( StrikeSlipFault , ( 80. , 10. )); Generate grids: 1 gd = discretize ( fa ; nx = 160 , n\u03be = 20 , buffer_ratio = 1 ); Tip It is recommended (from Yajing Liu's personal communication) to add buffer zones adjacent the horizontal edges to immitate zero dislocation at the ridge region. Basically, it affects how the stiffness tensor are periodically summed. To what extent it alters the results remains further testing. Under the hood, it shall impose buffer areas on both sides of along-strike, each of which has a length of bufferratio/2*fa[:x] . Thus, the stiffness contributions falling into those buffer zone shall be neglected, which is equivalent to impose zero-slip correspondingly. Time for us to establish frictional parameters profile: 1 2 3 4 5 6 7 8 9 10 11 a = 0.015 .* ones ( gd . nx , gd . n\u03be ) b = 0.0115 .* ones ( gd . nx , gd . n\u03be ) left_patch = @ . - 25. \u2264 gd . x \u2264 - 5. right_patch = @ . 5. \u2264 gd . x \u2264 25. vert_patch = @ . - 6. \u2264 gd . z \u2264 - 1. b [ xor . ( left_patch , right_patch ), vert_patch ] .= 0.0185 amb = a - b \u03c3max = 500. \u03c3 = [ min ( \u03c3max , 15. + 180. * z ) for z in - gd . z ] \u03c3 = Matrix ( repeat ( \u03c3 , 1 , gd . nx ) ' ) L = 12. ; Check our profile: 1 2 3 4 5 6 7 8 9 10 11 12 13 p1 = heatmap ( amb ' , xticks = ( 0 : 10 / gd . \u0394x : gd . nx , - fa . span [ 1 ] / 2 : 10 : fa . span [ 1 ] / 2 ), yticks = ( 0 : 5 / gd . \u0394\u03be : gd . n\u03be , 0 : - 5 : - fa . span [ 2 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"a-b\" ); p2 = heatmap ( \u03c3 ' , xticks = ( 0 : 10 / gd . \u0394x : gd . nx , - fa . span [ 1 ] / 2 : 10 : fa . span [ 1 ] / 2 ), yticks = ( 0 : 5 / gd . \u0394\u03be : gd . n\u03be , 0 : - 5 : - fa . span [ 2 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \" \\\\ sigma\" ); plot ( p1 , p2 , layout = ( 2 , 1 )) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n a-b \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 0.003 \\n \\n \\n - \\n \\n \\n 0.002 \\n \\n \\n - \\n \\n \\n 0.001 \\n \\n \\n 0 \\n \\n \\n 0.001 \\n \\n \\n 0.002 \\n \\n \\n 0.003 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n \u03c3 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 100 \\n \\n \\n 150 \\n \\n \\n 200 \\n \\n \\n 250 \\n \\n \\n 300 \\n \\n \\n 350 \\n \\n \\n 400 \\n \\n \\n 450 \\n \\n \\n 500 \\n \\n \\n \\n \\n \\n \\n\") Construct Model \u00b6 Construct our material property profile: 1 mp = properties ( fa , gd , [ : a => a , : b => b , : L => L , : \u03c3 => \u03c3 , : \u03b7 => \u03b7 , : k => [ : \u03bb => \u03bb , : \u03bc => \u03bc ], : vpl => vpl , : f0 => f0 , : v0 => v0 ]); 1 2 [ Info: Calculating stiffness tensor ... [ Info: Fault material properties establised. Provide the initial condition: 1 2 3 vinit = vpl .* ones ( gd . nx , gd . n\u03be ) \u03b80 = L ./ vinit ./ 1.1 u0 = cat ( vinit , \u03b80 , dims = 3 ); Get our ODEs problem: 1 prob = EarthquakeCycleProblem ( gd , mp , u0 , ( 0. , 18. ); se = DieterichStateLaw (), fform = CForm ()); Solve Model \u00b6 Solve the model: 1 sol = solve ( prob , Tsit5 (), reltol = 1e-6 , abstol = 1e-6 ); Sanity Check of Results \u00b6 Take a look at the max velocity: 1 2 maxv = max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , label = \"\" ) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 0 \\n \\n \\n 5 \\n \\n \\n 10 \\n \\n \\n 15 \\n \\n \\n -8 \\n \\n \\n -7 \\n \\n \\n -6 \\n \\n \\n -5 \\n \\n \\n -4 \\n \\n \\n -3 \\n \\n \\n -2 \\n \\n \\n Time (year) \\n \\n \\n Max Velocity (log10 (m/s)) \\n \\n \\n \\n\") View some snapshots to see the rupture (quasi-dynamic) patterns: 1 2 3 4 5 6 7 8 9 ind = argmax ( maxv ) myplot = ( ind ) -> heatmap ( log10 . ( sol . u [ ind ][ : , : , 1 ] ./ ms2mmyr ) ' , xticks = ( 0 : 10 / gd . \u0394x : gd . nx , - fa . span [ 1 ] / 2 : 10 : fa . span [ 1 ] / 2 ), yticks = ( 0 : 5 / gd . \u0394\u03be : gd . n\u03be , 0 : - 5 : - fa . span [ 2 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"t = $ ( sol . t [ ind ]) \" ) snaps = [ myplot ( i ) for i in ind - 700 : 200 : ind + 500 ] plot ( snaps ... , layout = ( length ( snaps ), 1 ), size = ( 600 , 1800 )) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n t = 10.71973068412635 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.0 \\n \\n \\n - \\n \\n \\n 7.5 \\n \\n \\n - \\n \\n \\n 7.0 \\n \\n \\n - \\n \\n \\n 6.5 \\n \\n \\n - \\n \\n \\n 6.0 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n t = 10.831121338136795 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.50 \\n \\n \\n - \\n \\n \\n 8.25 \\n \\n \\n - \\n \\n \\n 8.00 \\n \\n \\n - \\n \\n \\n 7.75 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n t = 14.7651243515813 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 9.25 \\n \\n \\n - \\n \\n \\n 9.00 \\n \\n \\n - \\n \\n \\n 8.75 \\n \\n \\n - \\n \\n \\n 8.50 \\n \\n \\n - \\n \\n \\n 8.25 \\n \\n \\n - \\n \\n \\n 8.00 \\n \\n \\n - \\n \\n \\n 7.75 \\n \\n \\n - \\n \\n \\n 7.50 \\n \\n \\n - \\n \\n \\n 7.25 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n \\n \\n \\n \\n \\n -30.0 \\n \\n \\n \\n \\n \\n \\n \\n -20.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n 10.0 \\n \\n \\n \\n \\n \\n \\n \\n 20.0 \\n \\n \\n \\n \\n \\n \\n \\n 30.0 \\n \\n \\n \\n \\n \\n \\n \\n 40.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n -5.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n t = 14.896146309474766 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.5 \\n \\n \\n - \\n \\n \\n 8.0 \\n \\n \\n - \\n \\n \\n 7.5 \\n \\n \\n - \\n \\n \\n 7.0 \\n \\n \\n - \\n \\n \\n 6.5 \\n \\n \\n - \\n \\n \\n 6.0 \\n \\n \\n - \\n \\n \\n 5.5 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n \\n \\n \\n \\n \\n -30.0 \\n \\n \\n \\n \\n \\n \\n \\n -20.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n 10.0 \\n \\n \\n \\n \\n \\n \\n \\n 20.0 \\n \\n \\n \\n \\n \\n \\n \\n 30.0 \\n \\n \\n \\n \\n \\n \\n \\n 40.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n -5.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n t = 14.897556049396778 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.5 \\n \\n \\n - \\n \\n \\n 8.0 \\n \\n \\n - \\n \\n \\n 7.5 \\n \\n \\n - \\n \\n \\n 7.0 \\n \\n \\n - \\n \\n \\n 6.5 \\n \\n \\n - \\n \\n \\n 6.0 \\n \\n \\n - \\n \\n \\n 5.5 \\n \\n \\n - \\n \\n \\n 5.0 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n \\n \\n \\n \\n \\n -30.0 \\n \\n \\n \\n \\n \\n \\n \\n -20.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n 10.0 \\n \\n \\n \\n \\n \\n \\n \\n 20.0 \\n \\n \\n \\n \\n \\n \\n \\n 30.0 \\n \\n \\n \\n \\n \\n \\n \\n 40.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n -5.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n t = 14.913521453799735 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.25 \\n \\n \\n - \\n \\n \\n 8.00 \\n \\n \\n - \\n \\n \\n 7.75 \\n \\n \\n - \\n \\n \\n 7.50 \\n \\n \\n - \\n \\n \\n 7.25 \\n \\n \\n - \\n \\n \\n 7.00 \\n \\n \\n - \\n \\n \\n 6.75 \\n \\n \\n - \\n \\n \\n 6.50 \\n \\n \\n - \\n \\n \\n 6.25 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n \\n \\n \\n \\n \\n -30.0 \\n \\n \\n \\n \\n \\n \\n \\n -20.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n 10.0 \\n \\n \\n \\n \\n \\n \\n \\n 20.0 \\n \\n \\n \\n \\n \\n \\n \\n 30.0 \\n \\n \\n \\n \\n \\n \\n \\n 40.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n -5.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n t = 17.043707465146564 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 9.75 \\n \\n \\n - \\n \\n \\n 9.50 \\n \\n \\n - \\n \\n \\n 9.25 \\n \\n \\n - \\n \\n \\n 9.00 \\n \\n \\n - \\n \\n \\n 8.75 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\") This page was generated using Literate.jl .","title":"Example 2D"},{"location":"examples/generated/otfsync/#define-parameters","text":"First, we load the package and define some basic parameters: 1 2 3 4 5 6 7 8 9 using JuEQ using Plots ms2mmyr = 365 * 86400 * 1e3 \u03c1 = 2670.0 # kg/m\u00b3 cs = 3044.0 # m/s vpl = 100.0 # mm/yr v0 = 3.2e4 # mm/yr f0 = 0.6 ; Then we come to parameters implicit by above: 1 2 3 4 \u03bc = 0.3 # Bar\u00b7km/mm \u03bb = \u03bc # poisson material \u03b1 = ( \u03bb + \u03bc ) / ( \u03bb + 2 \u03bc ) \u03b7 = \u03bc / 2 ( cs * 1e-3 * 365 * 86400 ); # Bar\u00b7yr/mm Create a fault: 1 fa = fault ( StrikeSlipFault , ( 80. , 10. )); Generate grids: 1 gd = discretize ( fa ; nx = 160 , n\u03be = 20 , buffer_ratio = 1 ); Tip It is recommended (from Yajing Liu's personal communication) to add buffer zones adjacent the horizontal edges to immitate zero dislocation at the ridge region. Basically, it affects how the stiffness tensor are periodically summed. To what extent it alters the results remains further testing. Under the hood, it shall impose buffer areas on both sides of along-strike, each of which has a length of bufferratio/2*fa[:x] . Thus, the stiffness contributions falling into those buffer zone shall be neglected, which is equivalent to impose zero-slip correspondingly. Time for us to establish frictional parameters profile: 1 2 3 4 5 6 7 8 9 10 11 a = 0.015 .* ones ( gd . nx , gd . n\u03be ) b = 0.0115 .* ones ( gd . nx , gd . n\u03be ) left_patch = @ . - 25. \u2264 gd . x \u2264 - 5. right_patch = @ . 5. \u2264 gd . x \u2264 25. vert_patch = @ . - 6. \u2264 gd . z \u2264 - 1. b [ xor . ( left_patch , right_patch ), vert_patch ] .= 0.0185 amb = a - b \u03c3max = 500. \u03c3 = [ min ( \u03c3max , 15. + 180. * z ) for z in - gd . z ] \u03c3 = Matrix ( repeat ( \u03c3 , 1 , gd . nx ) ' ) L = 12. ; Check our profile: 1 2 3 4 5 6 7 8 9 10 11 12 13 p1 = heatmap ( amb ' , xticks = ( 0 : 10 / gd . \u0394x : gd . nx , - fa . span [ 1 ] / 2 : 10 : fa . span [ 1 ] / 2 ), yticks = ( 0 : 5 / gd . \u0394\u03be : gd . n\u03be , 0 : - 5 : - fa . span [ 2 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"a-b\" ); p2 = heatmap ( \u03c3 ' , xticks = ( 0 : 10 / gd . \u0394x : gd . nx , - fa . span [ 1 ] / 2 : 10 : fa . span [ 1 ] / 2 ), yticks = ( 0 : 5 / gd . \u0394\u03be : gd . n\u03be , 0 : - 5 : - fa . span [ 2 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \" \\\\ sigma\" ); plot ( p1 , p2 , layout = ( 2 , 1 )) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n a-b \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 0.003 \\n \\n \\n - \\n \\n \\n 0.002 \\n \\n \\n - \\n \\n \\n 0.001 \\n \\n \\n 0 \\n \\n \\n 0.001 \\n \\n \\n 0.002 \\n \\n \\n 0.003 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n \u03c3 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 100 \\n \\n \\n 150 \\n \\n \\n 200 \\n \\n \\n 250 \\n \\n \\n 300 \\n \\n \\n 350 \\n \\n \\n 400 \\n \\n \\n 450 \\n \\n \\n 500 \\n \\n \\n \\n \\n \\n \\n\")","title":"Define Parameters"},{"location":"examples/generated/otfsync/#construct-model","text":"Construct our material property profile: 1 mp = properties ( fa , gd , [ : a => a , : b => b , : L => L , : \u03c3 => \u03c3 , : \u03b7 => \u03b7 , : k => [ : \u03bb => \u03bb , : \u03bc => \u03bc ], : vpl => vpl , : f0 => f0 , : v0 => v0 ]); 1 2 [ Info: Calculating stiffness tensor ... [ Info: Fault material properties establised. Provide the initial condition: 1 2 3 vinit = vpl .* ones ( gd . nx , gd . n\u03be ) \u03b80 = L ./ vinit ./ 1.1 u0 = cat ( vinit , \u03b80 , dims = 3 ); Get our ODEs problem: 1 prob = EarthquakeCycleProblem ( gd , mp , u0 , ( 0. , 18. ); se = DieterichStateLaw (), fform = CForm ());","title":"Construct Model"},{"location":"examples/generated/otfsync/#solve-model","text":"Solve the model: 1 sol = solve ( prob , Tsit5 (), reltol = 1e-6 , abstol = 1e-6 );","title":"Solve Model"},{"location":"examples/generated/otfsync/#sanity-check-of-results","text":"Take a look at the max velocity: 1 2 maxv = max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , label = \"\" ) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 0 \\n \\n \\n 5 \\n \\n \\n 10 \\n \\n \\n 15 \\n \\n \\n -8 \\n \\n \\n -7 \\n \\n \\n -6 \\n \\n \\n -5 \\n \\n \\n -4 \\n \\n \\n -3 \\n \\n \\n -2 \\n \\n \\n Time (year) \\n \\n \\n Max Velocity (log10 (m/s)) \\n \\n \\n \\n\") View some snapshots to see the rupture (quasi-dynamic) patterns: 1 2 3 4 5 6 7 8 9 ind = argmax ( maxv ) myplot = ( ind ) -> heatmap ( log10 . ( sol . u [ ind ][ : , : , 1 ] ./ ms2mmyr ) ' , xticks = ( 0 : 10 / gd . \u0394x : gd . nx , - fa . span [ 1 ] / 2 : 10 : fa . span [ 1 ] / 2 ), yticks = ( 0 : 5 / gd . \u0394\u03be : gd . n\u03be , 0 : - 5 : - fa . span [ 2 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"t = $ ( sol . t [ ind ]) \" ) snaps = [ myplot ( i ) for i in ind - 700 : 200 : ind + 500 ] plot ( snaps ... , layout = ( length ( snaps ), 1 ), size = ( 600 , 1800 )) Documenter.Documents.RawHTML(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n t = 10.71973068412635 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.0 \\n \\n \\n - \\n \\n \\n 7.5 \\n \\n \\n - \\n \\n \\n 7.0 \\n \\n \\n - \\n \\n \\n 6.5 \\n \\n \\n - \\n \\n \\n 6.0 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n t = 10.831121338136795 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.50 \\n \\n \\n - \\n \\n \\n 8.25 \\n \\n \\n - \\n \\n \\n 8.00 \\n \\n \\n - \\n \\n \\n 7.75 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n -30.0 \\n \\n \\n -20.0 \\n \\n \\n -10.0 \\n \\n \\n 0.0 \\n \\n \\n 10.0 \\n \\n \\n 20.0 \\n \\n \\n 30.0 \\n \\n \\n 40.0 \\n \\n \\n 0.0 \\n \\n \\n -5.0 \\n \\n \\n -10.0 \\n \\n \\n t = 14.7651243515813 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 9.25 \\n \\n \\n - \\n \\n \\n 9.00 \\n \\n \\n - \\n \\n \\n 8.75 \\n \\n \\n - \\n \\n \\n 8.50 \\n \\n \\n - \\n \\n \\n 8.25 \\n \\n \\n - \\n \\n \\n 8.00 \\n \\n \\n - \\n \\n \\n 7.75 \\n \\n \\n - \\n \\n \\n 7.50 \\n \\n \\n - \\n \\n \\n 7.25 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n \\n \\n \\n \\n \\n -30.0 \\n \\n \\n \\n \\n \\n \\n \\n -20.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n 10.0 \\n \\n \\n \\n \\n \\n \\n \\n 20.0 \\n \\n \\n \\n \\n \\n \\n \\n 30.0 \\n \\n \\n \\n \\n \\n \\n \\n 40.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n -5.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n t = 14.896146309474766 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.5 \\n \\n \\n - \\n \\n \\n 8.0 \\n \\n \\n - \\n \\n \\n 7.5 \\n \\n \\n - \\n \\n \\n 7.0 \\n \\n \\n - \\n \\n \\n 6.5 \\n \\n \\n - \\n \\n \\n 6.0 \\n \\n \\n - \\n \\n \\n 5.5 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n \\n \\n \\n \\n \\n -30.0 \\n \\n \\n \\n \\n \\n \\n \\n -20.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n 10.0 \\n \\n \\n \\n \\n \\n \\n \\n 20.0 \\n \\n \\n \\n \\n \\n \\n \\n 30.0 \\n \\n \\n \\n \\n \\n \\n \\n 40.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n -5.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n t = 14.897556049396778 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.5 \\n \\n \\n - \\n \\n \\n 8.0 \\n \\n \\n - \\n \\n \\n 7.5 \\n \\n \\n - \\n \\n \\n 7.0 \\n \\n \\n - \\n \\n \\n 6.5 \\n \\n \\n - \\n \\n \\n 6.0 \\n \\n \\n - \\n \\n \\n 5.5 \\n \\n \\n - \\n \\n \\n 5.0 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n \\n \\n \\n \\n \\n -30.0 \\n \\n \\n \\n \\n \\n \\n \\n -20.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n 10.0 \\n \\n \\n \\n \\n \\n \\n \\n 20.0 \\n \\n \\n \\n \\n \\n \\n \\n 30.0 \\n \\n \\n \\n \\n \\n \\n \\n 40.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n -5.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n t = 14.913521453799735 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 8.25 \\n \\n \\n - \\n \\n \\n 8.00 \\n \\n \\n - \\n \\n \\n 7.75 \\n \\n \\n - \\n \\n \\n 7.50 \\n \\n \\n - \\n \\n \\n 7.25 \\n \\n \\n - \\n \\n \\n 7.00 \\n \\n \\n - \\n \\n \\n 6.75 \\n \\n \\n - \\n \\n \\n 6.50 \\n \\n \\n - \\n \\n \\n 6.25 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n -40.0 \\n \\n \\n \\n \\n \\n \\n \\n -30.0 \\n \\n \\n \\n \\n \\n \\n \\n -20.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n 10.0 \\n \\n \\n \\n \\n \\n \\n \\n 20.0 \\n \\n \\n \\n \\n \\n \\n \\n 30.0 \\n \\n \\n \\n \\n \\n \\n \\n 40.0 \\n \\n \\n \\n \\n \\n \\n \\n 0.0 \\n \\n \\n \\n \\n \\n \\n \\n -5.0 \\n \\n \\n \\n \\n \\n \\n \\n -10.0 \\n \\n \\n \\n \\n \\n \\n \\n t = 17.043707465146564 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n - \\n \\n \\n 9.75 \\n \\n \\n - \\n \\n \\n 9.50 \\n \\n \\n - \\n \\n \\n 9.25 \\n \\n \\n - \\n \\n \\n 9.00 \\n \\n \\n - \\n \\n \\n 8.75 \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\") This page was generated using Literate.jl .","title":"Sanity Check of Results"}]}