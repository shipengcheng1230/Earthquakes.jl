{
    "docs": [
        {
            "location": "/", 
            "text": "JuEQ.jl Documentation\n\n\n\n\nOverview\n\n\nThis is a suite for numerically simulating earthquake sequences in \nJulia\n. The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics.\n\n\nFeatures of this package are listed as below:\n\n\n\n\nRate-State Friction Law\n\n\nOkada's Dislocation Method\n\n\nBoundary Element Method (Quasi-dynamic)\n\n\n\n\nFeatures to be implemented:\n\n\n\n\nViscoelastic Relaxation\n (priority)\n\n\nFully Elastodynamic Effect\n\n\nOff-Fault Materials Effect\n\n\n\n\n\n\nInstallation\n\n\nGet the latest version with Julia's package manager:\n\n\n] add https://github.com/shipengcheng1230/JuEQ.jl\n\n\n\n\nTo load the package:\n\n\nusing JuEQ\n\n\n\n\n\n\nAcknowledgements\n\n\nThe simulation of episodic seismic and slow slip events using boundary-element-method is largely benifit from \nYajing Liu\n original Fortran code.", 
            "title": "Home"
        }, 
        {
            "location": "/#jueqjl-documentation", 
            "text": "", 
            "title": "JuEQ.jl Documentation"
        }, 
        {
            "location": "/#overview", 
            "text": "This is a suite for numerically simulating earthquake sequences in  Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics.  Features of this package are listed as below:   Rate-State Friction Law  Okada's Dislocation Method  Boundary Element Method (Quasi-dynamic)   Features to be implemented:   Viscoelastic Relaxation  (priority)  Fully Elastodynamic Effect  Off-Fault Materials Effect", 
            "title": "Overview"
        }, 
        {
            "location": "/#installation", 
            "text": "Get the latest version with Julia's package manager:  ] add https://github.com/shipengcheng1230/JuEQ.jl  To load the package:  using JuEQ", 
            "title": "Installation"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "The simulation of episodic seismic and slow slip events using boundary-element-method is largely benifit from  Yajing Liu  original Fortran code.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/quasi_dynamic_intro/", 
            "text": "Quasi-dynamic Simulation using BEM\n\n\n\n\nBasic Theory\n\n\nThe governing equation is that at every time step, shear stress across the fault plane equals to frictional force plus a radiation damping term for approximating wave propagation effect:\n\n\n\n\n\n\u03c4 = \u03c3f + \u03b7V\n\n\n\n\n\nHere $\u03bc$ is shear stress across the fault plain. Using \nOkada's dislocation theory\n, it can be shown as:\n\n\n\n\n\n\u03c4 = \\mathrm{K} \u2297 \u03b4\n\n\n\n\n\nwhere $\\mathrm{K}$ is the so-called stiffness tensor, depicting relationship between displacements at one position regarding to dislocations somewhere else. $\u03b4$ is the dislocation, i.e. displacement at everywhere on the fault. $\u2297$ denotes tensor contraction.\n\n\nBack to $f$, we use rate-and-state frictional law to calculate its value, specifically as below:\n\n\n\n\n\nf(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)}\n\n\n\n\n\nwhere $f_0$ and $V_0$ are reference friction coefficient and velocity, $V$ and $\u03b8$ are velocity and state variable based on which frictional force is. $a$ and $b$ are two frictional parameters denoting contributions each of which comes from velocity and state variable respectively. $L$ is critical distance after which frictional force return to new steady state.\n\n\nSometimes people use regularized form to avoid infinity when $V \u2248 0$, namely:\n\n\n\n\n\nf(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]}\n\n\n\n\n\nThere are many state evolution law that describes how state variable $\u03b8$ changes with time, one of which that most widely used is Dieterich law:\n\n\n\n\n\n\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}\n\n\n\n\n\nFurther, $\u03b7$ is a damping coefficient whose value is often chosen as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity and $\u03c3$ is the effective normal stress.\n\n\nTo simulate how fault evolves with time, we then take the derivative of the governing equation:\n\n\n\n\n\n\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\frac{\\mathrm{d} f(V, \u03b8)}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t}\n= \\frac{\\mathrm{d} f}{\\mathrm{d} V} \\frac{\\mathrm{d} V}{\\mathrm{d} t} + \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t}\n\n\n\n\n\nThus we arrive at:\n\n\n\n\n\n\\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} - \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t}}{\\frac{\\mathrm{d} f}{\\mathrm{d} V} + \u03b7}\n\n\n\n\n\nwhere $\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\mathrm{K} \u2297 (\\mathrm{V_{pl}} - V)$ where $\\mathrm{V_{pl}}$ is the plate rate.\n\n\n\n\nNote\n\n\nThe direction of relative velocity, namely $\\mathrm{V_{pl} - V}$, must be in accordance to the direction of $\\mathrm{K}$ which, here, we use the same meaning as Rice, J. (1993).\n\n\n\n\nHence, with both derivatives of velocity $V$ and state variable $\u03b8$, we are able to discover how fault evolves with various parameters settings.", 
            "title": "Basic Theory"
        }, 
        {
            "location": "/quasi_dynamic_intro/#quasi-dynamic-simulation-using-bem", 
            "text": "", 
            "title": "Quasi-dynamic Simulation using BEM"
        }, 
        {
            "location": "/quasi_dynamic_intro/#basic-theory", 
            "text": "The governing equation is that at every time step, shear stress across the fault plane equals to frictional force plus a radiation damping term for approximating wave propagation effect:   \n\u03c4 = \u03c3f + \u03b7V   Here $\u03bc$ is shear stress across the fault plain. Using  Okada's dislocation theory , it can be shown as:   \n\u03c4 = \\mathrm{K} \u2297 \u03b4   where $\\mathrm{K}$ is the so-called stiffness tensor, depicting relationship between displacements at one position regarding to dislocations somewhere else. $\u03b4$ is the dislocation, i.e. displacement at everywhere on the fault. $\u2297$ denotes tensor contraction.  Back to $f$, we use rate-and-state frictional law to calculate its value, specifically as below:   \nf(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)}   where $f_0$ and $V_0$ are reference friction coefficient and velocity, $V$ and $\u03b8$ are velocity and state variable based on which frictional force is. $a$ and $b$ are two frictional parameters denoting contributions each of which comes from velocity and state variable respectively. $L$ is critical distance after which frictional force return to new steady state.  Sometimes people use regularized form to avoid infinity when $V \u2248 0$, namely:   \nf(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]}   There are many state evolution law that describes how state variable $\u03b8$ changes with time, one of which that most widely used is Dieterich law:   \n\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}   Further, $\u03b7$ is a damping coefficient whose value is often chosen as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity and $\u03c3$ is the effective normal stress.  To simulate how fault evolves with time, we then take the derivative of the governing equation:   \n\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\frac{\\mathrm{d} f(V, \u03b8)}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t}\n= \\frac{\\mathrm{d} f}{\\mathrm{d} V} \\frac{\\mathrm{d} V}{\\mathrm{d} t} + \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t}   Thus we arrive at:   \n\\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} - \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t}}{\\frac{\\mathrm{d} f}{\\mathrm{d} V} + \u03b7}   where $\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\mathrm{K} \u2297 (\\mathrm{V_{pl}} - V)$ where $\\mathrm{V_{pl}}$ is the plate rate.   Note  The direction of relative velocity, namely $\\mathrm{V_{pl} - V}$, must be in accordance to the direction of $\\mathrm{K}$ which, here, we use the same meaning as Rice, J. (1993).   Hence, with both derivatives of velocity $V$ and state variable $\u03b8$, we are able to discover how fault evolves with various parameters settings.", 
            "title": "Basic Theory"
        }, 
        {
            "location": "/examples/generated/bp1/", 
            "text": "Note\n\n\nThis example is from \nBenchmark Problem 1\n (hence referred as BP1).\n\n\n\n\n\n\nDefine parameters\n\n\nFirst, we load the package\n\n\nusing JuEQ\nusing Plots\n\n\n\n\nInstead of using SI unit, we refactor ours into the follow:\n\n\nms2mmyr = 365 * 86400 * 1e3 # convert velocity from m/s to mm/yr\n\u03c1 = 2670.0 # density [kg/m\u00b3]\nvs = 3464.0 # shear wave velocity [m/s]\n\u03c3 = 500.0 # effective normal stress [bar]\na0 = 0.010 # frictional paramter `a` in vw zone\namax = 0.025 # frictional paramter `a` in vs zone\nb0 = 0.015 # frictional paramter `b`\nL = 8.0 # critical distance [mm]\nvpl = 1e-9 * ms2mmyr # plate rate [mm/yr]\nvinit = 1e-9 * ms2mmyr # initial velocity [mm/yr]\nv0 = 1e-6 * ms2mmyr # reference velocity [mm/yr]\nf0 = 0.6 # reference frictional coefficient\nH = 15.0 # vw zone [km]\nh = 3.0 # vw-vs changing zone [km]\nWf = 40.0 # fault depth [km]\n\u0394z = 100.0e-3 # grid size interval [km]\ntf = 400.0; # simulation time [yr]\n\n\n\n\n\n\nWarning\n\n\nMake sure your units are consistent across the whole variable space. Pontenial imporvement may incoporate \nUnitful.jl\n package.\n\n\n\n\nThen we arrive at some parameters that are implicit by above:\n\n\n\u03bc = vs^2 * \u03c1 / 1e5 / 1e6 # shear modulus [bar\u00b7km/mm]\n\u03bb = \u03bc # poisson material\n\u03b7 = \u03bc / 2(vs * 1e-3 * 365 * 86400)\nngrid = round(Int, Wf / \u0394z); # number of grids\n\n\n\n\nNow, we start to construct our model using parameters above. First, we create a 'fault' by specifying fault type and depth:\n\n\n\n\nTip\n\n\nHere, we do not need to provide \ndip\n for strike-slip fault as it automatically choose \n90\n. See \nfault\n.\n\n\n\n\n\n\nConstruct Model\n\n\nfa = fault(StrikeSlipFault, Wf);\n\n\n\n\nNext, we generate the grid regarding the \nfault\n we just created by giving number of grids:\n\n\n\n\nNote\n\n\nThis package use \n\u03be\n for denoting downdip coordinate and \nx\n for along-strike one. See \ndiscretize\n.\n\n\n\n\ngd = discretize(fa; n\u03be=ngrid);\n\n\n\n\nNext, we construct the required frictional parameter profile:\n\n\nz = -gd.\u03be\naz = fill(a0, size(z))\naz[z .\u2265 (H + h)] .= amax\naz[H .\n z .\n H + h] = a0 .+ (amax - a0) / (h / \u0394z) * collect(1: Int(h / \u0394z));\n\n\n\n\nThen, we provide the required initial condition satisfying uniform slip distribution over the depth:\n\n\n\u03c40 = \u03c3 * amax * asinh(vinit / 2v0 * exp((f0 + b0 * log(v0 / vinit)) / amax)) + \u03b7 * vinit\n\u03c4z = fill(\u03c40, size(z))\n\u03b8z = @. L / v0 * exp(az / b0 * log(2v0 / vinit * sinh((\u03c4z - \u03b7 * vinit) / az / \u03c3)) - f0 / b0)\nvz = fill(vinit, size(z))\nu0 = hcat(vz, \u03b8z);\n\n\n\n\nLet's simulate only the first 200 years:\n\n\ntspan = (0., 200.);\n\n\n\n\nFinally, we provide the material properties w.r.t. our 'fault', 'grid' as well as other necessary parameters predefined using the same grid size \n dimension:\n\n\nmp = properties(;fault=fa, grid=gd, parameters=[:a=\naz, :b=\nb0, :L=\nL, :\u03c3=\n\u03c3, :\u03b7=\n\u03b7, :k=\n[:\u03bb=\n\u03bb, :\u03bc=\n\u03bc], :vpl=\nvpl, :f0=\nf0, :v0=\nv0]);\n\n\n\n\n[ Info: Calculating stiffness tensor ...\n[ Info: Fault material properties establised.\n\n\n\n\n\n\nTip\n\n\nCheck \nproperties\n for extended options.\n\n\n\n\nCheck our profile now:\n\n\nplot([mp.a, mp.b], z, label=[\na\n, \nb\n], yflip=true, ylabel=\nDepth (km)\n)\n\n\n\n\nDocumenter.Documents.RawHTML(\"\n?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n0.012\n\\n\n\\n\n\\n\n0.015\n\\n\n\\n\n\\n\n0.018\n\\n\n\\n\n\\n\n0.021\n\\n\n\\n\n\\n\n0.024\n\\n\n\\n\n\\n\n0\n\\n\n\\n\n\\n\n10\n\\n\n\\n\n\\n\n20\n\\n\n\\n\n\\n\n30\n\\n\n\\n\n\\n\n40\n\\n\n\\n\n\\n\nDepth (km)\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\na\n\\n\n\\n\n\\n\n\\n\nb\n\\n\n\\n\n\\n\")\n\n\nWe then contruct the \nODEProblem\n as following by stating which state evolution law to use and frcitonal law form, plus initial condition and simulation time:\n\n\nprob = EarthquakeCycleProblem(gd, mp, u0, tspan; se=DieterichStateLaw(), fform=RForm());\n\n\n\n\n\n\nSolve Model\n\n\nWe then solve the ODEs:\n\n\nsol = solve(prob, Tsit5(), reltol=1e-6, abstol=1e-6);\n\n\n\n\n\n\nTip\n\n\nFor details of solving options, see \nhere\n.\n\n\n\n\n\n\nTip\n\n\nRaise the accuracy option if you get instability when solving these ODEs.\n\n\n\n\n\n\nResults\n\n\nThe first event happens at around 196 year:\n\n\nmaxv = max_velocity(sol)\nplot(sol.t, log10.(maxv / ms2mmyr), xlabel=\nTime (year)\n, ylabel=\nMax Velocity (log10 (m/s))\n, xlims=(190, 200), label=\n)\n\n\n\n\nDocumenter.Documents.RawHTML(\"\n?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n190.0\n\\n\n\\n\n\\n\n192.5\n\\n\n\\n\n\\n\n195.0\n\\n\n\\n\n\\n\n197.5\n\\n\n\\n\n\\n\n200.0\n\\n\n\\n\n\\n\n-8\n\\n\n\\n\n\\n\n-6\n\\n\n\\n\n\\n\n-4\n\\n\n\\n\n\\n\n-2\n\\n\n\\n\n\\n\n0\n\\n\n\\n\n\\n\nTime (year)\n\\n\n\\n\n\\n\nMax Velocity (log10 (m/s))\n\\n\n\\n\n\\n\n\\n\")\n\n\n\n\nNote\n\n\nClick \nhere\n for the slip evolution over 3000 years simulation. It may need some time to load the page.\n\n\n\n\nThis page was generated using \nLiterate.jl\n.", 
            "title": "Example 1D"
        }, 
        {
            "location": "/examples/generated/bp1/#define-parameters", 
            "text": "First, we load the package  using JuEQ\nusing Plots  Instead of using SI unit, we refactor ours into the follow:  ms2mmyr = 365 * 86400 * 1e3 # convert velocity from m/s to mm/yr\n\u03c1 = 2670.0 # density [kg/m\u00b3]\nvs = 3464.0 # shear wave velocity [m/s]\n\u03c3 = 500.0 # effective normal stress [bar]\na0 = 0.010 # frictional paramter `a` in vw zone\namax = 0.025 # frictional paramter `a` in vs zone\nb0 = 0.015 # frictional paramter `b`\nL = 8.0 # critical distance [mm]\nvpl = 1e-9 * ms2mmyr # plate rate [mm/yr]\nvinit = 1e-9 * ms2mmyr # initial velocity [mm/yr]\nv0 = 1e-6 * ms2mmyr # reference velocity [mm/yr]\nf0 = 0.6 # reference frictional coefficient\nH = 15.0 # vw zone [km]\nh = 3.0 # vw-vs changing zone [km]\nWf = 40.0 # fault depth [km]\n\u0394z = 100.0e-3 # grid size interval [km]\ntf = 400.0; # simulation time [yr]   Warning  Make sure your units are consistent across the whole variable space. Pontenial imporvement may incoporate  Unitful.jl  package.   Then we arrive at some parameters that are implicit by above:  \u03bc = vs^2 * \u03c1 / 1e5 / 1e6 # shear modulus [bar\u00b7km/mm]\n\u03bb = \u03bc # poisson material\n\u03b7 = \u03bc / 2(vs * 1e-3 * 365 * 86400)\nngrid = round(Int, Wf / \u0394z); # number of grids  Now, we start to construct our model using parameters above. First, we create a 'fault' by specifying fault type and depth:   Tip  Here, we do not need to provide  dip  for strike-slip fault as it automatically choose  90 . See  fault .", 
            "title": "Define parameters"
        }, 
        {
            "location": "/examples/generated/bp1/#construct-model", 
            "text": "fa = fault(StrikeSlipFault, Wf);  Next, we generate the grid regarding the  fault  we just created by giving number of grids:   Note  This package use  \u03be  for denoting downdip coordinate and  x  for along-strike one. See  discretize .   gd = discretize(fa; n\u03be=ngrid);  Next, we construct the required frictional parameter profile:  z = -gd.\u03be\naz = fill(a0, size(z))\naz[z .\u2265 (H + h)] .= amax\naz[H .  z .  H + h] = a0 .+ (amax - a0) / (h / \u0394z) * collect(1: Int(h / \u0394z));  Then, we provide the required initial condition satisfying uniform slip distribution over the depth:  \u03c40 = \u03c3 * amax * asinh(vinit / 2v0 * exp((f0 + b0 * log(v0 / vinit)) / amax)) + \u03b7 * vinit\n\u03c4z = fill(\u03c40, size(z))\n\u03b8z = @. L / v0 * exp(az / b0 * log(2v0 / vinit * sinh((\u03c4z - \u03b7 * vinit) / az / \u03c3)) - f0 / b0)\nvz = fill(vinit, size(z))\nu0 = hcat(vz, \u03b8z);  Let's simulate only the first 200 years:  tspan = (0., 200.);  Finally, we provide the material properties w.r.t. our 'fault', 'grid' as well as other necessary parameters predefined using the same grid size   dimension:  mp = properties(;fault=fa, grid=gd, parameters=[:a= az, :b= b0, :L= L, :\u03c3= \u03c3, :\u03b7= \u03b7, :k= [:\u03bb= \u03bb, :\u03bc= \u03bc], :vpl= vpl, :f0= f0, :v0= v0]);  [ Info: Calculating stiffness tensor ...\n[ Info: Fault material properties establised.   Tip  Check  properties  for extended options.   Check our profile now:  plot([mp.a, mp.b], z, label=[ a ,  b ], yflip=true, ylabel= Depth (km) )  Documenter.Documents.RawHTML(\" ?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"? \\n \\n \\n   \\n     \\n   \\n \\n \\n   \\n     \\n   \\n \\n \\n \\n   \\n     \\n   \\n \\n \\n \\n   \\n     \\n   \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 0.012 \\n \\n \\n 0.015 \\n \\n \\n 0.018 \\n \\n \\n 0.021 \\n \\n \\n 0.024 \\n \\n \\n 0 \\n \\n \\n 10 \\n \\n \\n 20 \\n \\n \\n 30 \\n \\n \\n 40 \\n \\n \\n Depth (km) \\n \\n \\n \\n \\n \\n \\n \\n a \\n \\n \\n \\n b \\n \\n \\n\")  We then contruct the  ODEProblem  as following by stating which state evolution law to use and frcitonal law form, plus initial condition and simulation time:  prob = EarthquakeCycleProblem(gd, mp, u0, tspan; se=DieterichStateLaw(), fform=RForm());", 
            "title": "Construct Model"
        }, 
        {
            "location": "/examples/generated/bp1/#solve-model", 
            "text": "We then solve the ODEs:  sol = solve(prob, Tsit5(), reltol=1e-6, abstol=1e-6);   Tip  For details of solving options, see  here .    Tip  Raise the accuracy option if you get instability when solving these ODEs.", 
            "title": "Solve Model"
        }, 
        {
            "location": "/examples/generated/bp1/#results", 
            "text": "The first event happens at around 196 year:  maxv = max_velocity(sol)\nplot(sol.t, log10.(maxv / ms2mmyr), xlabel= Time (year) , ylabel= Max Velocity (log10 (m/s)) , xlims=(190, 200), label= )  Documenter.Documents.RawHTML(\" ?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"? \\n \\n \\n   \\n     \\n   \\n \\n \\n   \\n     \\n   \\n \\n \\n \\n   \\n     \\n   \\n \\n \\n \\n   \\n     \\n   \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n 190.0 \\n \\n \\n 192.5 \\n \\n \\n 195.0 \\n \\n \\n 197.5 \\n \\n \\n 200.0 \\n \\n \\n -8 \\n \\n \\n -6 \\n \\n \\n -4 \\n \\n \\n -2 \\n \\n \\n 0 \\n \\n \\n Time (year) \\n \\n \\n Max Velocity (log10 (m/s)) \\n \\n \\n \\n\")   Note  Click  here  for the slip evolution over 3000 years simulation. It may need some time to load the page.   This page was generated using  Literate.jl .", 
            "title": "Results"
        }, 
        {
            "location": "/examples/generated/otfsync/", 
            "text": "Note\n\n\nThis example is adapted from \nWei, 2016 AGU\n\n\n\n\n\n\nTip\n\n\nIt will automatically use parallel scheme if \nnprocs() \u2242\u0338 1\n when building stiffness tensor. To do so:\n\n\njulia\nusing Distributed\naddprocs(4); # add # of cores you desire\nusing JuEQ\n\n\n\n\nFirst, we load the package and define some basic parameters:\n\n\nusing JuEQ\nusing Plots\n\nms2mmyr = 365 * 86400 * 1e3\n\u03c1 = 2670.0 # kg/m\u00b3\ncs = 3044.0 # m/s\nvpl = 100.0 # mm/yr\nv0 = 3.2e4 # mm/yr\nf0 = 0.6;\n\n\n\n\nThen we come to parameters implicit by above:\n\n\n\u03bc = 0.3 # Bar\u00b7km/mm\n\u03bb = \u03bc # poisson material\n\u03b1 = (\u03bb + \u03bc) / (\u03bb + 2\u03bc)\n\u03b7 = \u03bc / 2(cs * 1e-3 * 365 * 86400); # Bar\u00b7yr/mm\n\n\n\n\nCreate a fault:\n\n\nfa = fault(StrikeSlipFault, (80., 10.));\n\n\n\n\nGenerate grids:\n\n\ngd = discretize(fa; nx=160, n\u03be=20, buffer_ratio=1);\n\n\n\n\n\n\nTip\n\n\nIt is recommended (from Yajing Liu's personal communication) to add buffer zones adjacent the horizontal edges to immitate \nzero\n dislocation at the ridge region. Basically, it affects how the stiffness tensor are periodically summed. To what extent it alters the results remains further testing.\n\n\nUnder the hood, it shall impose buffer areas on both sides of along-strike, each of which has a length of \nbufferratio/2*fa[:x]\n. Thus, the stiffness contributions falling into those buffer zone shall be neglected, which is equivalent to impose zero-slip correspondingly.\n\n\n\n\nTime for us to establish frictional parameters profile:\n\n\na = 0.015 .* ones(gd.nx, gd.n\u03be)\nb = 0.0115 .* ones(gd.nx, gd.n\u03be)\nleft_patch = @. -25. \u2264 gd.x \u2264 -5.\nright_patch = @. 5. \u2264 gd.x \u2264 25.\nvert_patch = @. -6. \u2264 gd.z \u2264 -1.\nb[xor.(left_patch, right_patch), vert_patch] .= 0.0185\namb = a - b\n\u03c3max = 500.\n\u03c3 = [min(\u03c3max, 15. + 180. * z) for z in -gd.z]\n\u03c3 = Matrix(repeat(\u03c3, 1, gd.nx)')\nL = 12.;\n\n\n\n\nCheck our profile:\n\n\np1 = heatmap(amb',\n    xticks=(0: 10/gd.\u0394x: gd.nx, -fa.span[1]/2: 10: fa.span[1]/2),\n    yticks=(0: 5/gd.\u0394\u03be: gd.n\u03be, 0: -5: -fa.span[2]),\n    yflip=true, color=:isolum, aspect_ratio=2, title=\na-b\n\n    );\n\np2 = heatmap(\u03c3',\n    xticks=(0: 10/gd.\u0394x: gd.nx, -fa.span[1]/2: 10: fa.span[1]/2),\n    yticks=(0: 5/gd.\u0394\u03be: gd.n\u03be, 0: -5: -fa.span[2]),\n    yflip=true, color=:isolum, aspect_ratio=2, title=\n\\\\sigma\n\n    );\n\nplot(p1, p2, layout=(2, 1))\n\n\n\n\nDocumenter.Documents.RawHTML(\"\n?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\na-b\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n0.003\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n0.002\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n0.001\n\\n\n\\n\n\\n\n0\n\\n\n\\n\n\\n\n0.001\n\\n\n\\n\n\\n\n0.002\n\\n\n\\n\n\\n\n0.003\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\n\u03c3\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n100\n\\n\n\\n\n\\n\n150\n\\n\n\\n\n\\n\n200\n\\n\n\\n\n\\n\n250\n\\n\n\\n\n\\n\n300\n\\n\n\\n\n\\n\n350\n\\n\n\\n\n\\n\n400\n\\n\n\\n\n\\n\n450\n\\n\n\\n\n\\n\n500\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\")\n\n\nConstruct our material property profile:\n\n\nmp = properties(fa, gd, [:a=\na, :b=\nb, :L=\nL, :\u03c3=\n\u03c3, :\u03b7=\n\u03b7, :k=\n[:\u03bb=\n\u03bb, :\u03bc=\n\u03bc], :vpl=\nvpl, :f0=\nf0, :v0=\nv0]);\n\n\n\n\n[ Info: Calculating stiffness tensor ...\n[ Info: Fault material properties establised.\n\n\n\n\nProvide the initial condition:\n\n\nvinit = vpl .* ones(gd.nx, gd.n\u03be)\n\u03b80 = L ./ vinit ./ 1.1\nu0 = cat(vinit, \u03b80, dims=3);\n\n\n\n\nGet our ODEs problem:\n\n\nprob = EarthquakeCycleProblem(gd, mp, u0, (0., 18.); se=DieterichStateLaw(), fform=CForm());\n\n\n\n\nSolve the model:\n\n\nsol = solve(prob, Tsit5(), reltol=1e-6, abstol=1e-6);\n\n\n\n\nTake a look at the max velocity:\n\n\nmaxv = max_velocity(sol)\nplot(sol.t, log10.(maxv / ms2mmyr), xlabel=\nTime (year)\n, ylabel=\nMax Velocity (log10 (m/s))\n, label=\n)\n\n\n\n\nDocumenter.Documents.RawHTML(\"\n?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n0\n\\n\n\\n\n\\n\n5\n\\n\n\\n\n\\n\n10\n\\n\n\\n\n\\n\n15\n\\n\n\\n\n\\n\n-8\n\\n\n\\n\n\\n\n-7\n\\n\n\\n\n\\n\n-6\n\\n\n\\n\n\\n\n-5\n\\n\n\\n\n\\n\n-4\n\\n\n\\n\n\\n\n-3\n\\n\n\\n\n\\n\n-2\n\\n\n\\n\n\\n\nTime (year)\n\\n\n\\n\n\\n\nMax Velocity (log10 (m/s))\n\\n\n\\n\n\\n\n\\n\")\n\n\nView some snapshots to see the rupture (quasi-dynamic) patterns:\n\n\nind = argmax(maxv)\nmyplot = (ind) -\n heatmap(log10.(sol.u[ind][:,:,1]./ms2mmyr)',\n    xticks=(0: 10/gd.\u0394x: gd.nx, -fa.span[1]/2: 10: fa.span[1]/2),\n    yticks=(0: 5/gd.\u0394\u03be: gd.n\u03be, 0: -5: -fa.span[2]),\n    yflip=true, color=:isolum, aspect_ratio=2, title=\nt = $(sol.t[ind])\n)\n\nsnaps = [myplot(i) for i in ind-700: 200: ind+500]\n\nplot(snaps..., layout=(length(snaps), 1), size=(600, 1800))\n\n\n\n\nDocumenter.Documents.RawHTML(\"\n?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\nt = 10.719730684126537\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.0\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.0\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.0\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\nt = 10.831121338149241\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.50\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.25\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.00\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.75\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n\nt = 14.765124351512933\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n9.25\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n9.00\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.75\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.50\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.25\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.00\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.75\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.50\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.25\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\nt = 14.896146309474155\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.0\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.0\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.0\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n5.5\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\nt = 14.897556049396742\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.0\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.0\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.0\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n5.5\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n5.0\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\nt = 14.91352145379932\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.25\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.00\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.75\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.50\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.25\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n7.00\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.75\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.50\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n6.25\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-40.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-30.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-20.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n20.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n30.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n40.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n0.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-5.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n-10.0\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\nt = 17.04370745093445\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n9.75\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n9.50\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n9.25\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n9.00\n\\n\n\\n\n\\n\n-\n\\n\n\\n\n\\n\n8.75\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n  \n\\n    \n\\n  \n\\n\n\\n\n\\n\")\n\n\nThis page was generated using \nLiterate.jl\n.", 
            "title": "Example 2D"
        }, 
        {
            "location": "/public_interface/", 
            "text": "Public Interface\n\n\n\n\nIndex\n\n\n\n\nJuEQ.DieterichStateLaw\n\n\nJuEQ.PrzStateLaw\n\n\nJuEQ.RuinaStateLaw\n\n\nJuEQ.DECallbackSaveToFile\n\n\nJuEQ.EarthquakeCycleProblem\n\n\nJuEQ.dc3d_okada\n\n\nJuEQ.discretize\n\n\nJuEQ.discretize\n\n\nJuEQ.fault\n\n\nJuEQ.friction\n\n\nJuEQ.max_velocity\n\n\nJuEQ.moment_magnitude\n\n\nJuEQ.properties\n\n\nJuEQ.stiffness_tensor\n\n\n\n\n\n\nInterfaces\n\n\n#\n\n\nJuEQ.DieterichStateLaw\n \n \nType\n.\n\n\n$\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}$\n\n\n#\n\n\nJuEQ.PrzStateLaw\n \n \nType\n.\n\n\n$\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - (\\frac{V \u03b8}{2L})^2$\n\n\n#\n\n\nJuEQ.RuinaStateLaw\n \n \nType\n.\n\n\n$\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\frac{V \u03b8}{L}}$\n\n\n#\n\n\nJuEQ.DECallbackSaveToFile\n \n \nMethod\n.\n\n\nDECallbackSaveToFile(iot::IOStream, iou::IOStream)\n\n\n\n\nConstruct a functional callback to write \nODESolution\n (\nt\n \n \nu\n) into file. The reason to separate \nt\n and \nu\n is for more easily reshape \nu\n w.r.t grids specification. It right now falls on users' memory on what the type of solution is for accurately retrieving results.\n\n\nArguments\n\n\n\n\niot::IOStream\n: stream pointing to solution of time\n\n\niou::IOStream\n: stream pointing to solution of domain\n\n\n\n\nNote\n It is strongly not recommended to use \"skipping\" scheme (by defining \nthrd\n and \ndts(a)\n for each case) when solution is too oscillated.\n\n\n#\n\n\nJuEQ.EarthquakeCycleProblem\n \n \nMethod\n.\n\n\nEarthquakeCycleProblem(p::PlaneMaterialProperties, u0, tspan; se=DieterichStateLaw(), fform=CForm())\n\n\n\n\nReturn an \nODEProblem\n that encapsulate all the parameters and functions required for simulation. For the entailing usage, please refer \nDifferentialEquations.jl\n\n\nArguments\n\n\n\n\ngd::BoundaryElementGrid\n: grids for fault domain.\n\n\np::PlaneMaterialProperties\n: material profile.\n\n\nu0::AbstractArray\n: initial condition, should be organized such that the first of last dim is velocity while the 2nd of last dim is state.\n\n\ntspan::NTuple\n: time interval to be simulated.\n\n\nse::StateEvolutionLaw\n: state evolution law to be applied.\n\n\nfform::FrictionLawForm\n: forms of frictional law to be applied.\n\n\n\n\n#\n\n\nJuEQ.dc3d_okada\n \n \nMethod\n.\n\n\nCalculate displacements and gradient of displacements due to a dislocation in an elastic isotropic halfspace. See \ndc3d\n for details.\n\n\ntest/test_okada.dat\n is obtained using \nDC3dfortran\n\n\nAn example wrapper for DC3D in julia as below:\n\n\nfunction dc3d_fortran(x::T, y::T, z::T, \u03b1::T, dep::T, dip::T, al1::T, al2::T, aw1::T, aw2::T,\n    disl1::T, disl2::T, disl3::T) where {T \n: AbstractFloat}\n\n    # initial return values\n    # `RefValue{T}` may be also viable other than `Array{T, 1}`\n    ux = Array{Float64}(1)\n    uy = Array{Float64}(1)\n    uz = Array{Float64}(1)\n    uxx = Array{Float64}(1)\n    uyx = Array{Float64}(1)\n    uzx = Array{Float64}(1)\n    uxy = Array{Float64}(1)\n    uyy = Array{Float64}(1)\n    uzy = Array{Float64}(1)\n    uxz = Array{Float64}(1)\n    uyz = Array{Float64}(1)\n    uzz = Array{Float64}(1)\n    iret = Array{Int64}(1)\n\n    # call okada's code which is renamed as \n__dc3d__\n (see binding rename shown below)\n    # input args tuple must be syntactically written instead of a variable assigned\n    # macros could be used to simplify this in the future\n    ccall((:__dc3d__, \ndc3d.so\n), Void,\n        (\n            Ref{Float64},\n            Ref{Float64}, Ref{Float64}, Ref{Float64}, Ref{Float64},\n            Ref{Float64}, Ref{Float64}, Ref{Float64}, Ref{Float64},\n            Ref{Float64}, Ref{Float64}, Ref{Float64}, Ref{Float64},\n            Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}},\n            Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}},\n            Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}},\n            Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}},\n            Ref{Int64},\n        ),\n        \u03b1, x, y, z, dep, dip, al1, al2, aw1, aw2, disl1, disl2, disl3,\n        ux, uy, uz, uxx, uyx, uzx, uxy, uyy, uzy, uxz, uyz, uzz,\n        iret,\n    )\n\n    # results valid iff iret[1] == 0\n    return (\n        iret[1],\n        ux[1], uy[1], uz[1],\n        uxx[1], uyx[1], uzx[1],\n        uxy[1], uyy[1], uzy[1],\n        uxz[1], uyz[1], uzz[1]\n    )\nend\n\n\n\n\nThe corresponding fortran module is:\n\n\nMODULE okada\n  USE, INTRINSIC :: iso_c_binding\n  IMPLICIT NONE\nCONTAINS\n\n  SUBROUTINE dc3d_wrapper(\n\n       \n alpha, \n\n       \n x, y, z, \n\n       \n depth, dip, \n\n       \n al1, al2, \n\n       \n aw1, aw2, \n\n       \n disl1, disl2, disl3, \n\n       \n ux, uy, uz, \n\n       \n uxx, uyx, uzx, \n\n       \n uxy, uyy, uzy, \n\n       \n uxz, uyz, uzz, \n\n       \n iret) BIND(C, NAME='__dc3d__')\n\n    REAL*8 :: \n\n         \n alpha, \n\n         \n x, y, z, \n\n         \n depth, dip, \n\n         \n al1, al2, \n\n         \n aw1, aw2, \n\n         \n disl1, disl2, disl3, \n\n         \n ux, uy, uz, \n\n         \n uxx, uyx, uzx, \n\n         \n uxy, uyy, uzy, \n\n         \n uxz, uyz, uzz\n\n    INTEGER*8 :: iret\n\n    CALL dc3d(\n\n         \n alpha, \n\n         \n x, y, z, \n\n         \n depth, dip, \n\n         \n al1, al2, \n\n         \n aw1, aw2, \n\n         \n disl1, disl2, disl3, \n\n         \n ux, uy, uz, \n\n         \n uxx, uyx, uzx, \n\n         \n uxy, uyy, uzy, \n\n         \n uxz, uyz, uzz, \n\n         \n iret)\n\n  END SUBROUTINE dc3d_wrapper\n\nEND MODULE okada\n\n\n\n\nA sample of makefile is as below:\n\n\n# Build Okada's code for calculating deformation due to a fault model\n#\nCC = gfortran\nCFLAGS = -fPIC -w -O3\nLDFLAGS = -shared\n\nSRCS = dc3d.f okada.f90\nOBJS = $(SRCS:.c=.o)\n\nTARGET = dc3d.so\n\n$(TARGET): $(OBJS)\n    $(CC) $(CFLAGS) $(LDFLAGS) -o $(TARGET) $(OBJS)\n\n\n\n\n#\n\n\nJuEQ.discretize\n \n \nMethod\n.\n\n\ndiscretize(fa::PlaneFaultDomain{ftype, 1}, \u0394\u03be::T; ax_ratio=12.5)\n\n\n\n\nGenerate the grid for given 1D fault domain. The grids will be forced to start at (x=0, y=0, z=0).\n\n\nArguments\n\n\n\n\n\u0394\u03be\n: grid space along-downdip\n\n\nax_ratio::Number\n: ration of along-strike length agsinst along-downdip length for mimicing an extended   2d (x \n \u03be) fault represented by 1d (\u03be) domain. Default \nax_ratio=12.5\n is more than enough for producing consistent results.\n\n\n\n\n#\n\n\nJuEQ.discretize\n \n \nMethod\n.\n\n\ndiscretize(fa::PlaneFaultDomain{ftype, 2}, \u0394x, \u0394\u03be; buffer=:auto) where {ftype \n: PlaneFault}\n\n\n\n\nGenerate the grid for given 2D fault domain. The grids will be forced to start at (z=0) and spread symmetrically along x-axis w.r.t y-z plane.     By such setting, we would be able to utilize the symmetry properties of stiffness tensor for performance speed up.\n\n\nArguments\n\n\n\n\n\u0394x, \u0394\u03be\n: grid space along-strike and along-downdip respectively\n\n\n`buffer_ratio::Number: ration of buffer size against along-strike length for introducing \nzero-dislocation\n area at along-strike edges of defined fault domain.\n\n\n\n\n#\n\n\nJuEQ.fault\n \n \nMethod\n.\n\n\nfault(ftype::Type{\n:PlaneFault}, dip, span)\n\n\n\n\nGenerate a fault given the fault type, dip angle and its spatial span.\n\n\nArguments\n\n\n\n\nftype::Type{\n:PlaneFault}\n: type of plane fault\n\n\ndip\n: dip angle in degree\n\n\nspan\n: spatial span of fault size\n\n\n\n\n#\n\n\nJuEQ.friction\n \n \nMethod\n.\n\n\nfriction(::FrictionLawForm, v::T, \u03b8::T, L::T, a::T, b::T, f0::T, v0::T) where {T\n:Number}\n\n\n\n\nCalculate friction given by the form of fomula as well as other necessary parameters.\n\n\n\n\nConventional Form:\n\n\n\n\n\n\n\nf(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)}\n\n\n\n\n\n\n\nRegularized Form:\n\n\n\n\n\n\n\nf(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]}\n\n\n\n\n\n#\n\n\nJuEQ.max_velocity\n \n \nMethod\n.\n\n\nmax_velocity(t::AbstractVector, u::AbstractArray, getu::Function)\n\n\n\n\nReturn max velocity across the fault at each time step. A number of convenient interfaces for common output are implemented.\n\n\nArguments\n\n\n\n\nt::AbstractVector\n: vector of time steps\n\n\nu::AbstractArray\n: array of solution\n\n\ngetu::Function\n: method for retrieving velocity section at each time step\n\n\n\n\n#\n\n\nJuEQ.moment_magnitude\n \n \nMethod\n.\n\n\nCalculate moment magnitude.\n\n\n#\n\n\nJuEQ.properties\n \n \nMethod\n.\n\n\nproperties(fa::PlaneFaultDomain, gd::BoundaryElementGrid{dim}; _kwargs...) where {dim}\n\n\n\n\nEstablishing a material-properties-profile given by the fault domain and grids. User must provide the     necessary parameters in according to the grid size specified or just a scalar for broadcasting.\n\n\nArguments that are required:\n\n\n\n\na\n: contrib from velocity.\n\n\nb\n: contrib from state.\n\n\nL\n: critical distance.\n\n\n\u03c3\n: effective normal stress.\n\n\n\u03b7\n: radiation damping. It is recommended to set as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is \nshear modulus\n and $\\mathrm{Vs}$ shear wave velocity.\n\n\nvpl\n: plate rate.\n\n\nf0\n: ref. frictional coeff.\n\n\nv0\n: ref. velocity.\n\n\n\n\nArguments that need options\n\n\n\n\n\n\nk\n: stiffness tensor.\n\n\n(1) Providing \nshear modulus\n denoted as \n\u03bc\n and \nLam\u00e9's first parameter\n denoted as \n\u03bb\n (same as \n\u03bc\n if missing),  then calculate it based on grid and fault domain, choosing parallel scheme if \nnprocs() != 1\n.  (2) an \nAbstractArray\n represent the pre-calculated stiffness tensor. No verification will be performed here.\n\n\n\n\n\n\n#\n\n\nJuEQ.stiffness_tensor\n \n \nMethod\n.\n\n\nstiffness_tensor(fa::PlaneFaultDomain, gd::BoundaryElementGrid, ep::HomogeneousElasticProperties)\n\n\n\n\nCalculate the reduced stiffness tensor. For 2D fault, the final result will be dimensionally reduced to a 3D array     due to the \ntranslational\n \n \nreflective\n \n \nperodic\n symmetry, such that the tensor contraction will be equivalent to convolution,     hence we could use FFT for better performace.\n\n\nNote\n\n\n\n\nFaults are originated from surface and extends downwards, thus \ndep = 0", 
            "title": "Public"
        }, 
        {
            "location": "/public_interface/#public-interface", 
            "text": "", 
            "title": "Public Interface"
        }, 
        {
            "location": "/public_interface/#index", 
            "text": "JuEQ.DieterichStateLaw  JuEQ.PrzStateLaw  JuEQ.RuinaStateLaw  JuEQ.DECallbackSaveToFile  JuEQ.EarthquakeCycleProblem  JuEQ.dc3d_okada  JuEQ.discretize  JuEQ.discretize  JuEQ.fault  JuEQ.friction  JuEQ.max_velocity  JuEQ.moment_magnitude  JuEQ.properties  JuEQ.stiffness_tensor", 
            "title": "Index"
        }, 
        {
            "location": "/public_interface/#interfaces", 
            "text": "#  JuEQ.DieterichStateLaw     Type .  $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}$  #  JuEQ.PrzStateLaw     Type .  $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - (\\frac{V \u03b8}{2L})^2$  #  JuEQ.RuinaStateLaw     Type .  $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\frac{V \u03b8}{L}}$  #  JuEQ.DECallbackSaveToFile     Method .  DECallbackSaveToFile(iot::IOStream, iou::IOStream)  Construct a functional callback to write  ODESolution  ( t     u ) into file. The reason to separate  t  and  u  is for more easily reshape  u  w.r.t grids specification. It right now falls on users' memory on what the type of solution is for accurately retrieving results.  Arguments   iot::IOStream : stream pointing to solution of time  iou::IOStream : stream pointing to solution of domain   Note  It is strongly not recommended to use \"skipping\" scheme (by defining  thrd  and  dts(a)  for each case) when solution is too oscillated.  #  JuEQ.EarthquakeCycleProblem     Method .  EarthquakeCycleProblem(p::PlaneMaterialProperties, u0, tspan; se=DieterichStateLaw(), fform=CForm())  Return an  ODEProblem  that encapsulate all the parameters and functions required for simulation. For the entailing usage, please refer  DifferentialEquations.jl  Arguments   gd::BoundaryElementGrid : grids for fault domain.  p::PlaneMaterialProperties : material profile.  u0::AbstractArray : initial condition, should be organized such that the first of last dim is velocity while the 2nd of last dim is state.  tspan::NTuple : time interval to be simulated.  se::StateEvolutionLaw : state evolution law to be applied.  fform::FrictionLawForm : forms of frictional law to be applied.   #  JuEQ.dc3d_okada     Method .  Calculate displacements and gradient of displacements due to a dislocation in an elastic isotropic halfspace. See  dc3d  for details.  test/test_okada.dat  is obtained using  DC3dfortran  An example wrapper for DC3D in julia as below:  function dc3d_fortran(x::T, y::T, z::T, \u03b1::T, dep::T, dip::T, al1::T, al2::T, aw1::T, aw2::T,\n    disl1::T, disl2::T, disl3::T) where {T  : AbstractFloat}\n\n    # initial return values\n    # `RefValue{T}` may be also viable other than `Array{T, 1}`\n    ux = Array{Float64}(1)\n    uy = Array{Float64}(1)\n    uz = Array{Float64}(1)\n    uxx = Array{Float64}(1)\n    uyx = Array{Float64}(1)\n    uzx = Array{Float64}(1)\n    uxy = Array{Float64}(1)\n    uyy = Array{Float64}(1)\n    uzy = Array{Float64}(1)\n    uxz = Array{Float64}(1)\n    uyz = Array{Float64}(1)\n    uzz = Array{Float64}(1)\n    iret = Array{Int64}(1)\n\n    # call okada's code which is renamed as  __dc3d__  (see binding rename shown below)\n    # input args tuple must be syntactically written instead of a variable assigned\n    # macros could be used to simplify this in the future\n    ccall((:__dc3d__,  dc3d.so ), Void,\n        (\n            Ref{Float64},\n            Ref{Float64}, Ref{Float64}, Ref{Float64}, Ref{Float64},\n            Ref{Float64}, Ref{Float64}, Ref{Float64}, Ref{Float64},\n            Ref{Float64}, Ref{Float64}, Ref{Float64}, Ref{Float64},\n            Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}},\n            Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}},\n            Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}},\n            Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}}, Ptr{Array{Float64,1}},\n            Ref{Int64},\n        ),\n        \u03b1, x, y, z, dep, dip, al1, al2, aw1, aw2, disl1, disl2, disl3,\n        ux, uy, uz, uxx, uyx, uzx, uxy, uyy, uzy, uxz, uyz, uzz,\n        iret,\n    )\n\n    # results valid iff iret[1] == 0\n    return (\n        iret[1],\n        ux[1], uy[1], uz[1],\n        uxx[1], uyx[1], uzx[1],\n        uxy[1], uyy[1], uzy[1],\n        uxz[1], uyz[1], uzz[1]\n    )\nend  The corresponding fortran module is:  MODULE okada\n  USE, INTRINSIC :: iso_c_binding\n  IMPLICIT NONE\nCONTAINS\n\n  SUBROUTINE dc3d_wrapper( \n         alpha,  \n         x, y, z,  \n         depth, dip,  \n         al1, al2,  \n         aw1, aw2,  \n         disl1, disl2, disl3,  \n         ux, uy, uz,  \n         uxx, uyx, uzx,  \n         uxy, uyy, uzy,  \n         uxz, uyz, uzz,  \n         iret) BIND(C, NAME='__dc3d__')\n\n    REAL*8 ::  \n           alpha,  \n           x, y, z,  \n           depth, dip,  \n           al1, al2,  \n           aw1, aw2,  \n           disl1, disl2, disl3,  \n           ux, uy, uz,  \n           uxx, uyx, uzx,  \n           uxy, uyy, uzy,  \n           uxz, uyz, uzz\n\n    INTEGER*8 :: iret\n\n    CALL dc3d( \n           alpha,  \n           x, y, z,  \n           depth, dip,  \n           al1, al2,  \n           aw1, aw2,  \n           disl1, disl2, disl3,  \n           ux, uy, uz,  \n           uxx, uyx, uzx,  \n           uxy, uyy, uzy,  \n           uxz, uyz, uzz,  \n           iret)\n\n  END SUBROUTINE dc3d_wrapper\n\nEND MODULE okada  A sample of makefile is as below:  # Build Okada's code for calculating deformation due to a fault model\n#\nCC = gfortran\nCFLAGS = -fPIC -w -O3\nLDFLAGS = -shared\n\nSRCS = dc3d.f okada.f90\nOBJS = $(SRCS:.c=.o)\n\nTARGET = dc3d.so\n\n$(TARGET): $(OBJS)\n    $(CC) $(CFLAGS) $(LDFLAGS) -o $(TARGET) $(OBJS)  #  JuEQ.discretize     Method .  discretize(fa::PlaneFaultDomain{ftype, 1}, \u0394\u03be::T; ax_ratio=12.5)  Generate the grid for given 1D fault domain. The grids will be forced to start at (x=0, y=0, z=0).  Arguments   \u0394\u03be : grid space along-downdip  ax_ratio::Number : ration of along-strike length agsinst along-downdip length for mimicing an extended   2d (x   \u03be) fault represented by 1d (\u03be) domain. Default  ax_ratio=12.5  is more than enough for producing consistent results.   #  JuEQ.discretize     Method .  discretize(fa::PlaneFaultDomain{ftype, 2}, \u0394x, \u0394\u03be; buffer=:auto) where {ftype  : PlaneFault}  Generate the grid for given 2D fault domain. The grids will be forced to start at (z=0) and spread symmetrically along x-axis w.r.t y-z plane.     By such setting, we would be able to utilize the symmetry properties of stiffness tensor for performance speed up.  Arguments   \u0394x, \u0394\u03be : grid space along-strike and along-downdip respectively  `buffer_ratio::Number: ration of buffer size against along-strike length for introducing  zero-dislocation  area at along-strike edges of defined fault domain.   #  JuEQ.fault     Method .  fault(ftype::Type{ :PlaneFault}, dip, span)  Generate a fault given the fault type, dip angle and its spatial span.  Arguments   ftype::Type{ :PlaneFault} : type of plane fault  dip : dip angle in degree  span : spatial span of fault size   #  JuEQ.friction     Method .  friction(::FrictionLawForm, v::T, \u03b8::T, L::T, a::T, b::T, f0::T, v0::T) where {T :Number}  Calculate friction given by the form of fomula as well as other necessary parameters.   Conventional Form:    \nf(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)}    Regularized Form:    \nf(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]}   #  JuEQ.max_velocity     Method .  max_velocity(t::AbstractVector, u::AbstractArray, getu::Function)  Return max velocity across the fault at each time step. A number of convenient interfaces for common output are implemented.  Arguments   t::AbstractVector : vector of time steps  u::AbstractArray : array of solution  getu::Function : method for retrieving velocity section at each time step   #  JuEQ.moment_magnitude     Method .  Calculate moment magnitude.  #  JuEQ.properties     Method .  properties(fa::PlaneFaultDomain, gd::BoundaryElementGrid{dim}; _kwargs...) where {dim}  Establishing a material-properties-profile given by the fault domain and grids. User must provide the     necessary parameters in according to the grid size specified or just a scalar for broadcasting.  Arguments that are required:   a : contrib from velocity.  b : contrib from state.  L : critical distance.  \u03c3 : effective normal stress.  \u03b7 : radiation damping. It is recommended to set as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is  shear modulus  and $\\mathrm{Vs}$ shear wave velocity.  vpl : plate rate.  f0 : ref. frictional coeff.  v0 : ref. velocity.   Arguments that need options    k : stiffness tensor.  (1) Providing  shear modulus  denoted as  \u03bc  and  Lam\u00e9's first parameter  denoted as  \u03bb  (same as  \u03bc  if missing),  then calculate it based on grid and fault domain, choosing parallel scheme if  nprocs() != 1 .  (2) an  AbstractArray  represent the pre-calculated stiffness tensor. No verification will be performed here.    #  JuEQ.stiffness_tensor     Method .  stiffness_tensor(fa::PlaneFaultDomain, gd::BoundaryElementGrid, ep::HomogeneousElasticProperties)  Calculate the reduced stiffness tensor. For 2D fault, the final result will be dimensionally reduced to a 3D array     due to the  translational     reflective     perodic  symmetry, such that the tensor contraction will be equivalent to convolution,     hence we could use FFT for better performace.  Note   Faults are originated from surface and extends downwards, thus  dep = 0", 
            "title": "Interfaces"
        }, 
        {
            "location": "/private_interface/", 
            "text": "Private Interface\n\n\n\n\nIndex\n\n\n\n\nJuEQ.HomogeneousElasticProperties\n\n\nJuEQ.ODEStateVariable\n\n\nJuEQ.applied_unit_dislocation\n\n\nJuEQ.shear_traction\n\n\nJuEQ.stiffness_periodic_boundary_condition!\n\n\n\n\n\n\nInterfaces\n\n\n#\n\n\nJuEQ.HomogeneousElasticProperties\n \n \nType\n.\n\n\nOkada's \ndc3d\n only applies on isotropic materials,     therefore, elastic modulus are constrained to be scalars.\n\n\nsource\n\n\n#\n\n\nJuEQ.ODEStateVariable\n \n \nType\n.\n\n\nIntermediate variable in solving ODEs aimed to avoid allocation overheads.\n\n\n#\n\n\nJuEQ.applied_unit_dislocation\n \n \nMethod\n.\n\n\nFor noraml fault, it should of course be [0., -1., 0.]. However, in term of force balance, it is quivalent to thrust fault if dip angle are constrained within [0, \u03c0/2] in fact.\n\n\nThe unit of \nunit dislocation\n below is the same of \nv * t\n at set by user so to avoid normalization step.\n\n\n#\n\n\nJuEQ.shear_traction\n \n \nMethod\n.\n\n\nshear_traction(::Type{\n:PlaneFault}, u, \u03bb, \u03bc, dip)\n\n\n\n\nCalculate the shear traction on the fault plane w.r.t. fault types.\n\n\nArguments\n\n\n\n\nu::AbstractArray{\n:Number, 1}\n: the output from \ndc3d_okada\n\n\n\u03bb::Number\n: Lam\u00e9's first parameter\n\n\n\u03bc::Number\n: shear modulus\n\n\ndip::Number\n: plane dip angle\n\n\n\n\nReference\n\n\n\n\nA good reference is at \nDisplacement \n Strain \n Stress\n.\n\n\n\n\n#\n\n\nJuEQ.stiffness_periodic_boundary_condition!\n \n \nMethod\n.\n\n\nPeriodic boundary condition for 2D faults.\n\n\nArguments\n\n\n\n\nu::AbstractVector\n: In-place output which is a 12-elements vector (exactly the output of \ndc3d_okada\n). No assertion here imposed.\n\n\nsame as \ndc3d_okada\n, see \ndc3d\n for details.\n\n\nnrept::Integer\n: (half) number of repetition, as denoted by \n-npret: nrept\n\n\nlrept::Number\n: length of repetition interval, see \nNote\n below\n\n\n\n\nNote\n\n\n\n\nThe buffer block length is (\nbuffer_ratio\n - 1) multipled by along-strike length.", 
            "title": "Private"
        }, 
        {
            "location": "/private_interface/#private-interface", 
            "text": "", 
            "title": "Private Interface"
        }, 
        {
            "location": "/private_interface/#index", 
            "text": "JuEQ.HomogeneousElasticProperties  JuEQ.ODEStateVariable  JuEQ.applied_unit_dislocation  JuEQ.shear_traction  JuEQ.stiffness_periodic_boundary_condition!", 
            "title": "Index"
        }, 
        {
            "location": "/private_interface/#interfaces", 
            "text": "#  JuEQ.HomogeneousElasticProperties     Type .  Okada's  dc3d  only applies on isotropic materials,     therefore, elastic modulus are constrained to be scalars.  source  #  JuEQ.ODEStateVariable     Type .  Intermediate variable in solving ODEs aimed to avoid allocation overheads.  #  JuEQ.applied_unit_dislocation     Method .  For noraml fault, it should of course be [0., -1., 0.]. However, in term of force balance, it is quivalent to thrust fault if dip angle are constrained within [0, \u03c0/2] in fact.  The unit of  unit dislocation  below is the same of  v * t  at set by user so to avoid normalization step.  #  JuEQ.shear_traction     Method .  shear_traction(::Type{ :PlaneFault}, u, \u03bb, \u03bc, dip)  Calculate the shear traction on the fault plane w.r.t. fault types.  Arguments   u::AbstractArray{ :Number, 1} : the output from  dc3d_okada  \u03bb::Number : Lam\u00e9's first parameter  \u03bc::Number : shear modulus  dip::Number : plane dip angle   Reference   A good reference is at  Displacement   Strain   Stress .   #  JuEQ.stiffness_periodic_boundary_condition!     Method .  Periodic boundary condition for 2D faults.  Arguments   u::AbstractVector : In-place output which is a 12-elements vector (exactly the output of  dc3d_okada ). No assertion here imposed.  same as  dc3d_okada , see  dc3d  for details.  nrept::Integer : (half) number of repetition, as denoted by  -npret: nrept  lrept::Number : length of repetition interval, see  Note  below   Note   The buffer block length is ( buffer_ratio  - 1) multipled by along-strike length.", 
            "title": "Interfaces"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "MIT License\n\n\nCopyright (c) 2018 Shi Pengcheng\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}