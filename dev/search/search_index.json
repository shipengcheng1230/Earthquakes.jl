{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quaycle.jl Documentation \u00b6 Overview \u00b6 This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Plastic Deformation Boundary Element Method (Quasi-dynamic) Viscoelastic Relaxation Integration with Gmsh and Paraview Features to be implemented: Fully elastodynamics Finite element method via Fenics Installation \u00b6 Get the latest version with Julia's package manager: 1 ( v1 . 1 ) pkg > add https :// github . com / shipengcheng1230 / Quaycle . jl To load the package: 1 using Quaycle","title":"Home"},{"location":"#quayclejl-documentation","text":"","title":"Quaycle.jl Documentation"},{"location":"#overview","text":"This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Plastic Deformation Boundary Element Method (Quasi-dynamic) Viscoelastic Relaxation Integration with Gmsh and Paraview Features to be implemented: Fully elastodynamics Finite element method via Fenics","title":"Overview"},{"location":"#installation","text":"Get the latest version with Julia's package manager: 1 ( v1 . 1 ) pkg > add https :// github . com / shipengcheng1230 / Quaycle . jl To load the package: 1 using Quaycle","title":"Installation"},{"location":"acknowledge/","text":"Acknowledge \u00b6 The simulation of episodic seismic and slow slip events using boundary-element-method for pure elastic fault is largely benefit from Yajing Liu original Fortran code. This package isn't possible without a collaborating Julia community. LICENSE \u00b6 This package is licensed under GPLv3 . This package includes derivative codes from the following project which has their own license: dc3d.f (rectangular dislocation with limited rotation freedom) Triangular Dislocation Hexahedron Inelastic Deformation Tetrahedron Inelastic Deformation","title":"Acknowledge"},{"location":"acknowledge/#acknowledge","text":"The simulation of episodic seismic and slow slip events using boundary-element-method for pure elastic fault is largely benefit from Yajing Liu original Fortran code. This package isn't possible without a collaborating Julia community.","title":"Acknowledge"},{"location":"acknowledge/#license","text":"This package is licensed under GPLv3 . This package includes derivative codes from the following project which has their own license: dc3d.f (rectangular dislocation with limited rotation freedom) Triangular Dislocation Hexahedron Inelastic Deformation Tetrahedron Inelastic Deformation","title":"LICENSE"},{"location":"interface_HDF5/","text":"HDF5 Utilities \u00b6 To use HDF5 functionality, 1 2 3 4 pkg > add HDF5 julia > using Quaycle julia > using HDF5 This package provides a bunch of utilities, such as storing simulation properties and writing ODE solution on the fly to HDF5 format file for postprocessing on different platform and package version. We currently don't support automatically saving green's function to HDF5 due to its limitation of natively storing complex number. It's worth mention that JLD and JLD2 are also excellent alternatives but they storing the whole type information that may broke read when this package changes or remove certain type definitions. Users may choose them as auxiliary tools. Public Interface \u00b6 # Quaycle.store \u2014 Method . 1 store ( filename :: AbstractString , p :: AbstractProperty ) Store property in HDF5. Arguments filename::AbstractString : file name to be used p::AbstractProperty : property to be saved # Quaycle.@getprop \u2014 Macro . 1 @getprop filename Read property stored in HDF5. Arguments filename : file name. Assume it has one and only one kind of property group. # Quaycle.@store \u2014 Macro . 1 @store filename :: AbstractString p :: AbstractProperty Macro shortcut for storing property in HDF5. Arguments filename::AbstractString : file name to be used p::AbstractProperty : property to be saved # Quaycle.wsolve \u2014 Method . 1 2 wsolve ( prob :: ODEProblem , alg :: OrdinaryDiffEqAlgorithm , file , nstep , getu , ustrs , tstr ; kwargs ... ) Write the solution to HDF5 file while solving the ODE. The interface is exactly the same as solve an ODEProblem except a few more about the saving procedure. Notice, it will set save_everystep=false so to avoid memory blow up. The return code will be written as an attribute in tstr data group. Extra Arguments file::AbstractString : name of file to be saved nstep::Integer : number of steps after which a saving operation will be performed getu::Function : function handler to extract desired solution for saving ustr::AbstractVector : list of names to be assigned for each components, whose length must equal the length of getu output tstr::AbstractString : name of time data # Quaycle.\ud835\udc15\ud835\udeac\u2032 \u2014 Method . Retrieve velocity and strain rate # Quaycle.\ud835\udc15\ud835\udeaf \u2014 Method . Retrieve velocity and state . # Quaycle.\ud835\udc15\ud835\udeaf\ud835\udeac \u2014 Method . Retrieve velocity , state and strain . # Quaycle.\ud835\udc15\ud835\udeaf\ud835\udeac\u2032 \u2014 Method . Retrieve velocity , state and strain rate . # Quaycle.\ud835\udc15\ud835\udeaf\ud835\udeac\ud835\udeba \u2014 Method . Retrieve velocity , state , strain and stress . # Quaycle.@h5savecallback \u2014 Macro . 1 @h5savecallback ( filename , tend , nsteps , usize , T ) Construct a FunctionCallingCallback for incrementally stored output into HDF5 file. This callback function only works for naive output arrays whose shape look like A[..., :, :, :, ...] . It is suggested to use this macro at top-level scope since it contains eval . Arguments filename : file name to be stored tend : end time of simulation nsteps : after nsteps steps, a saving operation is performed otherwise caching them T : type of stored data","title":"HDF5 Utility"},{"location":"interface_HDF5/#hdf5-utilities","text":"To use HDF5 functionality, 1 2 3 4 pkg > add HDF5 julia > using Quaycle julia > using HDF5 This package provides a bunch of utilities, such as storing simulation properties and writing ODE solution on the fly to HDF5 format file for postprocessing on different platform and package version. We currently don't support automatically saving green's function to HDF5 due to its limitation of natively storing complex number. It's worth mention that JLD and JLD2 are also excellent alternatives but they storing the whole type information that may broke read when this package changes or remove certain type definitions. Users may choose them as auxiliary tools.","title":"HDF5 Utilities"},{"location":"interface_HDF5/#public-interface","text":"# Quaycle.store \u2014 Method . 1 store ( filename :: AbstractString , p :: AbstractProperty ) Store property in HDF5. Arguments filename::AbstractString : file name to be used p::AbstractProperty : property to be saved # Quaycle.@getprop \u2014 Macro . 1 @getprop filename Read property stored in HDF5. Arguments filename : file name. Assume it has one and only one kind of property group. # Quaycle.@store \u2014 Macro . 1 @store filename :: AbstractString p :: AbstractProperty Macro shortcut for storing property in HDF5. Arguments filename::AbstractString : file name to be used p::AbstractProperty : property to be saved # Quaycle.wsolve \u2014 Method . 1 2 wsolve ( prob :: ODEProblem , alg :: OrdinaryDiffEqAlgorithm , file , nstep , getu , ustrs , tstr ; kwargs ... ) Write the solution to HDF5 file while solving the ODE. The interface is exactly the same as solve an ODEProblem except a few more about the saving procedure. Notice, it will set save_everystep=false so to avoid memory blow up. The return code will be written as an attribute in tstr data group. Extra Arguments file::AbstractString : name of file to be saved nstep::Integer : number of steps after which a saving operation will be performed getu::Function : function handler to extract desired solution for saving ustr::AbstractVector : list of names to be assigned for each components, whose length must equal the length of getu output tstr::AbstractString : name of time data # Quaycle.\ud835\udc15\ud835\udeac\u2032 \u2014 Method . Retrieve velocity and strain rate # Quaycle.\ud835\udc15\ud835\udeaf \u2014 Method . Retrieve velocity and state . # Quaycle.\ud835\udc15\ud835\udeaf\ud835\udeac \u2014 Method . Retrieve velocity , state and strain . # Quaycle.\ud835\udc15\ud835\udeaf\ud835\udeac\u2032 \u2014 Method . Retrieve velocity , state and strain rate . # Quaycle.\ud835\udc15\ud835\udeaf\ud835\udeac\ud835\udeba \u2014 Method . Retrieve velocity , state , strain and stress . # Quaycle.@h5savecallback \u2014 Macro . 1 @h5savecallback ( filename , tend , nsteps , usize , T ) Construct a FunctionCallingCallback for incrementally stored output into HDF5 file. This callback function only works for naive output arrays whose shape look like A[..., :, :, :, ...] . It is suggested to use this macro at top-level scope since it contains eval . Arguments filename : file name to be stored tend : end time of simulation nsteps : after nsteps steps, a saving operation is performed otherwise caching them T : type of stored data","title":"Public Interface"},{"location":"interface_assemble/","text":"Assemble \u00b6 The assemble function aims to provide an ODEProblem encapsulating all the necessary information for modeling earthquake cycles. It will automatically generate caches based on given mesh sizes aiming to minimize allocation during solving. The full functionality of ODEProblem as well as solving interface can be viewed at documents of DifferentialEquations.jl . Also, please checkout RecursiveArrayTools.jl for usage of ArrayPartition which is adopted by default for multiple variables in this package. Public Interface \u00b6 # Quaycle.assemble \u2014 Method . 1 2 3 assemble ( gf :: AbstractArray , p :: RateStateQuasiDynamicProperty , u0 :: AbstractArray , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (), kwargs ... ) Assemble the ODEProblem for elastic fault. Extra Arguments gf::AbstractArray : green's function associated with fs.mesh and p.\u03bb & p.\u03bc p::RateStateQuasiDynamicProperty : all system properties u0::ArrayPartition : initial condition. By rule of order in this package: velocity state tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # Quaycle.assemble \u2014 Method . 1 2 3 assemble ( gf :: ViscoelasticCompositeGreensFunction , p :: ViscoelasticMaxwellProperty , u0 :: ArrayPartition , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (),) Assemble the ODEProblem for elastic fault plus viscoelastic relaxation. Arguments gf::ViscoelasticCompositeGreensFunction : green's function associated with the composite space fas p::ViscoelasticCompositeGreensFunction : all system properties u0::ArrayPartition : initial condition. By rule of order in this package: velocity state strain stress tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # Quaycle.assemble \u2014 Method . 1 2 assemble ( p :: SingleDofRSFProperty , u0 :: AbstractArray , tspan :: NTuple ; flf :: FrictionLawForm = CForm (), se :: StateEvolutionLaw = DieterichStateLaw ()) Assemble the ODEProblem for single degree of freedom system. Arguments p::SingleDofRSFProperty : all system properties u0::AbstractArray : initial condition tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw References \u00b6 Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., McGuire, J. J., & Behn, M. D. (2012). Frictional behavior of oceanic transform faults and its influence on earthquake characteristics. Journal of Geophysical Research: Solid Earth, 117(B4). https://doi.org/10.1029/2011JB009025 Barbot, S. (2018). Asthenosphere Flow Modulated by Megathrust Earthquake Cycles. Geophysical Research Letters, 45(12), 6018\u20136031. https://doi.org/10.1029/2018GL078197","title":"Assemble"},{"location":"interface_assemble/#assemble","text":"The assemble function aims to provide an ODEProblem encapsulating all the necessary information for modeling earthquake cycles. It will automatically generate caches based on given mesh sizes aiming to minimize allocation during solving. The full functionality of ODEProblem as well as solving interface can be viewed at documents of DifferentialEquations.jl . Also, please checkout RecursiveArrayTools.jl for usage of ArrayPartition which is adopted by default for multiple variables in this package.","title":"Assemble"},{"location":"interface_assemble/#public-interface","text":"# Quaycle.assemble \u2014 Method . 1 2 3 assemble ( gf :: AbstractArray , p :: RateStateQuasiDynamicProperty , u0 :: AbstractArray , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (), kwargs ... ) Assemble the ODEProblem for elastic fault. Extra Arguments gf::AbstractArray : green's function associated with fs.mesh and p.\u03bb & p.\u03bc p::RateStateQuasiDynamicProperty : all system properties u0::ArrayPartition : initial condition. By rule of order in this package: velocity state tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # Quaycle.assemble \u2014 Method . 1 2 3 assemble ( gf :: ViscoelasticCompositeGreensFunction , p :: ViscoelasticMaxwellProperty , u0 :: ArrayPartition , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (),) Assemble the ODEProblem for elastic fault plus viscoelastic relaxation. Arguments gf::ViscoelasticCompositeGreensFunction : green's function associated with the composite space fas p::ViscoelasticCompositeGreensFunction : all system properties u0::ArrayPartition : initial condition. By rule of order in this package: velocity state strain stress tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # Quaycle.assemble \u2014 Method . 1 2 assemble ( p :: SingleDofRSFProperty , u0 :: AbstractArray , tspan :: NTuple ; flf :: FrictionLawForm = CForm (), se :: StateEvolutionLaw = DieterichStateLaw ()) Assemble the ODEProblem for single degree of freedom system. Arguments p::SingleDofRSFProperty : all system properties u0::AbstractArray : initial condition tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw","title":"Public Interface"},{"location":"interface_assemble/#references","text":"Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., McGuire, J. J., & Behn, M. D. (2012). Frictional behavior of oceanic transform faults and its influence on earthquake characteristics. Journal of Geophysical Research: Solid Earth, 117(B4). https://doi.org/10.1029/2011JB009025 Barbot, S. (2018). Asthenosphere Flow Modulated by Megathrust Earthquake Cycles. Geophysical Research Letters, 45(12), 6018\u20136031. https://doi.org/10.1029/2018GL078197","title":"References"},{"location":"interface_friction/","text":"Friction \u00b6 This package adopts what is called rate-and-state friction as one of the essential components for modeling fault dynamics. Currently, we only support single state variable \u03b8 \u03b8 . Public Interface \u00b6 # Quaycle.CForm \u2014 Type . Conventional form, see friction # Quaycle.DieterichStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} # Quaycle.PrzStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\left(\\frac{V \u03b8}{2L}\\right)^2 \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\left(\\frac{V \u03b8}{2L}\\right)^2 # Quaycle.RForm \u2014 Type . Regularized form, see friction # Quaycle.RuinaStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\left(\\frac{V \u03b8}{L}\\right)} \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\left(\\frac{V \u03b8}{L}\\right)} # Quaycle.StateEvolutionLaw \u2014 Type . Currently support: DieterichStateLaw RuinaStateLaw PrzStateLaw # Quaycle.friction \u2014 Method . 1 friction ( :: FrictionLawForm , v :: T , \u03b8 :: T , L :: T , a :: T , b :: T , f0 :: T , v0 :: T ) where { T <: Number } Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\left(\\frac{V}{V_0}\\right)} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} f(V, \u03b8) = f_0 + a \\ln{\\left(\\frac{V}{V_0}\\right)} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left(\\frac{V}{2V_0} \\exp{\\left(\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}\\right)}\\right)} f(V, \u03b8) = a \\sinh ^{-1}{\\left(\\frac{V}{2V_0} \\exp{\\left(\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}\\right)}\\right)} References \u00b6 Dieterich, J. (1979). Modeling of rock friction: 1. Experimental results and constitutive equations. Journal of Geophysical Research: Solid Earth, 84(B5), 2161\u20132168. https://doi.org/10.1029/JB084iB05p02161 Ruina, A. (1983). Slip instability and state variable friction laws. Journal of Geophysical Research: Solid Earth, 88(B12), 10359\u201310370. https://doi.org/10.1029/JB088iB12p10359 Rubin, A. M., & Ampuero, J.-P. (2005). Earthquake nucleation on (aging) rate and state faults. Journal of Geophysical Research: Solid Earth, 110(B11). https://doi.org/10.1029/2005JB003686","title":"Friction"},{"location":"interface_friction/#friction","text":"This package adopts what is called rate-and-state friction as one of the essential components for modeling fault dynamics. Currently, we only support single state variable \u03b8 \u03b8 .","title":"Friction"},{"location":"interface_friction/#public-interface","text":"# Quaycle.CForm \u2014 Type . Conventional form, see friction # Quaycle.DieterichStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} # Quaycle.PrzStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\left(\\frac{V \u03b8}{2L}\\right)^2 \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\left(\\frac{V \u03b8}{2L}\\right)^2 # Quaycle.RForm \u2014 Type . Regularized form, see friction # Quaycle.RuinaStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\left(\\frac{V \u03b8}{L}\\right)} \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\left(\\frac{V \u03b8}{L}\\right)} # Quaycle.StateEvolutionLaw \u2014 Type . Currently support: DieterichStateLaw RuinaStateLaw PrzStateLaw # Quaycle.friction \u2014 Method . 1 friction ( :: FrictionLawForm , v :: T , \u03b8 :: T , L :: T , a :: T , b :: T , f0 :: T , v0 :: T ) where { T <: Number } Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\left(\\frac{V}{V_0}\\right)} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} f(V, \u03b8) = f_0 + a \\ln{\\left(\\frac{V}{V_0}\\right)} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left(\\frac{V}{2V_0} \\exp{\\left(\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}\\right)}\\right)} f(V, \u03b8) = a \\sinh ^{-1}{\\left(\\frac{V}{2V_0} \\exp{\\left(\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}\\right)}\\right)}","title":"Public Interface"},{"location":"interface_friction/#references","text":"Dieterich, J. (1979). Modeling of rock friction: 1. Experimental results and constitutive equations. Journal of Geophysical Research: Solid Earth, 84(B5), 2161\u20132168. https://doi.org/10.1029/JB084iB05p02161 Ruina, A. (1983). Slip instability and state variable friction laws. Journal of Geophysical Research: Solid Earth, 88(B12), 10359\u201310370. https://doi.org/10.1029/JB088iB12p10359 Rubin, A. M., & Ampuero, J.-P. (2005). Earthquake nucleation on (aging) rate and state faults. Journal of Geophysical Research: Solid Earth, 110(B11). https://doi.org/10.1029/2005JB003686","title":"References"},{"location":"interface_greensfun/","text":"Green's Function \u00b6 The interactions among fault patches, asthenosphere elements as well as between fault and asthenosphere are computed via convolution of Green's Function. Currently supported Green's Function: 1D elastic line dislocation 2D elastic rectangular dislocation 2D elastic triangular dislocation 3D inelastic strain in Hex8 or Tet4 elements Other types, such as 2D inelastic (plane stress or antiplane stress), polygon dislocation, are WIP ( PR are welcome! ). All functions translated here are ensured to be type stable and have minimum allocation. Broadcasting isn't supported here ( why? ) so you can easily embed them into multiprocessors parallel computation, which is implemented here. Also be aware of the coordinate system difference among all the Green's function provided here. Users are encouraged to view the original sources for further details. This package preserves the original coordinate systems as well as function arguments for all, whose outcomes are also tested against original ones. Public Interface \u00b6 # Quaycle.compose_stress_greens_func \u2014 Method . 1 2 compose_stress_greens_func ( ee :: AbstractArray , ev :: NTuple , ve :: NTuple , vv :: NTuple { N , <: Tuple }, \u03f5comp :: NTuple , \u03c3comp :: NTuple ) where N Concatenate tuple of matrix or tuple of tuple of matrix which arrange them in a way to update traction/stress rate using only one BLAS call. It does nothing to the elastic Green's function and specifically used for the outputs from stress_greens_func and stress_greens_func . Arguments ee::AbstractArray : traction Green's function within the elastic fault ev::NTuple : stress Green's function from elastic fault to inelastic asthenosphere ve::NTuple : traction Green's function inelastic asthenosphere to elastic fault vv::NTuple : stress Green's function within inelastic asthenosphere \u03f5comp : strain component to be considered, must be a subset of \u03c3comp \u03c3comp : stress component to be considered # Quaycle.compose_stress_greens_func \u2014 Method . 1 2 compose_stress_greens_func ( mf :: OkadaMesh , me :: SBarbotMeshEntity , \u03bb :: T , \u03bc :: T , ft :: PlaneFault , comp :: NTuple { N , <: Symbol }) where { T , N } Shortcut function for computing all 4 Green's function for viscoelastic relaxation. Arguments stays the same as stress_greens_func . # Quaycle.stress_greens_func \u2014 Method . 1 2 3 stress_greens_func ( mf :: AbstractMesh { 2 }, ma :: SBarbotMeshEntity { 3 }, \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault , \u03c3comp :: NTuple { N , Symbol }; kwargs ... ) where { T <: Real , I <: Integer , N } Compute stress Green's function from fault mesh to asthenosphere mesh. Arguments mf::AbstractMesh{2} : mesh of fault ma::SBarbotMeshEntity{3} : mesh of asthenosphere \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() \u03c3comp::NTuple{N, Symbol} : stress components to consider KWARGS Arguments The same as previously mentioned: nrept::Integer buffer_ratio::Real Output The output is a tuple of length(\u03c3comp) matrix, each corresponds \u03c3_{ij} \u03c3_{ij} in the same order as given by \u03c3comp . # Quaycle.stress_greens_func \u2014 Method . 1 stress_greens_func ( mesh :: LineOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; kwargs ... ) where T Compute traction Green function in 1-D elastic fault in LineOkadaMesh . Arguments mesh::LineOkadaMesh : the line mesh coupled with dc3d \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments ax_ratio::Real : ratio of along-strike to along-downdip, default is 12.5 # Quaycle.stress_greens_func \u2014 Method . 1 2 stress_greens_func ( mesh :: RectOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; fourier_domain = true , kwargs ... ) where T Compute traction Green's function in 2-D elastic fault in RectOkadaMesh . Translational symmetry is considered. Arguments mesh::RectOkadaMesh : the rectangular mesh coupled with dc3d \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments fourier_domain::Bool : whether or not transform the tensor to fourier domain nrept::Integer : number of periodic summation is performed buffer_ratio::Real : ratio of length of buffer zone (along-strike) to that of fault (along-strike) It is recommended to set at least 1 for strike-slip fault for mimicing zero-dislocation at ridge on both sides. # Quaycle.stress_greens_func \u2014 Method . 1 stress_greens_func ( mesh :: TDTri3MeshEntity , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; kwargs ... ) where T Compute traction Green's function in 2-D elastic fault in TDTri3MeshEntity . Arguments mesh::TDTri3MeshEntity : the triangular mesh coupled with td_stress_hs \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments nrept::Integer : number of periodic summation is performed buffer_ratio::Real : ratio of length of buffer zone (along-strike) to that of fault (along-strike). Notice the direction of strike is the average value of mesh.ss and the length is the strike projected maximum horizontal expansion. # Quaycle.stress_greens_func \u2014 Method . 1 2 stress_greens_func ( ma :: SBarbotMeshEntity { 3 }, \u03bb :: T , \u03bc :: T , \u03f5comp :: NTuple { N1 , Symbol }, \u03c3comp :: NTuple { N2 , Symbol }; kwargs ... ) where { T , N1 , N2 } Compute stress Green's function within SBarbotTet4MeshEntity or SBarbotHex8MeshEntity Arguments ma::SBarbotMeshEntity{3} : asthenosphere mesh \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus \u03f5comp : the strain \u03f5component(s) to be considered \u03c3comp::NTuple{N, Symbol} : stress components to consider Output A tuple of n n tuple of matrix, each tuple represents interaction from one strain component, w.r.t. \u03f5comp to the stress \u03f5components, whose order is \u03c3_{ij} \u03c3_{ij} whose order is the same as \u03c3comp , each of which is a matrix. # Quaycle.stress_greens_func \u2014 Method . 1 2 stress_greens_func ( ma :: SBarbotMeshEntity { 3 }, mf :: AbstractMesh { 2 }, \u03bb :: T , \u03bc :: T , ft :: PlaneFault , \u03f5comp :: NTuple { N , Symbol }; kwargs ... ) where { T , N } Compute traction Green's function from SBarbotTet4MeshEntity or SBarbotHex8MeshEntity to RectOkadaMesh Arguments ma::SBarbotMeshEntity{3} : asthenosphere mesh mf::AbstractMesh{2} : fault mesh \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() \u03f5comp : the strain \u03f5component(s) to be considered Output A tuple of n n matrix, each represents interaction from one strain to the traction on fault. # Quaycle.dc3d \u2014 Method . 1 2 3 dc3d ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al :: Union { A , SubArray }, aw :: Union { A , SubArray }, disl :: A ) where { T <: Number , A <: AbstractVecOrMat { T }} Calculate displacements and gradient of displacements due to a rectangular dislocation in an elastic isotropic halfspace. Please see dc3d for details. Also this fault coordinate system is widely used in this package. Arguments x , y , z : observational position, where z \u2264 0 z \u2264 0 \u03b1 : elastic constant dep : depth of fault origin dip : dip angle in degree al : a vector of 2 numbers, indicating along strike (x-axis) spanning aw : a vector of 2 numbers, indicating along downdip (y-z plane) spanning disl : a vector of 3 numbers, indicating dislocation in along-strike, along-downdip and tensile respectively. Output A vector of 12 numbers, each is u_{x} u_{x} , u_{y} u_{y} , u_{z} u_{z} , u_{x,x} u_{x,x} , u_{y,x} u_{y,x} , u_{z,x} u_{z,x} , u_{x,y} u_{x,y} , u_{y,y} u_{y,y} , u_{z,y} u_{z,y} , u_{x,z} u_{x,z} u_{y,z} u_{y,z} , u_{z,z} u_{z,z} . # Quaycle.sbarbot_disp_hex8 \u2014 Method . 1 2 3 4 5 6 sbarbot_disp_hex8 ( x1 :: R , x2 :: R , x3 :: R , q1 :: R , q2 :: R , q3 :: R , L :: R , T :: R , W :: R , theta :: R , epsv11p :: R , epsv12p :: R , epsv13p :: R , epsv22p :: R , epsv23p :: R , epsv33p :: R , G :: R , nu :: R , ) where R Compute displacement arisen from inelastic strain in Hex8 elements. Please see original version for complete details, especially the coordinate system used here. Arguments x1 , x2 , x3 : observational position, where x_{3} \u2265 0 x_{3} \u2265 0 q1 , q2 , q3 : Hex8 element position, where q_{3} \u2265 0 q_{3} \u2265 0 L , T , W : Hex8 element length, thickness and width theta : strike angle epsv** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} G : shear modulus nu : poisson ratio Output A vector of 3 numbers, each represents u_{1} u_{1} , u_{2} u_{2} , u_{3} u_{3} Notice Inplace version: sbarbot_disp_hex8!(u, args...) where u is a vector of 3 numbers. # Quaycle.sbarbot_stress_hex8 \u2014 Method . 1 2 3 4 5 6 sbarbot_stress_hex8 ( x1 :: R , x2 :: R , x3 :: R , q1 :: R , q2 :: R , q3 :: R , L :: R , T :: R , W :: R , theta :: R , epsv11p :: R , epsv12p :: R , epsv13p :: R , epsv22p :: R , epsv23p :: R , epsv33p :: R , G :: R , nu :: R , ) where R Compute stress arisen from inelastic strain in Hex8 elements. Please see original version for complete details, especially the coordinate system used here. Arguments The same as sbarbot_disp_hex8 Output A vector of 6 numbers, each represents \u03c3_{11} \u03c3_{11} , \u03c3_{12} \u03c3_{12} , \u03c3_{13} \u03c3_{13} , \u03c3_{22} \u03c3_{22} , \u03c3_{23} \u03c3_{23} , \u03c3_{33} \u03c3_{33} Notice Inplace version: sbarbot_stress_hex8!(u, args...) where u is a vector of 6 numbers. # Quaycle.sbarbot_disp_tet4 \u2014 Method . 1 2 3 4 sbarbot_disp_tet4 ( quadrature :: Q , x1 :: R , x2 :: R , x3 :: R , A :: U , B :: U , C :: U , D :: U , e11 :: R , e12 :: R , e13 :: R , e22 :: R , e23 :: R , e33 :: R , nu :: R ) where { R , U , Q } Compute displacement arisen from inelastic strain in Tet4 elements. Please see original version for complete details, especially the coordinate system used here. Arguments quadrature : quadrature rule for integration, see FastGaussQuadrature.jl x1 , x2 , x3 : observational position, where x_{3} \u2265 0 x_{3} \u2265 0 A , B , C , D : a list of 3 numbers for each, each of which represents coordinates of the vertex. All depth coordinates must be greater or equal to 0 (no checking is performed here) e** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} nu : poisson ratio Output A vector of 3 numbers, each represents u_{1} u_{1} , u_{2} u_{2} , u_{3} u_{3} Notice Inplace version: sbarbot_disp_tet4!(u, args...) where u is a vector of 3 numbers. # Quaycle.sbarbot_stress_tet4 \u2014 Method . 1 2 3 4 sbarbot_stress_tet4 ( quadrature :: Q , x1 :: R , x2 :: R , x3 :: R , A :: U , B :: U , C :: U , D :: U , e11 :: R , e12 :: R , e13 :: R , e22 :: R , e23 :: R , e33 :: R , G :: R , nu :: R ) where { R , U , Q } Compute stress arisen from inelastic strain in Tet4 elements. Please see original version for complete details, especially the coordinate system used here. Arguments quadrature : quadrature rule for integration, see FastGaussQuadrature.jl x1 , x2 , x3 : observational position A , B , C , D : a list of 3 numbers for each, each of which represents coordinates of the vertex e** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} G : shear modulus nu : poisson ratio Output A vector of 6 numbers, each represents \u03c3_{11} \u03c3_{11} , \u03c3_{12} \u03c3_{12} , \u03c3_{13} \u03c3_{13} , \u03c3_{22} \u03c3_{22} , \u03c3_{23} \u03c3_{23} , \u03c3_{33} \u03c3_{33} Notice Inplace version: sbarbot_stress_tet4!(u, args...) where u is a vector of 6 numbers. # Quaycle.td_disp_fs \u2014 Method . 1 td_disp_fs ( X :: T , Y :: T , Z :: T , P1 :: V , P2 :: V , P3 :: V , Ss :: T , Ds :: T , Ts :: T , nu :: T ) where { T , V } Compute displacement risen from triangular dislocation in elastic fullspace . Please see original version (in supporting information) for details, especially the coordinate system used here. Arguments The same as td_disp_hs # Quaycle.td_disp_hs \u2014 Method . 1 td_disp_hs ( X :: T , Y :: T , Z :: T , P1 :: V , P2 :: V , P3 :: V , Ss :: T , Ds :: T , Ts :: T , nu :: T ) where { T , V } Compute displacement risen from triangular dislocation in elastic halfspace . Please see original version (in supporting information) for details, especially the coordinate system used here. Arguments X , Y , Z : observational coordinates P1 , P2 , P3 : three triangular vertices coordinates respectively Ss , Ds , Ts : triangular dislocation vector, Strike-slip, Dip-slip, Tensile-slip respectively nu : poisson ratio Output By order: u_x u_x , u_y u_y , u_z u_z # Quaycle.td_stress_fs \u2014 Method . 1 td_stress_fs ( X :: T , Y :: T , Z :: T , P1 :: V , P2 :: V , P3 :: V , Ss :: T , Ds :: T , Ts :: T , \u03bb :: T , \u03bc :: T ) where { T , V } Compute stress risen from triangular dislocation in elastic fullspace . Please see original version (in supporting information) for details, especially the coordinate system used here. Arguments The same as td_stress_hs # Quaycle.td_stress_hs \u2014 Method . 1 td_stress_hs ( X :: T , Y :: T , Z :: T , P1 :: V , P2 :: V , P3 :: V , Ss :: T , Ds :: T , Ts :: T , \u03bb :: T , \u03bc :: T ) where { T , V } Compute stress risen from triangular dislocation in elastic halfspace . Please see original version (in supporting information) for details, especially the coordinate system used here. Arguments X , Y , Z : observational coordinates P1 , P2 , P3 : three triangular vertices coordinates respectively Ss , Ds , Ts : triangular dislocation vector, Strike-slip, Dip-slip, Tensile-slip respectively \u03bb : Lam\u00e9's first parameter \u03bc : shear modulus Output By order: \u03c3_{xx} \u03c3_{xx} , \u03c3_{yy} \u03c3_{yy} , \u03c3_{zz} \u03c3_{zz} , \u03c3_{xy} \u03c3_{xy} , \u03c3_{xz} \u03c3_{xz} , \u03c3_{yz} \u03c3_{yz} . Please be aware of its different order, where principle components come first, against sbarbot_stress_hex8 and sbarbot_stress_tet4 aside from coordinate system difference. References \u00b6 Okada, Y. (1992). Internal deformation due to shear and tensile faults in a half-space. Bulletin of the Seismological Society of America, 82(2), 1018\u20131040. Pan, E., Yuan, J. H., Chen, W. Q., & Griffith, W. A. (2014). Elastic Deformation due to Polygonal Dislocations in a Transversely Isotropic Half\u2010SpaceElastic Deformation due to Polygonal Dislocations in a Transversely Isotropic Half\u2010Space. Bulletin of the Seismological Society of America, 104(6), 2698\u20132716. https://doi.org/10.1785/0120140161 Nikkhoo, M., & Walter, T. R. (2015). Triangular dislocation: an analytical, artefact-free solution. Geophysical Journal International, 201(2), 1119\u20131141. https://doi.org/10.1093/gji/ggv035 Barbot, S., Moore, J. D. P., & Lambert, V. (2017). Displacement and Stress Associated with Distributed Anelastic Deformation in a Half\u2010Space. Bulletin of the Seismological Society of America, 107(2), 821\u2013855. https://doi.org/10.1785/0120160237 Barbot, S. (2018). Deformation of a Half\u2010Space from Anelastic Strain Confined in a Tetrahedral Volume. Bulletin of the Seismological Society of America, 108(5A), 2687\u20132712. https://doi.org/10.1785/0120180058","title":"Greens Function"},{"location":"interface_greensfun/#greens-function","text":"The interactions among fault patches, asthenosphere elements as well as between fault and asthenosphere are computed via convolution of Green's Function. Currently supported Green's Function: 1D elastic line dislocation 2D elastic rectangular dislocation 2D elastic triangular dislocation 3D inelastic strain in Hex8 or Tet4 elements Other types, such as 2D inelastic (plane stress or antiplane stress), polygon dislocation, are WIP ( PR are welcome! ). All functions translated here are ensured to be type stable and have minimum allocation. Broadcasting isn't supported here ( why? ) so you can easily embed them into multiprocessors parallel computation, which is implemented here. Also be aware of the coordinate system difference among all the Green's function provided here. Users are encouraged to view the original sources for further details. This package preserves the original coordinate systems as well as function arguments for all, whose outcomes are also tested against original ones.","title":"Green's Function"},{"location":"interface_greensfun/#public-interface","text":"# Quaycle.compose_stress_greens_func \u2014 Method . 1 2 compose_stress_greens_func ( ee :: AbstractArray , ev :: NTuple , ve :: NTuple , vv :: NTuple { N , <: Tuple }, \u03f5comp :: NTuple , \u03c3comp :: NTuple ) where N Concatenate tuple of matrix or tuple of tuple of matrix which arrange them in a way to update traction/stress rate using only one BLAS call. It does nothing to the elastic Green's function and specifically used for the outputs from stress_greens_func and stress_greens_func . Arguments ee::AbstractArray : traction Green's function within the elastic fault ev::NTuple : stress Green's function from elastic fault to inelastic asthenosphere ve::NTuple : traction Green's function inelastic asthenosphere to elastic fault vv::NTuple : stress Green's function within inelastic asthenosphere \u03f5comp : strain component to be considered, must be a subset of \u03c3comp \u03c3comp : stress component to be considered # Quaycle.compose_stress_greens_func \u2014 Method . 1 2 compose_stress_greens_func ( mf :: OkadaMesh , me :: SBarbotMeshEntity , \u03bb :: T , \u03bc :: T , ft :: PlaneFault , comp :: NTuple { N , <: Symbol }) where { T , N } Shortcut function for computing all 4 Green's function for viscoelastic relaxation. Arguments stays the same as stress_greens_func . # Quaycle.stress_greens_func \u2014 Method . 1 2 3 stress_greens_func ( mf :: AbstractMesh { 2 }, ma :: SBarbotMeshEntity { 3 }, \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault , \u03c3comp :: NTuple { N , Symbol }; kwargs ... ) where { T <: Real , I <: Integer , N } Compute stress Green's function from fault mesh to asthenosphere mesh. Arguments mf::AbstractMesh{2} : mesh of fault ma::SBarbotMeshEntity{3} : mesh of asthenosphere \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() \u03c3comp::NTuple{N, Symbol} : stress components to consider KWARGS Arguments The same as previously mentioned: nrept::Integer buffer_ratio::Real Output The output is a tuple of length(\u03c3comp) matrix, each corresponds \u03c3_{ij} \u03c3_{ij} in the same order as given by \u03c3comp . # Quaycle.stress_greens_func \u2014 Method . 1 stress_greens_func ( mesh :: LineOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; kwargs ... ) where T Compute traction Green function in 1-D elastic fault in LineOkadaMesh . Arguments mesh::LineOkadaMesh : the line mesh coupled with dc3d \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments ax_ratio::Real : ratio of along-strike to along-downdip, default is 12.5 # Quaycle.stress_greens_func \u2014 Method . 1 2 stress_greens_func ( mesh :: RectOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; fourier_domain = true , kwargs ... ) where T Compute traction Green's function in 2-D elastic fault in RectOkadaMesh . Translational symmetry is considered. Arguments mesh::RectOkadaMesh : the rectangular mesh coupled with dc3d \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments fourier_domain::Bool : whether or not transform the tensor to fourier domain nrept::Integer : number of periodic summation is performed buffer_ratio::Real : ratio of length of buffer zone (along-strike) to that of fault (along-strike) It is recommended to set at least 1 for strike-slip fault for mimicing zero-dislocation at ridge on both sides. # Quaycle.stress_greens_func \u2014 Method . 1 stress_greens_func ( mesh :: TDTri3MeshEntity , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; kwargs ... ) where T Compute traction Green's function in 2-D elastic fault in TDTri3MeshEntity . Arguments mesh::TDTri3MeshEntity : the triangular mesh coupled with td_stress_hs \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments nrept::Integer : number of periodic summation is performed buffer_ratio::Real : ratio of length of buffer zone (along-strike) to that of fault (along-strike). Notice the direction of strike is the average value of mesh.ss and the length is the strike projected maximum horizontal expansion. # Quaycle.stress_greens_func \u2014 Method . 1 2 stress_greens_func ( ma :: SBarbotMeshEntity { 3 }, \u03bb :: T , \u03bc :: T , \u03f5comp :: NTuple { N1 , Symbol }, \u03c3comp :: NTuple { N2 , Symbol }; kwargs ... ) where { T , N1 , N2 } Compute stress Green's function within SBarbotTet4MeshEntity or SBarbotHex8MeshEntity Arguments ma::SBarbotMeshEntity{3} : asthenosphere mesh \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus \u03f5comp : the strain \u03f5component(s) to be considered \u03c3comp::NTuple{N, Symbol} : stress components to consider Output A tuple of n n tuple of matrix, each tuple represents interaction from one strain component, w.r.t. \u03f5comp to the stress \u03f5components, whose order is \u03c3_{ij} \u03c3_{ij} whose order is the same as \u03c3comp , each of which is a matrix. # Quaycle.stress_greens_func \u2014 Method . 1 2 stress_greens_func ( ma :: SBarbotMeshEntity { 3 }, mf :: AbstractMesh { 2 }, \u03bb :: T , \u03bc :: T , ft :: PlaneFault , \u03f5comp :: NTuple { N , Symbol }; kwargs ... ) where { T , N } Compute traction Green's function from SBarbotTet4MeshEntity or SBarbotHex8MeshEntity to RectOkadaMesh Arguments ma::SBarbotMeshEntity{3} : asthenosphere mesh mf::AbstractMesh{2} : fault mesh \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() \u03f5comp : the strain \u03f5component(s) to be considered Output A tuple of n n matrix, each represents interaction from one strain to the traction on fault. # Quaycle.dc3d \u2014 Method . 1 2 3 dc3d ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al :: Union { A , SubArray }, aw :: Union { A , SubArray }, disl :: A ) where { T <: Number , A <: AbstractVecOrMat { T }} Calculate displacements and gradient of displacements due to a rectangular dislocation in an elastic isotropic halfspace. Please see dc3d for details. Also this fault coordinate system is widely used in this package. Arguments x , y , z : observational position, where z \u2264 0 z \u2264 0 \u03b1 : elastic constant dep : depth of fault origin dip : dip angle in degree al : a vector of 2 numbers, indicating along strike (x-axis) spanning aw : a vector of 2 numbers, indicating along downdip (y-z plane) spanning disl : a vector of 3 numbers, indicating dislocation in along-strike, along-downdip and tensile respectively. Output A vector of 12 numbers, each is u_{x} u_{x} , u_{y} u_{y} , u_{z} u_{z} , u_{x,x} u_{x,x} , u_{y,x} u_{y,x} , u_{z,x} u_{z,x} , u_{x,y} u_{x,y} , u_{y,y} u_{y,y} , u_{z,y} u_{z,y} , u_{x,z} u_{x,z} u_{y,z} u_{y,z} , u_{z,z} u_{z,z} . # Quaycle.sbarbot_disp_hex8 \u2014 Method . 1 2 3 4 5 6 sbarbot_disp_hex8 ( x1 :: R , x2 :: R , x3 :: R , q1 :: R , q2 :: R , q3 :: R , L :: R , T :: R , W :: R , theta :: R , epsv11p :: R , epsv12p :: R , epsv13p :: R , epsv22p :: R , epsv23p :: R , epsv33p :: R , G :: R , nu :: R , ) where R Compute displacement arisen from inelastic strain in Hex8 elements. Please see original version for complete details, especially the coordinate system used here. Arguments x1 , x2 , x3 : observational position, where x_{3} \u2265 0 x_{3} \u2265 0 q1 , q2 , q3 : Hex8 element position, where q_{3} \u2265 0 q_{3} \u2265 0 L , T , W : Hex8 element length, thickness and width theta : strike angle epsv** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} G : shear modulus nu : poisson ratio Output A vector of 3 numbers, each represents u_{1} u_{1} , u_{2} u_{2} , u_{3} u_{3} Notice Inplace version: sbarbot_disp_hex8!(u, args...) where u is a vector of 3 numbers. # Quaycle.sbarbot_stress_hex8 \u2014 Method . 1 2 3 4 5 6 sbarbot_stress_hex8 ( x1 :: R , x2 :: R , x3 :: R , q1 :: R , q2 :: R , q3 :: R , L :: R , T :: R , W :: R , theta :: R , epsv11p :: R , epsv12p :: R , epsv13p :: R , epsv22p :: R , epsv23p :: R , epsv33p :: R , G :: R , nu :: R , ) where R Compute stress arisen from inelastic strain in Hex8 elements. Please see original version for complete details, especially the coordinate system used here. Arguments The same as sbarbot_disp_hex8 Output A vector of 6 numbers, each represents \u03c3_{11} \u03c3_{11} , \u03c3_{12} \u03c3_{12} , \u03c3_{13} \u03c3_{13} , \u03c3_{22} \u03c3_{22} , \u03c3_{23} \u03c3_{23} , \u03c3_{33} \u03c3_{33} Notice Inplace version: sbarbot_stress_hex8!(u, args...) where u is a vector of 6 numbers. # Quaycle.sbarbot_disp_tet4 \u2014 Method . 1 2 3 4 sbarbot_disp_tet4 ( quadrature :: Q , x1 :: R , x2 :: R , x3 :: R , A :: U , B :: U , C :: U , D :: U , e11 :: R , e12 :: R , e13 :: R , e22 :: R , e23 :: R , e33 :: R , nu :: R ) where { R , U , Q } Compute displacement arisen from inelastic strain in Tet4 elements. Please see original version for complete details, especially the coordinate system used here. Arguments quadrature : quadrature rule for integration, see FastGaussQuadrature.jl x1 , x2 , x3 : observational position, where x_{3} \u2265 0 x_{3} \u2265 0 A , B , C , D : a list of 3 numbers for each, each of which represents coordinates of the vertex. All depth coordinates must be greater or equal to 0 (no checking is performed here) e** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} nu : poisson ratio Output A vector of 3 numbers, each represents u_{1} u_{1} , u_{2} u_{2} , u_{3} u_{3} Notice Inplace version: sbarbot_disp_tet4!(u, args...) where u is a vector of 3 numbers. # Quaycle.sbarbot_stress_tet4 \u2014 Method . 1 2 3 4 sbarbot_stress_tet4 ( quadrature :: Q , x1 :: R , x2 :: R , x3 :: R , A :: U , B :: U , C :: U , D :: U , e11 :: R , e12 :: R , e13 :: R , e22 :: R , e23 :: R , e33 :: R , G :: R , nu :: R ) where { R , U , Q } Compute stress arisen from inelastic strain in Tet4 elements. Please see original version for complete details, especially the coordinate system used here. Arguments quadrature : quadrature rule for integration, see FastGaussQuadrature.jl x1 , x2 , x3 : observational position A , B , C , D : a list of 3 numbers for each, each of which represents coordinates of the vertex e** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} G : shear modulus nu : poisson ratio Output A vector of 6 numbers, each represents \u03c3_{11} \u03c3_{11} , \u03c3_{12} \u03c3_{12} , \u03c3_{13} \u03c3_{13} , \u03c3_{22} \u03c3_{22} , \u03c3_{23} \u03c3_{23} , \u03c3_{33} \u03c3_{33} Notice Inplace version: sbarbot_stress_tet4!(u, args...) where u is a vector of 6 numbers. # Quaycle.td_disp_fs \u2014 Method . 1 td_disp_fs ( X :: T , Y :: T , Z :: T , P1 :: V , P2 :: V , P3 :: V , Ss :: T , Ds :: T , Ts :: T , nu :: T ) where { T , V } Compute displacement risen from triangular dislocation in elastic fullspace . Please see original version (in supporting information) for details, especially the coordinate system used here. Arguments The same as td_disp_hs # Quaycle.td_disp_hs \u2014 Method . 1 td_disp_hs ( X :: T , Y :: T , Z :: T , P1 :: V , P2 :: V , P3 :: V , Ss :: T , Ds :: T , Ts :: T , nu :: T ) where { T , V } Compute displacement risen from triangular dislocation in elastic halfspace . Please see original version (in supporting information) for details, especially the coordinate system used here. Arguments X , Y , Z : observational coordinates P1 , P2 , P3 : three triangular vertices coordinates respectively Ss , Ds , Ts : triangular dislocation vector, Strike-slip, Dip-slip, Tensile-slip respectively nu : poisson ratio Output By order: u_x u_x , u_y u_y , u_z u_z # Quaycle.td_stress_fs \u2014 Method . 1 td_stress_fs ( X :: T , Y :: T , Z :: T , P1 :: V , P2 :: V , P3 :: V , Ss :: T , Ds :: T , Ts :: T , \u03bb :: T , \u03bc :: T ) where { T , V } Compute stress risen from triangular dislocation in elastic fullspace . Please see original version (in supporting information) for details, especially the coordinate system used here. Arguments The same as td_stress_hs # Quaycle.td_stress_hs \u2014 Method . 1 td_stress_hs ( X :: T , Y :: T , Z :: T , P1 :: V , P2 :: V , P3 :: V , Ss :: T , Ds :: T , Ts :: T , \u03bb :: T , \u03bc :: T ) where { T , V } Compute stress risen from triangular dislocation in elastic halfspace . Please see original version (in supporting information) for details, especially the coordinate system used here. Arguments X , Y , Z : observational coordinates P1 , P2 , P3 : three triangular vertices coordinates respectively Ss , Ds , Ts : triangular dislocation vector, Strike-slip, Dip-slip, Tensile-slip respectively \u03bb : Lam\u00e9's first parameter \u03bc : shear modulus Output By order: \u03c3_{xx} \u03c3_{xx} , \u03c3_{yy} \u03c3_{yy} , \u03c3_{zz} \u03c3_{zz} , \u03c3_{xy} \u03c3_{xy} , \u03c3_{xz} \u03c3_{xz} , \u03c3_{yz} \u03c3_{yz} . Please be aware of its different order, where principle components come first, against sbarbot_stress_hex8 and sbarbot_stress_tet4 aside from coordinate system difference.","title":"Public Interface"},{"location":"interface_greensfun/#references","text":"Okada, Y. (1992). Internal deformation due to shear and tensile faults in a half-space. Bulletin of the Seismological Society of America, 82(2), 1018\u20131040. Pan, E., Yuan, J. H., Chen, W. Q., & Griffith, W. A. (2014). Elastic Deformation due to Polygonal Dislocations in a Transversely Isotropic Half\u2010SpaceElastic Deformation due to Polygonal Dislocations in a Transversely Isotropic Half\u2010Space. Bulletin of the Seismological Society of America, 104(6), 2698\u20132716. https://doi.org/10.1785/0120140161 Nikkhoo, M., & Walter, T. R. (2015). Triangular dislocation: an analytical, artefact-free solution. Geophysical Journal International, 201(2), 1119\u20131141. https://doi.org/10.1093/gji/ggv035 Barbot, S., Moore, J. D. P., & Lambert, V. (2017). Displacement and Stress Associated with Distributed Anelastic Deformation in a Half\u2010Space. Bulletin of the Seismological Society of America, 107(2), 821\u2013855. https://doi.org/10.1785/0120160237 Barbot, S. (2018). Deformation of a Half\u2010Space from Anelastic Strain Confined in a Tetrahedral Volume. Bulletin of the Seismological Society of America, 108(5A), 2687\u20132712. https://doi.org/10.1785/0120180058","title":"References"},{"location":"interface_mesh/","text":"Mesh \u00b6 This package provides some buildin structured mesh functionality and some data structures coupled with existing Green's functions where users could explore external mesh tools. This package also has rich utilities based on Gmsh . To use them, it is recommended to install GmshTools.jl which automatically downloads Gmsh SDK and provides a few convenient macros. 1 2 3 pkg > add GmshTools julia > using Quaycle julia > using GmshTools Users are encouraged to read Gmsh Julia API for more comprehensive operations. Public Interface \u00b6 # Quaycle.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ) Generate LineOkadaMesh Arguments \u03be : downdip length \u0394\u03be : downdip interval dip : dipping angle # Quaycle.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ) Generate RectOkadaMesh Arguments x : along strike length \u03be : downdip length \u0394x : along strike interval \u0394\u03be : downdip interval dip : dipping angle # Quaycle.gen_gmsh_mesh \u2014 Method . 1 gen_gmsh_mesh ( mf :: OkadaMesh ; kwargs ... ) Generate an equivalent unstructured mesh as mf::OkadaMesh Arguments mf::OkadaMesh : the structured mesh kwargs... : stay the same as other methods for gen_gmsh_mesh # Quaycle.gen_gmsh_mesh \u2014 Method . 1 2 3 4 5 gen_gmsh_mesh ( mf :: RectOkadaMesh , :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Generate a mesh combinating RectOkadaMesh and BoxHexExtrudeFromSurface mesh for asthenosphere. The first argument is the corresponding RectOkadaMesh , the rest ones stay the same. # Quaycle.gen_gmsh_mesh \u2014 Method . 1 2 3 4 gen_gmsh_mesh ( :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Gernate a box for Asthenosphere using 8-node hexahedron elements (via setting transfinite curve). Arguments llx , lly , llz : coordinates of low-left corner on the top surface dx , dy , dz : x-, y-, z-extension nx , ny : number of cells along x-, y-axis rfx , rfy : refinement coefficients along x-, y-axis using Bump algorithm, please refer gmsh.model.geo.mesh.setTransfiniteCurve rfzn : number of cells along z-axis, please refer numElements in gmsh.model.geo.extrude rfzh : accumulated height of cells along z-axis, please refer heights in gmsh.model.geo.extrude # Quaycle.gen_gmsh_mesh \u2014 Method . 1 2 gen_gmsh_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ; filename :: AbstractString = \"temp.msh\" , reg :: Integer = 1 ) where T Generate equivalent LineOkadaMesh via Gmsh buildin engine. Extra Arguments filename::AbstractString=\"temp.msh\" : name of the generated mesh file. The file ext will be automatically handled by Gmsh. reg::Integer=1 : the starting tag for entity of any dimension The rest arguments stay the same as gen_mesh . # Quaycle.gen_gmsh_mesh \u2014 Method . 1 2 gen_gmsh_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ; filename :: AbstractString = \"temp.msh\" , reg :: Integer = 1 ) where T Generate equivalent RectOkadaMesh via Gmsh buildin engine. Extra Arguments filename::AbstractString=\"temp.msh\" : name of the generated mesh file. The file ext will be automatically handled by Gmsh. reg::Integer=1 : the starting tag for entity of any dimension The rest arguments stay the same as gen_mesh . # Quaycle.gmsh_vtk_output_cache \u2014 Method . 1 gmsh_vtk_output_cache ( file :: AbstractString , phydim :: I , phytag :: I ) where I <: Integer Create cache of unstructured mesh for VTK output. Arguments file::AbstractString : mesh file phydim : physical group dimension, which you will querry phytag : physical group tag associated with phydim . If smaller than 0, retrieve all entities in physical group whose dimension is phydim . If in this case, only one such entity, binded with that physical group, shall exist. If you would like to write multi-block data, create VTK output caches for each physical group. # Quaycle.gmsh_vtk_output_cache \u2014 Method . 1 gmsh_vtk_output_cache ( file :: AbstractString , mf :: OkadaMesh { N }, phytag :: Integer =- 1 , datatype = Float64 ) where N Create cache of structured OkadaMesh for VTK output, which handles the data mapping from structured data to unstructured mesh. It's worth mention that currently WriteVTK cannot write inclined plane in 3D space. As a workround, it seeks transfering from Gmsh unstructured (transfinite) mesh. Arguments file::AbstractString : mesh file containing fault mesh (transfinite) mf::OkadaMesh{N} : equivalent structured mesh, must match unstructured mesh in the file above phytag::Integer=-1 : physical group tag associated with fault mesh in the mesh file. If smaller than 0, retrieve all entities in physical group whose dimension is determined by mf . If in this case, only one such entity, assumed to be the fault, shall exist. datatype=Float64 : data type for temporary array storing the mapped data # Quaycle.read_gmsh_mesh \u2014 Method . 1 2 read_gmsh_mesh ( :: Val { : SBarbotHex8 }, f :: AbstractString ; phytag :: Integer =- 1 , rotate :: Number = 0.0 , reverse = false , check = false ) Read the mesh and construct mesh entity infomation for SBarbot Hex8 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 3-dimensional entities. If in this case, your mesh must contain only one element type, which should be Hex8 rotate : the angle of strike direction, see sbarbot_disp_hex8! . If your meshing box isn't parallel to x, y-axis, your must provide your strike angle manually. By default, the strike angle is zero reverse : if true , reverse the along-x, y-node tag during read. By default, 1\u21924 in x-axis, 1\u21922 in y-axis, 1\u21925 in z-axis check : if true , check that number of distinctive q1 equals that of x1 , same for q2 and x2 at orthogonal direction, which should hold for transfinite mesh. Notice This function can only be used for Hex8 element with each element lying parallel to z-axis. The check procedure is not complete for arbitrary strike angle (0 < \u03b8 < 90). The user should take a close look on the node ordering for one element to ensure the x-, y-extent are correctly resolved by change reverse accordingly. # Quaycle.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : SBarbotTet4 }, f :: AbstractString ; phytag :: Integer =- 1 ) Read the mesh and construct mesh entity infomation for SBarbot Tet4 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 3-dimensional entities. If in this case, your mesh must contain only one element type, which should be Tet4. # Quaycle.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : TDTri3 }, f :: AbstractString ; phytag :: Integer =- 1 ) Read the mesh and construct mesh entity infomation for triangular Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 2-dimensional entities. If in this case, your mesh must contain only one element type, which should be Tri3. atol : absolute tolerance, by default 1e-12 , to determine whether the triangle is parallel to axis. If this reading procedure does not resolve the slip direction correctly, try to lower this value. # Quaycle.DIPPING \u2014 Type . Dipping, indicate dislocation occurs at downdip direction. # Quaycle.STRIKING \u2014 Type . Striking, indicate dislocation occurs at strike direction. References \u00b6 Geuzaine, C., & Remacle, J.-F. (2009). Gmsh: A 3-D finite element mesh generator with built-in pre- and post-processing facilities. International Journal for Numerical Methods in Engineering, 79(11), 1309\u20131331. https://doi.org/10.1002/nme.2579","title":"Mesh"},{"location":"interface_mesh/#mesh","text":"This package provides some buildin structured mesh functionality and some data structures coupled with existing Green's functions where users could explore external mesh tools. This package also has rich utilities based on Gmsh . To use them, it is recommended to install GmshTools.jl which automatically downloads Gmsh SDK and provides a few convenient macros. 1 2 3 pkg > add GmshTools julia > using Quaycle julia > using GmshTools Users are encouraged to read Gmsh Julia API for more comprehensive operations.","title":"Mesh"},{"location":"interface_mesh/#public-interface","text":"# Quaycle.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ) Generate LineOkadaMesh Arguments \u03be : downdip length \u0394\u03be : downdip interval dip : dipping angle # Quaycle.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ) Generate RectOkadaMesh Arguments x : along strike length \u03be : downdip length \u0394x : along strike interval \u0394\u03be : downdip interval dip : dipping angle # Quaycle.gen_gmsh_mesh \u2014 Method . 1 gen_gmsh_mesh ( mf :: OkadaMesh ; kwargs ... ) Generate an equivalent unstructured mesh as mf::OkadaMesh Arguments mf::OkadaMesh : the structured mesh kwargs... : stay the same as other methods for gen_gmsh_mesh # Quaycle.gen_gmsh_mesh \u2014 Method . 1 2 3 4 5 gen_gmsh_mesh ( mf :: RectOkadaMesh , :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Generate a mesh combinating RectOkadaMesh and BoxHexExtrudeFromSurface mesh for asthenosphere. The first argument is the corresponding RectOkadaMesh , the rest ones stay the same. # Quaycle.gen_gmsh_mesh \u2014 Method . 1 2 3 4 gen_gmsh_mesh ( :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Gernate a box for Asthenosphere using 8-node hexahedron elements (via setting transfinite curve). Arguments llx , lly , llz : coordinates of low-left corner on the top surface dx , dy , dz : x-, y-, z-extension nx , ny : number of cells along x-, y-axis rfx , rfy : refinement coefficients along x-, y-axis using Bump algorithm, please refer gmsh.model.geo.mesh.setTransfiniteCurve rfzn : number of cells along z-axis, please refer numElements in gmsh.model.geo.extrude rfzh : accumulated height of cells along z-axis, please refer heights in gmsh.model.geo.extrude # Quaycle.gen_gmsh_mesh \u2014 Method . 1 2 gen_gmsh_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ; filename :: AbstractString = \"temp.msh\" , reg :: Integer = 1 ) where T Generate equivalent LineOkadaMesh via Gmsh buildin engine. Extra Arguments filename::AbstractString=\"temp.msh\" : name of the generated mesh file. The file ext will be automatically handled by Gmsh. reg::Integer=1 : the starting tag for entity of any dimension The rest arguments stay the same as gen_mesh . # Quaycle.gen_gmsh_mesh \u2014 Method . 1 2 gen_gmsh_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ; filename :: AbstractString = \"temp.msh\" , reg :: Integer = 1 ) where T Generate equivalent RectOkadaMesh via Gmsh buildin engine. Extra Arguments filename::AbstractString=\"temp.msh\" : name of the generated mesh file. The file ext will be automatically handled by Gmsh. reg::Integer=1 : the starting tag for entity of any dimension The rest arguments stay the same as gen_mesh . # Quaycle.gmsh_vtk_output_cache \u2014 Method . 1 gmsh_vtk_output_cache ( file :: AbstractString , phydim :: I , phytag :: I ) where I <: Integer Create cache of unstructured mesh for VTK output. Arguments file::AbstractString : mesh file phydim : physical group dimension, which you will querry phytag : physical group tag associated with phydim . If smaller than 0, retrieve all entities in physical group whose dimension is phydim . If in this case, only one such entity, binded with that physical group, shall exist. If you would like to write multi-block data, create VTK output caches for each physical group. # Quaycle.gmsh_vtk_output_cache \u2014 Method . 1 gmsh_vtk_output_cache ( file :: AbstractString , mf :: OkadaMesh { N }, phytag :: Integer =- 1 , datatype = Float64 ) where N Create cache of structured OkadaMesh for VTK output, which handles the data mapping from structured data to unstructured mesh. It's worth mention that currently WriteVTK cannot write inclined plane in 3D space. As a workround, it seeks transfering from Gmsh unstructured (transfinite) mesh. Arguments file::AbstractString : mesh file containing fault mesh (transfinite) mf::OkadaMesh{N} : equivalent structured mesh, must match unstructured mesh in the file above phytag::Integer=-1 : physical group tag associated with fault mesh in the mesh file. If smaller than 0, retrieve all entities in physical group whose dimension is determined by mf . If in this case, only one such entity, assumed to be the fault, shall exist. datatype=Float64 : data type for temporary array storing the mapped data # Quaycle.read_gmsh_mesh \u2014 Method . 1 2 read_gmsh_mesh ( :: Val { : SBarbotHex8 }, f :: AbstractString ; phytag :: Integer =- 1 , rotate :: Number = 0.0 , reverse = false , check = false ) Read the mesh and construct mesh entity infomation for SBarbot Hex8 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 3-dimensional entities. If in this case, your mesh must contain only one element type, which should be Hex8 rotate : the angle of strike direction, see sbarbot_disp_hex8! . If your meshing box isn't parallel to x, y-axis, your must provide your strike angle manually. By default, the strike angle is zero reverse : if true , reverse the along-x, y-node tag during read. By default, 1\u21924 in x-axis, 1\u21922 in y-axis, 1\u21925 in z-axis check : if true , check that number of distinctive q1 equals that of x1 , same for q2 and x2 at orthogonal direction, which should hold for transfinite mesh. Notice This function can only be used for Hex8 element with each element lying parallel to z-axis. The check procedure is not complete for arbitrary strike angle (0 < \u03b8 < 90). The user should take a close look on the node ordering for one element to ensure the x-, y-extent are correctly resolved by change reverse accordingly. # Quaycle.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : SBarbotTet4 }, f :: AbstractString ; phytag :: Integer =- 1 ) Read the mesh and construct mesh entity infomation for SBarbot Tet4 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 3-dimensional entities. If in this case, your mesh must contain only one element type, which should be Tet4. # Quaycle.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : TDTri3 }, f :: AbstractString ; phytag :: Integer =- 1 ) Read the mesh and construct mesh entity infomation for triangular Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 2-dimensional entities. If in this case, your mesh must contain only one element type, which should be Tri3. atol : absolute tolerance, by default 1e-12 , to determine whether the triangle is parallel to axis. If this reading procedure does not resolve the slip direction correctly, try to lower this value. # Quaycle.DIPPING \u2014 Type . Dipping, indicate dislocation occurs at downdip direction. # Quaycle.STRIKING \u2014 Type . Striking, indicate dislocation occurs at strike direction.","title":"Public Interface"},{"location":"interface_mesh/#references","text":"Geuzaine, C., & Remacle, J.-F. (2009). Gmsh: A 3-D finite element mesh generator with built-in pre- and post-processing facilities. International Journal for Numerical Methods in Engineering, 79(11), 1309\u20131331. https://doi.org/10.1002/nme.2579","title":"References"},{"location":"interface_property/","text":"Simulation Properties \u00b6 We attribute one struct of all necessary properties for each type of simulation objections. Public Interface \u00b6 # Quaycle.SingleDofRSFProperty \u2014 Type . System property for single degree of freedom under rate-state friction. Fields a : contrib from velocity b : contrib from state L : critical distance k : spring stiffness \u03c3 : effective normal stress \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # Quaycle.RateStateQuasiDynamicProperty \u2014 Type . System property for multiple fault patches under rate-state friction. Fields a : contrib from velocity b : contrib from state L : critical distance \u03c3 : effective normal stress \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # Quaycle.DislocationCreepProperty \u2014 Type . System properties for plastic deformation of dislocation creep . Please refer (Hirth & Kohlstedt, 2003) for concrete units of each factor. Fields A : prefactor n : power law stress exponent COH : water content 1 r : water fugacity exponent \u03b1 : melting constant \u03d5 : melting fraction Q : activation energy P : pressure \u03a9 : activation volume T : temperature source # Quaycle.DiffusionCreepProperty \u2014 Type . System properties for plastic deformation of diffusion creep . Please refer (Hirth & Kohlstedt, 2003) for concrete units of each factor. Fields A : prefactor d : grain size m : grain size exponent COH : water content 1 r : water fugacity exponent \u03b1 : melting constant \u03d5 : melting fraction Q : activation energy P : pressure \u03a9 : activation volume T : temperature source # Quaycle.PeierlsProperty \u2014 Type . System properties for plastic deformation of Peierls Mechanisms . Not implemented yet. # Quaycle.CompositePlasticDeformationProperty \u2014 Type . Compose all three type of plastic deformation and other strain-related system properties, see (Kohlstedt & Hansen, 2015) . Each field is the overall equivalent factor not dependent on stress. Fields disl : dislocation creep n : stress exponent in dislocation creep diff : diffusion creep peie : Peierls mechanisms d\u03f5ref : reference strain rate whose length must equal strain components considered source # Quaycle.ViscoelasticMaxwellProperty \u2014 Type . Composite property for viscoelastic rheology of maxwell representation. Fields pe::RateStateQuasiDynamicProperty : elastic rate-and-state system property pv::CompositePlasticDeformationProperty : composite plastic deformation system property # Quaycle.compose \u2014 Method . 1 compose ( pe :: RateStateQuasiDynamicProperty { T }, d\u03f5ref :: AbstractVector , d\u03f5name :: AbstractVector , pvs ... ) where T Create maxwell viscoelastic system given both rate-and-state and plastic properties. Arguments pe::RateStateQuasiDynamicProperty{T} : elastic rate-and-state system property d\u03f5ref : reference strain rate whose length must equal to and order same as strain components considered pvs... : different type of plastic deformation system properties but no more than three # Quaycle.composite_factor \u2014 Method . 1 composite_factor ( pv :: PlasticDeformationProperty ) Compute an equivalent factor for levarage recomputing during ODE solving. Arguments pv::PlasticDeformationProperty : plastic deformation system property Some references may refer it as water fugacity f_{\\mathrm{H_{2} O}} f_{\\mathrm{H_{2} O}} , which is misleading. Since fugacity has the same dimension of chemical potential (Pa) while water content is dimensionless. \u21a9 \u21a9","title":"Simulation Property"},{"location":"interface_property/#simulation-properties","text":"We attribute one struct of all necessary properties for each type of simulation objections.","title":"Simulation Properties"},{"location":"interface_property/#public-interface","text":"# Quaycle.SingleDofRSFProperty \u2014 Type . System property for single degree of freedom under rate-state friction. Fields a : contrib from velocity b : contrib from state L : critical distance k : spring stiffness \u03c3 : effective normal stress \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # Quaycle.RateStateQuasiDynamicProperty \u2014 Type . System property for multiple fault patches under rate-state friction. Fields a : contrib from velocity b : contrib from state L : critical distance \u03c3 : effective normal stress \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # Quaycle.DislocationCreepProperty \u2014 Type . System properties for plastic deformation of dislocation creep . Please refer (Hirth & Kohlstedt, 2003) for concrete units of each factor. Fields A : prefactor n : power law stress exponent COH : water content 1 r : water fugacity exponent \u03b1 : melting constant \u03d5 : melting fraction Q : activation energy P : pressure \u03a9 : activation volume T : temperature source # Quaycle.DiffusionCreepProperty \u2014 Type . System properties for plastic deformation of diffusion creep . Please refer (Hirth & Kohlstedt, 2003) for concrete units of each factor. Fields A : prefactor d : grain size m : grain size exponent COH : water content 1 r : water fugacity exponent \u03b1 : melting constant \u03d5 : melting fraction Q : activation energy P : pressure \u03a9 : activation volume T : temperature source # Quaycle.PeierlsProperty \u2014 Type . System properties for plastic deformation of Peierls Mechanisms . Not implemented yet. # Quaycle.CompositePlasticDeformationProperty \u2014 Type . Compose all three type of plastic deformation and other strain-related system properties, see (Kohlstedt & Hansen, 2015) . Each field is the overall equivalent factor not dependent on stress. Fields disl : dislocation creep n : stress exponent in dislocation creep diff : diffusion creep peie : Peierls mechanisms d\u03f5ref : reference strain rate whose length must equal strain components considered source # Quaycle.ViscoelasticMaxwellProperty \u2014 Type . Composite property for viscoelastic rheology of maxwell representation. Fields pe::RateStateQuasiDynamicProperty : elastic rate-and-state system property pv::CompositePlasticDeformationProperty : composite plastic deformation system property # Quaycle.compose \u2014 Method . 1 compose ( pe :: RateStateQuasiDynamicProperty { T }, d\u03f5ref :: AbstractVector , d\u03f5name :: AbstractVector , pvs ... ) where T Create maxwell viscoelastic system given both rate-and-state and plastic properties. Arguments pe::RateStateQuasiDynamicProperty{T} : elastic rate-and-state system property d\u03f5ref : reference strain rate whose length must equal to and order same as strain components considered pvs... : different type of plastic deformation system properties but no more than three # Quaycle.composite_factor \u2014 Method . 1 composite_factor ( pv :: PlasticDeformationProperty ) Compute an equivalent factor for levarage recomputing during ODE solving. Arguments pv::PlasticDeformationProperty : plastic deformation system property Some references may refer it as water fugacity f_{\\mathrm{H_{2} O}} f_{\\mathrm{H_{2} O}} , which is misleading. Since fugacity has the same dimension of chemical potential (Pa) while water content is dimensionless. \u21a9 \u21a9","title":"Public Interface"},{"location":"interface_rheology/","text":"Rheology \u00b6 This package implements plastic deformation as the key for modeling asthenosphere dynamics. Currently, only DiffusionCreep and DislocationCreep are supported. Public Interface \u00b6 # Quaycle.DiffusionCreep \u2014 Type . \\dot{\u03f5} = A \u03c3\u2032 d^{-m} C_{\\mathrm{OH}} ^{r} \\exp{\\left(\u03b1\u03d5\\right)} \\exp{\\left(- \\frac{Q + PV}{RT}\\right)} \\dot{\u03f5} = A \u03c3\u2032 d^{-m} C_{\\mathrm{OH}} ^{r} \\exp{\\left(\u03b1\u03d5\\right)} \\exp{\\left(- \\frac{Q + PV}{RT}\\right)} # Quaycle.DislocationCreep \u2014 Type . \\dot{\u03f5} = A \u03c4^{n-1} \u03c3\u2032 C_{\\mathrm{OH}} ^{r} \\exp{\\left(\u03b1\u03d5\\right)} \\exp{\\left(- \\frac{Q + PV}{RT}\\right)} \\dot{\u03f5} = A \u03c4^{n-1} \u03c3\u2032 C_{\\mathrm{OH}} ^{r} \\exp{\\left(\u03b1\u03d5\\right)} \\exp{\\left(- \\frac{Q + PV}{RT}\\right)} # Quaycle.Peierls \u2014 Type . \\dot{\u03f5} = \\dot{\u03f5_{P}}\\left(\\frac{\u03c3}{G}\\right)^{2} \\exp{\\left(-\\frac{\u0394F_{k}^{o}}{RT}\\left(1 - \\left(\\frac{\u03c3}{\u03c3_{P}}\\right)^{r}\\right)^{s}\\right)} \\dot{\u03f5} = \\dot{\u03f5_{P}}\\left(\\frac{\u03c3}{G}\\right)^{2} \\exp{\\left(-\\frac{\u0394F_{k}^{o}}{RT}\\left(1 - \\left(\\frac{\u03c3}{\u03c3_{P}}\\right)^{r}\\right)^{s}\\right)} References \u00b6 Hirth, G., & Kohlstedt, D. (2003). Rheology of the Upper Mantle and the Mantle Wedge: A View from the Experimentalists. In Inside the Subduction Factory (pp. 83\u2013105). American Geophysical Union (AGU). https://doi.org/10.1029/138GM06 Karato, S. (2010). Rheology of the Earth\u2019s mantle: A historical review. Gondwana Research, 18(1), 17\u201345. https://doi.org/10.1016/j.gr.2010.03.004 Kohlstedt, D. L., & Hansen, L. N. (2015). 2.18 - Constitutive Equations, Rheological Behavior, and Viscosity of Rocks. In G. Schubert (Ed.), Treatise on Geophysics (Second Edition) (pp. 441\u2013472). Oxford: Elsevier. https://doi.org/10.1016/B978-0-444-53802-4.00042-7","title":"Rheology"},{"location":"interface_rheology/#rheology","text":"This package implements plastic deformation as the key for modeling asthenosphere dynamics. Currently, only DiffusionCreep and DislocationCreep are supported.","title":"Rheology"},{"location":"interface_rheology/#public-interface","text":"# Quaycle.DiffusionCreep \u2014 Type . \\dot{\u03f5} = A \u03c3\u2032 d^{-m} C_{\\mathrm{OH}} ^{r} \\exp{\\left(\u03b1\u03d5\\right)} \\exp{\\left(- \\frac{Q + PV}{RT}\\right)} \\dot{\u03f5} = A \u03c3\u2032 d^{-m} C_{\\mathrm{OH}} ^{r} \\exp{\\left(\u03b1\u03d5\\right)} \\exp{\\left(- \\frac{Q + PV}{RT}\\right)} # Quaycle.DislocationCreep \u2014 Type . \\dot{\u03f5} = A \u03c4^{n-1} \u03c3\u2032 C_{\\mathrm{OH}} ^{r} \\exp{\\left(\u03b1\u03d5\\right)} \\exp{\\left(- \\frac{Q + PV}{RT}\\right)} \\dot{\u03f5} = A \u03c4^{n-1} \u03c3\u2032 C_{\\mathrm{OH}} ^{r} \\exp{\\left(\u03b1\u03d5\\right)} \\exp{\\left(- \\frac{Q + PV}{RT}\\right)} # Quaycle.Peierls \u2014 Type . \\dot{\u03f5} = \\dot{\u03f5_{P}}\\left(\\frac{\u03c3}{G}\\right)^{2} \\exp{\\left(-\\frac{\u0394F_{k}^{o}}{RT}\\left(1 - \\left(\\frac{\u03c3}{\u03c3_{P}}\\right)^{r}\\right)^{s}\\right)} \\dot{\u03f5} = \\dot{\u03f5_{P}}\\left(\\frac{\u03c3}{G}\\right)^{2} \\exp{\\left(-\\frac{\u0394F_{k}^{o}}{RT}\\left(1 - \\left(\\frac{\u03c3}{\u03c3_{P}}\\right)^{r}\\right)^{s}\\right)}","title":"Public Interface"},{"location":"interface_rheology/#references","text":"Hirth, G., & Kohlstedt, D. (2003). Rheology of the Upper Mantle and the Mantle Wedge: A View from the Experimentalists. In Inside the Subduction Factory (pp. 83\u2013105). American Geophysical Union (AGU). https://doi.org/10.1029/138GM06 Karato, S. (2010). Rheology of the Earth\u2019s mantle: A historical review. Gondwana Research, 18(1), 17\u201345. https://doi.org/10.1016/j.gr.2010.03.004 Kohlstedt, D. L., & Hansen, L. N. (2015). 2.18 - Constitutive Equations, Rheological Behavior, and Viscosity of Rocks. In G. Schubert (Ed.), Treatise on Geophysics (Second Edition) (pp. 441\u2013472). Oxford: Elsevier. https://doi.org/10.1016/B978-0-444-53802-4.00042-7","title":"References"},{"location":"interface_visualize/","text":"Visualize \u00b6 This package provides some utilities for writing results to VTK (vts, vti, vtu, vtm, pvd, etc...) file for postprocessing with Paraview . Data cache for writing results are also implemented where users could explore other meshing tools. One short note is that if you store 6 components vector, for example \u03c3 \u03c3 , Paraview will interpret them in the order of \u03c3_{xx} \u03c3_{xx} , \u03c3_{yy} \u03c3_{yy} , \u03c3_{zz} \u03c3_{zz} , \u03c3_{xy} \u03c3_{xy} , \u03c3_{yz} \u03c3_{yz} , \u03c3_{xz} \u03c3_{xz} . Whereas in our assemble for stress, the order, same as e.g OpenFOAM, is \u03c3_{xx} \u03c3_{xx} , \u03c3_{xy} \u03c3_{xy} , \u03c3_{xz} \u03c3_{xz} , \u03c3_{yy} \u03c3_{yy} , \u03c3_{yz} \u03c3_{yz} , \u03c3_{zz} \u03c3_{zz} . Notice that these function are not fully tested. If you encounter any problem, please file an issue with your MWE. Public Interface \u00b6 # Quaycle.vtk_output \u2014 Method . 1 2 vtk_output ( f , t :: AbstractVector , u :: AbstractVector { <: AbstractVecOrMat }, ustr :: AbstractVector { <: AbstractString }, cache :: ParaviewOutputCache ) Write time-series results to single-block paraview collection file. Arguments f : output file name t::AbstractVector : time stamp vector u::AbstractVector{<:AbstractArray} , list of results to be written ustr::AbstractVector{<:AbstractString} : list results names to be assigned cache : cache of data conversion, cell information and nodes information # Quaycle.vtk_output \u2014 Method . 1 2 vtk_output ( f , u :: AbstractVector { <: AbstractVecOrMat }, ustr :: AbstractVector { <: AbstractString }, cache :: ParaviewOutputCache ) Write results to single-block VTU file. Arguments f : output file name u::AbstractVector , list of results to be written ustr::AbstractVector{<:AbstractString} : list results names to be assigned cache : cache of data conversion, cell information and nodes information # Quaycle.vtk_output \u2014 Method . 1 vtk_output ( f , p :: AbstractProperty , cache :: ParaviewOutputCache ) Store simulation property, including all its fields, to VTU file. Arguments f : output file name p : property struct cache : cache of data conversion, cell information and nodes information Notice Not all AbstractProperty are supported. Only those with well defined fieldnames are. For multi-block domain property, save them separately. # Quaycle.vtm_output \u2014 Method . 1 vtm_output ( f , u , ustr , cache :: ParaviewOutputCache ) Write results to multiple-block VTM file. Arguments f : output file name u , list of block to be written, each contains a list of results in that block ustr : list of block to be assigned, each contains a list of results names to data in that block cache : list cache corresponding to each block # Quaycle.vtm_output \u2014 Method . 1 vtm_output ( f , t , u , ustr , cache :: ParaviewOutputCache ) Write results to multiple-block paraview collection file. Arguments f : output file name t::AbstractVector : time stamp vector u , list of different block data to be written, each contains a list of results in that block ustr : list of block names to be assigned, each contains a list of results names to data in that block cache : list cache corresponding to each block","title":"Visualize"},{"location":"interface_visualize/#visualize","text":"This package provides some utilities for writing results to VTK (vts, vti, vtu, vtm, pvd, etc...) file for postprocessing with Paraview . Data cache for writing results are also implemented where users could explore other meshing tools. One short note is that if you store 6 components vector, for example \u03c3 \u03c3 , Paraview will interpret them in the order of \u03c3_{xx} \u03c3_{xx} , \u03c3_{yy} \u03c3_{yy} , \u03c3_{zz} \u03c3_{zz} , \u03c3_{xy} \u03c3_{xy} , \u03c3_{yz} \u03c3_{yz} , \u03c3_{xz} \u03c3_{xz} . Whereas in our assemble for stress, the order, same as e.g OpenFOAM, is \u03c3_{xx} \u03c3_{xx} , \u03c3_{xy} \u03c3_{xy} , \u03c3_{xz} \u03c3_{xz} , \u03c3_{yy} \u03c3_{yy} , \u03c3_{yz} \u03c3_{yz} , \u03c3_{zz} \u03c3_{zz} . Notice that these function are not fully tested. If you encounter any problem, please file an issue with your MWE.","title":"Visualize"},{"location":"interface_visualize/#public-interface","text":"# Quaycle.vtk_output \u2014 Method . 1 2 vtk_output ( f , t :: AbstractVector , u :: AbstractVector { <: AbstractVecOrMat }, ustr :: AbstractVector { <: AbstractString }, cache :: ParaviewOutputCache ) Write time-series results to single-block paraview collection file. Arguments f : output file name t::AbstractVector : time stamp vector u::AbstractVector{<:AbstractArray} , list of results to be written ustr::AbstractVector{<:AbstractString} : list results names to be assigned cache : cache of data conversion, cell information and nodes information # Quaycle.vtk_output \u2014 Method . 1 2 vtk_output ( f , u :: AbstractVector { <: AbstractVecOrMat }, ustr :: AbstractVector { <: AbstractString }, cache :: ParaviewOutputCache ) Write results to single-block VTU file. Arguments f : output file name u::AbstractVector , list of results to be written ustr::AbstractVector{<:AbstractString} : list results names to be assigned cache : cache of data conversion, cell information and nodes information # Quaycle.vtk_output \u2014 Method . 1 vtk_output ( f , p :: AbstractProperty , cache :: ParaviewOutputCache ) Store simulation property, including all its fields, to VTU file. Arguments f : output file name p : property struct cache : cache of data conversion, cell information and nodes information Notice Not all AbstractProperty are supported. Only those with well defined fieldnames are. For multi-block domain property, save them separately. # Quaycle.vtm_output \u2014 Method . 1 vtm_output ( f , u , ustr , cache :: ParaviewOutputCache ) Write results to multiple-block VTM file. Arguments f : output file name u , list of block to be written, each contains a list of results in that block ustr : list of block to be assigned, each contains a list of results names to data in that block cache : list cache corresponding to each block # Quaycle.vtm_output \u2014 Method . 1 vtm_output ( f , t , u , ustr , cache :: ParaviewOutputCache ) Write results to multiple-block paraview collection file. Arguments f : output file name t::AbstractVector : time stamp vector u , list of different block data to be written, each contains a list of results in that block ustr : list of block names to be assigned, each contains a list of results names to data in that block cache : list cache corresponding to each block","title":"Public Interface"},{"location":"examples/generated/bp1/","text":"Note This example is from Benchmark Problem 1 (hence referred as BP1). First, we load the package 1 2 using Quaycle using Plots The prerequisite parameters in this benchmark are list below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ms2mmyr = 365 * 86400 * 1e3 # convert velocity from m/s to mm/yr \u03c1 = 2670.0 # density [kg/m\u00b3] vs = 3464.0 # shear wave velocity [m/s] \u03c30 = 500.0 # effective normal stress [bar] a0 = 0.010 # frictional paramter `a` in vw zone amax = 0.025 # frictional paramter `a` in vs zone b0 = 0.015 # frictional paramter `b` L0 = 8.0 # critical distance [mm] vpl = 1e-9 * ms2mmyr # plate rate [mm/yr] vinit = 1e-9 * ms2mmyr # initial velocity [mm/yr] v0 = 1e-6 * ms2mmyr # reference velocity [mm/yr] f0 = 0.6 # reference frictional coefficient H = 15.0 # vw zone [km] h = 3.0 # vw-vs changing zone [km] Wf = 40.0 # fault depth [km] \u0394z = 100.0e-3 # grid size interval [km] tf = 200.0 ; nothing # simulation time [yr] Warning Make sure your units are consistent across the whole variable space. Then we arrive at some parameters that are implicit by above: 1 2 3 4 \u03bc = vs ^ 2 * \u03c1 / 1e5 / 1e6 # shear modulus [bar\u00b7km/mm] \u03bb = \u03bc # poisson material \u03b7 = \u03bc / 2 ( vs * 1e-3 * 365 * 86400 ) ngrid = round ( Int , Wf / \u0394z ); nothing # number of grids First, set up a fault type which is strike-slip, and create a fault mesh by specifying depth and the desired discretization interval. 1 2 ft = STRIKING () mesh = gen_mesh ( Val ( : LineOkada ), 40.0 , \u0394z , 90.0 ); nothing Computing the Green's function for this setting. 1 gf = stress_greens_func ( mesh , \u03bb , \u03bc , ft ); nothing Then, provide the material properties w.r.t. our 'fault space'. 1 2 3 4 5 6 7 a = a0 .* ones ( mesh . n\u03be ) a [ - mesh . z .\u2265 ( H + h )] .= amax a [ H .< - mesh . z .< H + h ] .= a0 .+ ( amax - a0 ) / ( h / \u0394z ) * collect ( 1 : Int ( h / \u0394z )) b = b0 .* ones ( mesh . n\u03be ) L = L0 .* ones ( mesh . n\u03be ) \u03c3 = \u03c30 .* ones ( mesh . n\u03be ) prop = RateStateQuasiDynamicProperty ( a = a , b = b , L = L , \u03c3 = \u03c3 , vpl = vpl , f0 = f0 , v0 = v0 , \u03b7 = \u03b7 ); nothing Next, construct the initial condition and ODE problem using Okada's Green's function. 1 2 3 4 5 6 \u03c40 = \u03c30 * amax * asinh ( vinit / 2 v0 * exp (( f0 + b0 * log ( v0 / vinit )) / amax )) + \u03b7 * vinit \u03c4z = fill ( \u03c40 , size ( mesh . z )) \u03b8z = @ . L / v0 * exp ( a / b0 * log ( 2 v0 / vinit * sinh (( \u03c4z - \u03b7 * vinit ) / a / \u03c3 )) - f0 / b0 ) vz = fill ( vinit , size ( mesh . \u03be )) u0 = ArrayPartition ( vz , \u03b8z ) prob = assemble ( gf , prop , u0 , ( 0.0 , tf )); nothing Check our depth profile now. 1 plot ( a .- b , mesh . z , label = \"a - b\" , yflip = true , ylabel = \"Depth (km)\" ) -0.003 0.000 0.003 0.006 0.009 -40 -30 -20 -10 0 Depth (km) a - b Afterwards, solve ODE thanks to DifferentialEquations.jl 1 sol = solve ( prob , TsitPap8 (), reltol = 1e-6 , abstol = 1e-6 ); nothing Tip Raise the accuracy option or switch to other algorithms if you get instability when solving these ODEs. Finally, check the results. The first event happens at around 196 year: 1 2 maxv = max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , xlims = ( 190 , 200 ), label = \"\" ) 190.0 192.5 195.0 197.5 200.0 -8 -6 -4 -2 0 Time (year) Max Velocity (log10 (m/s)) Note Click here for the slip evolution over 3000 years simulation. It may need some time to load the page. This page was generated using Literate.jl .","title":"Example 1D"},{"location":"examples/generated/otfsync/","text":"Note This example is adapted from Wei, 2016 AGU Tip It will automatically use parallel scheme if nprocs() \u2242\u0338 1 when building stiffness tensor. To do so: 1 2 3 using Distributed addprocs ( 4 ); # add # of cores you desire @everywhere using Quaycle First, list all the essential parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 using Quaycle using Plots ms2mmyr = 365 * 86400 * 1e3 \u03c1 = 2670.0 # kg/m\u00b3 cs = 3044.0 # m/s vpl = 100.0 # mm/yr v0 = 3.2e4 # mm/yr f0 = 0.6 ; \u03bc = 0.3 # Bar\u00b7km/mm \u03bb = \u03bc # poisson material \u03b1 = ( \u03bb + \u03bc ) / ( \u03bb + 2 \u03bc ) \u03b7 = \u03bc / 2 ( cs * 1e-3 * 365 * 86400 ); nothing # Bar\u00b7yr/mm First, create a fault mesh, specify fault type and compute the Green's function. 1 2 3 ft = STRIKING () mesh = gen_mesh ( Val ( : RectOkada ), 80. , 10. , 0.5 , 0.5 , 90.0 ) gf = stress_greens_func ( mesh , \u03bb , \u03bc , ft ; buffer_ratio = 1 ); nothing Tip It is recommended (from Yajing Liu's personal communication) to add buffer zones adjacent the horizontal edges to immitate zero dislocation at the ridge region. Basically, it affects how the stiffness tensor are periodically summed. To what extent it alters the results remains further testing. Under the hood, it shall impose buffer areas on both sides of along-strike, each of which has a length of bufferratio/2*fa[:x] . Thus, the stiffness contributions falling into those buffer zone shall be neglected, which is equivalent to impose zero-slip correspondingly. Next, establish frictional and fault space parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 a = ones ( mesh . nx , mesh . n\u03be ) .* 0.015 b = ones ( mesh . nx , mesh . n\u03be ) .* 0.0115 L = ones ( mesh . nx , mesh . n\u03be ) .* 12.0 left_patch = @ . - 25. \u2264 mesh . x \u2264 - 5. right_patch = @ . 5. \u2264 mesh . x \u2264 25. vert_patch = @ . - 6. \u2264 mesh . z \u2264 - 1 b [ xor . ( left_patch , right_patch ), vert_patch ] .= 0.0185 \u03c3max = 500. \u03c3 = [ min ( \u03c3max , 15. + 180. * z ) for z in - mesh . z ] \u03c3 = Matrix ( repeat ( \u03c3 , 1 , mesh . nx ) ' ) prop = RateStateQuasiDynamicProperty ( a = a , b = b , L = L , \u03c3 = \u03c3 , vpl = vpl , f0 = f0 , v0 = v0 , \u03b7 = \u03b7 ); nothing Make sure our profile match our expectation: 1 2 3 4 5 6 7 8 9 10 11 12 13 p1 = plot (( a .- b ) ' , seriestype =: heatmap , xticks = ( collect ( 1 : 40 : mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"a-b\" , ); p2 = heatmap ( \u03c3 ' , xticks = ( collect ( 1 : 40 : mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \" \\\\ sigma\" ); plot ( p1 , p2 , layout = ( 2 , 1 )) -40 -20 0 20 40 0 5 10 15 20 a-b - 0.003 - 0.002 - 0.001 0 0.001 0.002 0.003 -40 -20 0 20 40 0 5 10 15 20 \u03c3 100 150 200 250 300 350 400 450 500 Then, provide the initial condition and assemble the ODEs: 1 2 3 4 vinit = vpl .* ones ( mesh . nx , mesh . n\u03be ) \u03b80 = L ./ vinit ./ 1.1 u0 = ArrayPartition ( vinit , \u03b80 ) prob = assemble ( gf , prop , u0 , ( 0. , 18. )); nothing Afterwards, solve ODEs problem: 1 sol = solve ( prob , VCABM5 (), reltol = 1e-5 , abstol = 1e-3 ); nothing Last, take a look at the max velocity time series: ```@example otfsync maxv = JuEQ.max_velocity(sol) plot(sol.t, log10.(maxv / ms2mmyr), xlabel=\"Time (year)\", ylabel=\"Max Velocity (log10 (m/s))\", label=\"\") 1 2 3 4 5 6 7 8 9 10 11 And view some snapshots of ruptures (quasi-dynamic) patterns: ```@example otfsync ind = argmax(maxv) myplot = (ind) -> heatmap(log10.(sol.u[ind].x[1]./ms2mmyr)', xticks=(collect(1: 40: mesh.nx+1), [-40, -20, 0, 20, 40]), yticks=(collect(1: 5: mesh.n\u03be+1), [0, 5, 10, 15, 20]), yflip=true, color=:isolum, aspect_ratio=2, title=\"t = $(sol.t[ind])\") snaps = myplot(ind+300) plot(snaps) Example An equivalent simulation using triangular dislocation Green's function is shown below. Notice it's far less performant than using rectangular disloction above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 using Distributed addprocs ( 4 ) @everywhere using JuEQ using GmshTools using HDF5 using Plots ## generate mesh fname = \"temp.msh\" @gmsh_do begin reg = JuEQ . geo_rect_x ( - 40e3 , 0.0 , - 10e3 , 80e3 , 0.0 , 10e3 , 1 ) gmsh . model . addPhysicalGroup ( 2 , [ reg - 1 ], 99 ) gmsh . model . setPhysicalName ( 2 , 99 , \"FAULT\" ) @addOption begin \"Mesh.CharacteristicLengthMax\" , 500.0 \"Mesh.CharacteristicLengthMin\" , 500.0 end gmsh . model . geo . synchronize () gmsh . model . mesh . generate ( 2 ) gmsh . write ( fname ) end m = read_gmsh_mesh ( Val ( : TDTri3 ), fname ; phytag = 99 ) ## system parameters \u03bb , \u03bc = 3e10 , 3e10 ft = STRIKING () f0 = 0.6 v0 = 1e-6 vpl = 3.17e-9 cs = 3044.0 \u03b7 = \u03bc / 2 cs a = ones ( size ( m . tag )) * 0.015 b = ones ( size ( m . tag )) * 0.0115 L = ones ( size ( m . tag )) * 12e-3 left_patch = @ . - 25e3 \u2264 m . x \u2264 - 5e3 right_patch = @ . 5e3 \u2264 m . x \u2264 25e3 vert_patch = @ . - 6e3 \u2264 m . z \u2264 - 1e3 b [( left_patch .| right_patch ) .& vert_patch ] .= 0.0185 \u03c3max = 5e7 \u03c3 = map ( z -> min ( \u03c3max , 1.5e6 + 18e3 * - z ), m . z ) ## visual check cache = gmsh_vtk_output_cache ( fname , 2 , 99 ) vtk_output ( \"tdp\" , [ a - b , \u03c3 ], [ \"a-b\" , \"\u03c3\" ], cache ) ## compute Green's function gf = stress_greens_func ( m , \u03bb , \u03bc , ft ) h5write ( \"tdgf.h5\" , \"gf\" , gf ) gf = h5read ( \"tdgf.h5\" , \"gf\" ) ## assemble prob p = RateStateQuasiDynamicProperty ( a , b , L , \u03c3 , \u03b7 , vpl , f0 , v0 ) vinit = ones ( size ( m . tag )) * vpl \u03b8init = L ./ vinit ./ 1.1 uinit = ArrayPartition ( vinit , \u03b8init ) prob = assemble ( gf , p , uinit , ( 0. , 18. * 365 * 86400 )) sol = wsolve ( prob , VCABM3 (), \"temp.h5\" , 500 , \ud835\udc15\ud835\udeaf , [ \"v\" , \"\u03b8\" ], \"t\" ; rtol = 1e-6 , atol = 1e-6 ) ## results t = h5read ( \"temp.h5\" , \"t\" ) v = h5read ( \"temp.h5\" , \"v\" ) maxv = dropdims ( mapslices ( maximum , v , dims = [ 1 ]); dims = 1 ) plot ( t / 365 / 86400 , log10 . ( maxv ), markershape =: circle , markersize = 0.2 ) This page was generated using Literate.jl .","title":"Example 2D"}]}