{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JuEQ.jl Documentation \u00b6 Overview \u00b6 This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Plastic Deformation Boundary Element Method (Quasi-dynamic) Viscoelastic Relaxation Integration with Gmsh and Paraview Features to be implemented: Fully elastodynamics Finite element method via Fenics Installation \u00b6 Get the latest version with Julia's package manager: 1 ( v1 . 1 ) pkg > add https :// github . com / shipengcheng1230 / JuEQ . jl To load the package: 1 using JuEQ","title":"Home"},{"location":"#jueqjl-documentation","text":"","title":"JuEQ.jl Documentation"},{"location":"#overview","text":"This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Plastic Deformation Boundary Element Method (Quasi-dynamic) Viscoelastic Relaxation Integration with Gmsh and Paraview Features to be implemented: Fully elastodynamics Finite element method via Fenics","title":"Overview"},{"location":"#installation","text":"Get the latest version with Julia's package manager: 1 ( v1 . 1 ) pkg > add https :// github . com / shipengcheng1230 / JuEQ . jl To load the package: 1 using JuEQ","title":"Installation"},{"location":"LICENSE/","text":"MIT License Copyright \u00a9 2018-2019 Shi Pengcheng Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"acknowledge/","text":"Acknowledge \u00b6 The simulation of episodic seismic and slow slip events using boundary-element-method for pure elastic fault is largely benefit from Yajing Liu original Fortran code. This package isn't possible without a collaborating Julia community. Thanks to all the authors in the dependent packages .","title":"Acknowledge"},{"location":"acknowledge/#acknowledge","text":"The simulation of episodic seismic and slow slip events using boundary-element-method for pure elastic fault is largely benefit from Yajing Liu original Fortran code. This package isn't possible without a collaborating Julia community. Thanks to all the authors in the dependent packages .","title":"Acknowledge"},{"location":"interface_HDF5/","text":"HDF5 Utilities \u00b6 To use HDF5 functionality, 1 2 3 4 pkg > add HDF5 julia > using JuEQ julia > using HDF5 This package provides a bunch of utilities, such as storing simulation properties and writing ODE solution on the fly to HDF5 format file for postprocessing on different platform and package version. We currently don't support automatically saving green's function to HDF5 due to its limitation of natively storing complex number. It's worth mention that JLD and JLD2 are also excellent alternatives but they storing the whole type information that may broke read when this package changes or remove certain type definitions. Users may choose them as auxiliary tools. Public Interface \u00b6 # JuEQ.store \u2014 Method . 1 store ( filename :: AbstractString , p :: AbstractProperty ) Store property in HDF5. Arguments filename::AbstractString : file name to be used p::AbstractProperty : property to be saved # JuEQ.@getprop \u2014 Macro . 1 @getprop filename Read property stored in HDF5. Arguments filename : file name. Assume it has one and only one kind of property group. # JuEQ.@store \u2014 Macro . 1 @store filename :: AbstractString p :: AbstractProperty Macro shortcut for storing property in HDF5. Arguments filename::AbstractString : file name to be used p::AbstractProperty : property to be saved # JuEQ.wsolve \u2014 Method . 1 2 wsolve ( prob :: ODEProblem , alg :: OrdinaryDiffEqAlgorithm , file , nstep , getu , ustrs , tstr ; kwargs ... ) Write the solution to HDF5 file while solving the ODE. The interface is exactly the same as solve an ODEProblem except a few more about the saving procedure. Notice, it will set save_everystep=false so to avoid memory blow up. The return code will be written as an attribute in tstr data group. Extra Arguments file::AbstractString : name of file to be saved nstep::Integer : number of steps after which a saving operation will be performed getu::Function : function handler to extract desired solution for saving ustr::AbstractVector : list of names to be assigned for each components, whose length must equal the length of getu output tstr::AbstractString : name of time data # JuEQ.\ud835\udc15\ud835\udeaf \u2014 Method . Retrieve velocity and state . # JuEQ.\ud835\udc15\ud835\udeaf\ud835\udc04\u2032 \u2014 Method . Retrieve velocity , state and strain rate . # JuEQ.\ud835\udc15\ud835\udeaf\ud835\udeac \u2014 Method . Retrieve velocity , state and strain . # JuEQ.\ud835\udc15\ud835\udeaf\ud835\udeac\ud835\udeba \u2014 Method . Retrieve velocity , state , strain and stress . # JuEQ.@h5savecallback \u2014 Macro . 1 @h5savecallback ( filename , tend , nsteps , usize , T ) Construct a FunctionCallingCallback for incrementally stored output into HDF5 file. This callback function only works for naive output arrays whose shape look like A[..., :, :, :, ...] . It is suggested to use this macro at top-level scope since it contains eval . Arguments filename : file name to be stored tend : end time of simulation nsteps : after nsteps steps, a saving operation is performed otherwise caching them T : type of stored data","title":"HDF5 Utility"},{"location":"interface_HDF5/#hdf5-utilities","text":"To use HDF5 functionality, 1 2 3 4 pkg > add HDF5 julia > using JuEQ julia > using HDF5 This package provides a bunch of utilities, such as storing simulation properties and writing ODE solution on the fly to HDF5 format file for postprocessing on different platform and package version. We currently don't support automatically saving green's function to HDF5 due to its limitation of natively storing complex number. It's worth mention that JLD and JLD2 are also excellent alternatives but they storing the whole type information that may broke read when this package changes or remove certain type definitions. Users may choose them as auxiliary tools.","title":"HDF5 Utilities"},{"location":"interface_HDF5/#public-interface","text":"# JuEQ.store \u2014 Method . 1 store ( filename :: AbstractString , p :: AbstractProperty ) Store property in HDF5. Arguments filename::AbstractString : file name to be used p::AbstractProperty : property to be saved # JuEQ.@getprop \u2014 Macro . 1 @getprop filename Read property stored in HDF5. Arguments filename : file name. Assume it has one and only one kind of property group. # JuEQ.@store \u2014 Macro . 1 @store filename :: AbstractString p :: AbstractProperty Macro shortcut for storing property in HDF5. Arguments filename::AbstractString : file name to be used p::AbstractProperty : property to be saved # JuEQ.wsolve \u2014 Method . 1 2 wsolve ( prob :: ODEProblem , alg :: OrdinaryDiffEqAlgorithm , file , nstep , getu , ustrs , tstr ; kwargs ... ) Write the solution to HDF5 file while solving the ODE. The interface is exactly the same as solve an ODEProblem except a few more about the saving procedure. Notice, it will set save_everystep=false so to avoid memory blow up. The return code will be written as an attribute in tstr data group. Extra Arguments file::AbstractString : name of file to be saved nstep::Integer : number of steps after which a saving operation will be performed getu::Function : function handler to extract desired solution for saving ustr::AbstractVector : list of names to be assigned for each components, whose length must equal the length of getu output tstr::AbstractString : name of time data # JuEQ.\ud835\udc15\ud835\udeaf \u2014 Method . Retrieve velocity and state . # JuEQ.\ud835\udc15\ud835\udeaf\ud835\udc04\u2032 \u2014 Method . Retrieve velocity , state and strain rate . # JuEQ.\ud835\udc15\ud835\udeaf\ud835\udeac \u2014 Method . Retrieve velocity , state and strain . # JuEQ.\ud835\udc15\ud835\udeaf\ud835\udeac\ud835\udeba \u2014 Method . Retrieve velocity , state , strain and stress . # JuEQ.@h5savecallback \u2014 Macro . 1 @h5savecallback ( filename , tend , nsteps , usize , T ) Construct a FunctionCallingCallback for incrementally stored output into HDF5 file. This callback function only works for naive output arrays whose shape look like A[..., :, :, :, ...] . It is suggested to use this macro at top-level scope since it contains eval . Arguments filename : file name to be stored tend : end time of simulation nsteps : after nsteps steps, a saving operation is performed otherwise caching them T : type of stored data","title":"Public Interface"},{"location":"interface_assemble/","text":"Assemble \u00b6 The assemble function aims to provide an ODEProblem encapsulating all the necessary information for modeling earthquake cycles. It will automatically generate caches based on given mesh sizes aiming to minimize allocation during solving. The full functionality of ODEProblem as well as solving interface can be viewed at documents of DifferentialEquations.jl . Also, please checkout RecursiveArrayTools.jl for usage of ArrayPartition which is adopted by default for multiple variables in this package. Public Interface \u00b6 # JuEQ.assemble \u2014 Method . 1 2 3 assemble ( mf :: AbstractMesh , gf :: AbstractArray , p :: ElasticRSFProperty , u0 :: AbstractArray , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (), kwargs ... ) Assemble the ODEProblem for elastic fault. Extra Arguments mf::AbstractMesh : fault mesh, currently only support OkadaMesh gf::AbstractArray : green's function associated with fs.mesh and p.\u03bb & p.\u03bc p::ElasticRSFProperty : all system properties u0::ArrayPartition : initial condition. By rule of order in this package: velocity state tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # JuEQ.assemble \u2014 Method . 1 2 3 assemble ( fas :: LithAsthSpace , gf :: ViscoelasticCompositeGreensFunction , p :: ViscoelasticMaxwellProperty , u0 :: ArrayPartition , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (),) Assemble the ODEProblem for elastic fault plus viscoelastic relaxation. Arguments fas::LithAsthSpace : containing fault mesh, fault type and asthenosphere mesh gf::ViscoelasticCompositeGreensFunction : green's function associated with the composite space fas p::ViscoelasticCompositeGreensFunction : all system properties u0::ArrayPartition : initial condition. By rule of order in this package: velocity state strain stress tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # JuEQ.assemble \u2014 Method . 1 2 assemble ( p :: SingleDofRSFProperty , u0 :: AbstractArray , tspan :: NTuple ; flf :: FrictionLawForm = CForm (), se :: StateEvolutionLaw = DieterichStateLaw ()) Assemble the ODEProblem for single degree of freedom system. Arguments p::SingleDofRSFProperty : all system properties u0::AbstractArray : initial condition tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw References \u00b6 Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., McGuire, J. J., & Behn, M. D. (2012). Frictional behavior of oceanic transform faults and its influence on earthquake characteristics. Journal of Geophysical Research: Solid Earth, 117(B4). https://doi.org/10.1029/2011JB009025 Barbot, S. (2018). Asthenosphere Flow Modulated by Megathrust Earthquake Cycles. Geophysical Research Letters, 45(12), 6018\u20136031. https://doi.org/10.1029/2018GL078197","title":"Assemble"},{"location":"interface_assemble/#assemble","text":"The assemble function aims to provide an ODEProblem encapsulating all the necessary information for modeling earthquake cycles. It will automatically generate caches based on given mesh sizes aiming to minimize allocation during solving. The full functionality of ODEProblem as well as solving interface can be viewed at documents of DifferentialEquations.jl . Also, please checkout RecursiveArrayTools.jl for usage of ArrayPartition which is adopted by default for multiple variables in this package.","title":"Assemble"},{"location":"interface_assemble/#public-interface","text":"# JuEQ.assemble \u2014 Method . 1 2 3 assemble ( mf :: AbstractMesh , gf :: AbstractArray , p :: ElasticRSFProperty , u0 :: AbstractArray , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (), kwargs ... ) Assemble the ODEProblem for elastic fault. Extra Arguments mf::AbstractMesh : fault mesh, currently only support OkadaMesh gf::AbstractArray : green's function associated with fs.mesh and p.\u03bb & p.\u03bc p::ElasticRSFProperty : all system properties u0::ArrayPartition : initial condition. By rule of order in this package: velocity state tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # JuEQ.assemble \u2014 Method . 1 2 3 assemble ( fas :: LithAsthSpace , gf :: ViscoelasticCompositeGreensFunction , p :: ViscoelasticMaxwellProperty , u0 :: ArrayPartition , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (),) Assemble the ODEProblem for elastic fault plus viscoelastic relaxation. Arguments fas::LithAsthSpace : containing fault mesh, fault type and asthenosphere mesh gf::ViscoelasticCompositeGreensFunction : green's function associated with the composite space fas p::ViscoelasticCompositeGreensFunction : all system properties u0::ArrayPartition : initial condition. By rule of order in this package: velocity state strain stress tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # JuEQ.assemble \u2014 Method . 1 2 assemble ( p :: SingleDofRSFProperty , u0 :: AbstractArray , tspan :: NTuple ; flf :: FrictionLawForm = CForm (), se :: StateEvolutionLaw = DieterichStateLaw ()) Assemble the ODEProblem for single degree of freedom system. Arguments p::SingleDofRSFProperty : all system properties u0::AbstractArray : initial condition tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw","title":"Public Interface"},{"location":"interface_assemble/#references","text":"Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., McGuire, J. J., & Behn, M. D. (2012). Frictional behavior of oceanic transform faults and its influence on earthquake characteristics. Journal of Geophysical Research: Solid Earth, 117(B4). https://doi.org/10.1029/2011JB009025 Barbot, S. (2018). Asthenosphere Flow Modulated by Megathrust Earthquake Cycles. Geophysical Research Letters, 45(12), 6018\u20136031. https://doi.org/10.1029/2018GL078197","title":"References"},{"location":"interface_friction/","text":"Friction \u00b6 This package adopts what is called rate-and-state friction as one of the essential components for modeling fault dynamics. Currently, we only support single state variable \u03b8 \u03b8 . Public Interface \u00b6 # JuEQ.CForm \u2014 Type . Conventional form, see friction # JuEQ.DieterichStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} # JuEQ.PrzStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\left(\\frac{V \u03b8}{2L}\\right)^2 \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\left(\\frac{V \u03b8}{2L}\\right)^2 # JuEQ.RForm \u2014 Type . Regularized form, see friction # JuEQ.RuinaStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\left(\\frac{V \u03b8}{L}\\right)} \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\left(\\frac{V \u03b8}{L}\\right)} # JuEQ.StateEvolutionLaw \u2014 Type . Currently support: DieterichStateLaw RuinaStateLaw PrzStateLaw # JuEQ.friction \u2014 Method . 1 friction ( :: FrictionLawForm , v :: T , \u03b8 :: T , L :: T , a :: T , b :: T , f0 :: T , v0 :: T ) where { T <: Number } Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\left(\\frac{V}{V_0}\\right)} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} f(V, \u03b8) = f_0 + a \\ln{\\left(\\frac{V}{V_0}\\right)} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left(\\frac{V}{2V_0} \\exp{\\left(\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}\\right)}\\right)} f(V, \u03b8) = a \\sinh ^{-1}{\\left(\\frac{V}{2V_0} \\exp{\\left(\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}\\right)}\\right)} References \u00b6 Dieterich, J. (1979). Modeling of rock friction: 1. Experimental results and constitutive equations. Journal of Geophysical Research: Solid Earth, 84(B5), 2161\u20132168. https://doi.org/10.1029/JB084iB05p02161 Ruina, A. (1983). Slip instability and state variable friction laws. Journal of Geophysical Research: Solid Earth, 88(B12), 10359\u201310370. https://doi.org/10.1029/JB088iB12p10359 Rubin, A. M., & Ampuero, J.-P. (2005). Earthquake nucleation on (aging) rate and state faults. Journal of Geophysical Research: Solid Earth, 110(B11). https://doi.org/10.1029/2005JB003686","title":"Friction"},{"location":"interface_friction/#friction","text":"This package adopts what is called rate-and-state friction as one of the essential components for modeling fault dynamics. Currently, we only support single state variable \u03b8 \u03b8 .","title":"Friction"},{"location":"interface_friction/#public-interface","text":"# JuEQ.CForm \u2014 Type . Conventional form, see friction # JuEQ.DieterichStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} # JuEQ.PrzStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\left(\\frac{V \u03b8}{2L}\\right)^2 \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\left(\\frac{V \u03b8}{2L}\\right)^2 # JuEQ.RForm \u2014 Type . Regularized form, see friction # JuEQ.RuinaStateLaw \u2014 Type . \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\left(\\frac{V \u03b8}{L}\\right)} \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\left(\\frac{V \u03b8}{L}\\right)} # JuEQ.StateEvolutionLaw \u2014 Type . Currently support: DieterichStateLaw RuinaStateLaw PrzStateLaw # JuEQ.friction \u2014 Method . 1 friction ( :: FrictionLawForm , v :: T , \u03b8 :: T , L :: T , a :: T , b :: T , f0 :: T , v0 :: T ) where { T <: Number } Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\left(\\frac{V}{V_0}\\right)} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} f(V, \u03b8) = f_0 + a \\ln{\\left(\\frac{V}{V_0}\\right)} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left(\\frac{V}{2V_0} \\exp{\\left(\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}\\right)}\\right)} f(V, \u03b8) = a \\sinh ^{-1}{\\left(\\frac{V}{2V_0} \\exp{\\left(\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}\\right)}\\right)}","title":"Public Interface"},{"location":"interface_friction/#references","text":"Dieterich, J. (1979). Modeling of rock friction: 1. Experimental results and constitutive equations. Journal of Geophysical Research: Solid Earth, 84(B5), 2161\u20132168. https://doi.org/10.1029/JB084iB05p02161 Ruina, A. (1983). Slip instability and state variable friction laws. Journal of Geophysical Research: Solid Earth, 88(B12), 10359\u201310370. https://doi.org/10.1029/JB088iB12p10359 Rubin, A. M., & Ampuero, J.-P. (2005). Earthquake nucleation on (aging) rate and state faults. Journal of Geophysical Research: Solid Earth, 110(B11). https://doi.org/10.1029/2005JB003686","title":"References"},{"location":"interface_greensfun/","text":"Green's Function \u00b6 The interactions among fault patches, asthenosphere elements as well as between fault and asthenosphere are computed via convolution of Green's Function. Currently supported Green's Function: 1D elastic line dislocation 2D elastic rectangular dislocation 3D inelastic strain in Hex8 or Tet4 elements Other types, such as 2D inelastic (plane stress or antiplane stress), curved dislocation, are WIP. Also notice that coordinate system in dc3d is different from sbarbot_disp_hex8 , sbarbot_disp_tet4 or their auxiliary stress/strain computing function. Public Interface \u00b6 # JuEQ.cat_greensfun \u2014 Method . 1 cat_greensfun ( ee :: AbstractArray , ev :: NTuple , ve :: NTuple , vv :: NTuple ) Concatenate tuple of matrix or tuple of tuple of matrix which arrange them in a way to update traction/stress rate using only one BLAS call. It does nothing to the elastic Green's function and specifically used for the outputs from okada_stress_gf_tensor and sbarbot_stress_gf_tensor . Arguments ee : traction Green's function within the elastic fault ev : stress Green's function from elastic fault to inelastic asthenosphere ve : traction Green's function inelastic asthenosphere to elastic fault vv : stress Green's function within inelastic asthenosphere # JuEQ.okada_stress_gf_tensor \u2014 Method . 1 2 okada_stress_gf_tensor ( mf :: RectOkadaMesh , ma :: SBarbotMeshEntity { 3 }, \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; kwargs ... ) where { T <: Real , I <: Integer } Compute stress Green's function from RectOkadaMesh to SBarbotTet4MeshEntity or SBarbotHex8MeshEntity Arguments mf::RectOkadaMesh : mesh of fault ma::SBarbotMeshEntity{3} : mesh of asthenosphere \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() Output The output is a tuple of 6 matrix, each corresponds \u03c3_{xx} \u03c3_{xx} , \u03c3_{xy} \u03c3_{xy} , \u03c3_{xz} \u03c3_{xz} , \u03c3_{yy} \u03c3_{yy} , \u03c3_{yz} \u03c3_{yz} , \u03c3_{zz} \u03c3_{zz} # JuEQ.okada_stress_gf_tensor \u2014 Method . 1 okada_stress_gf_tensor ( mesh :: LineOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; kwargs ... ) where T Compute traction Green function in 1-D elastic fault in LineOkadaMesh . Arguments mesh::LineOkadaMesh : the line mesh coupled with dc3d \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments ax_ratio::Real : ratio of along-strike to along-downdip, default is 12.5 # JuEQ.okada_stress_gf_tensor \u2014 Method . 1 2 okada_stress_gf_tensor ( mesh :: RectOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; fourier_domain = true , kwargs ... ) where T Compute traction Green's function in 2-D elastic fault in RectOkadaMesh . Translational symmetry is considered. Arguments mesh::RectOkadaMesh : the line mesh coupled with dc3d \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments fourier_domain::Bool : whether or not transform the tensor to fourier domain nrept::Integer : number of periodic summation is performed buffer_ratio::Real : ratio of length of buffer zone (along-strike) to that of fault (along-strike) It is recommended to set at least 1 for strike-slip fault for mimicing zero-dislocation at ridge on both sides. # JuEQ.sbarbot_stress_gf_tensor \u2014 Method . 1 2 sbarbot_stress_gf_tensor ( ma :: SBarbotMeshEntity { 3 }, mf :: RectOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: PlaneFault , comp :: NTuple { N , Symbol }; kwargs ... ) where { T , N } Compute traction Green's function from SBarbotTet4MeshEntity or SBarbotHex8MeshEntity to RectOkadaMesh Arguments ma::SBarbotMeshEntity{3} : asthenosphere mesh mf::RectOkadaMesh : fault mesh \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() comp : the strain component(s) to be considered. Either a singleton of :xx , :xy , :xz , :yy , :yz , :zz or tuple of a few ones Output A tuple of n n matrix, each represents interaction from one strain to the traction on fault # JuEQ.sbarbot_stress_gf_tensor \u2014 Method . 1 2 sbarbot_stress_gf_tensor ( ma :: SBarbotMeshEntity { 3 }, \u03bb :: T , \u03bc :: T , comp :: NTuple { N , Symbol }; kwargs ... ) where { T , N } Compute stress Green's function within SBarbotTet4MeshEntity or SBarbotHex8MeshEntity Arguments ma::SBarbotMeshEntity{3} : asthenosphere mesh \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus comp : the strain component(s) to be considered. Either a singleton of :xx , :xy , :xz , :yy , :yz , :zz or tuple of a few ones Output A tuple of n n tuple of matrix, each tuple represents interaction from one strain to the stress components, each of which is a matrix, within asthenosphere # JuEQ.dc3d \u2014 Method . 1 2 3 dc3d ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al :: Union { A , SubArray }, aw :: Union { A , SubArray }, disl :: A ) where { T <: Number , A <: AbstractVecOrMat { T }} Calculate displacements and gradient of displacements due to a rectangular dislocation in an elastic isotropic halfspace. Please see dc3d for details. Also this fault coordinate system is widely used in this package. Arguments x , y , z : observational position \u03b1 : elastic constant dep : depth of fault origin dip : dip angle in degree al : a vector of 2 numbers, indicating along strike (x-axis) spanning aw : a vector of 2 numbers, indicating along downdip (y-z plane) spanning disl : a vector of 3 numbers, indicating dislocation in along-strike, along-downdip and tensile respectively. Output A vector of 12 numbers, each is u_{x} u_{x} , u_{y} u_{y} , u_{z} u_{z} , u_{x,x} u_{x,x} , u_{y,x} u_{y,x} , u_{z,x} u_{z,x} , u_{x,y} u_{x,y} , u_{y,y} u_{y,y} , u_{z,y} u_{z,y} , u_{x,z} u_{x,z} u_{y,z} u_{y,z} , u_{z,z} u_{z,z} . # JuEQ.sbarbot_disp_hex8 \u2014 Method . 1 2 3 4 5 6 sbarbot_disp_hex8 ( x1 :: R , x2 :: R , x3 :: R , q1 :: R , q2 :: R , q3 :: R , L :: R , T :: R , W :: R , theta :: R , epsv11p :: R , epsv12p :: R , epsv13p :: R , epsv22p :: R , epsv23p :: R , epsv33p :: R , G :: R , nu :: R , ) where R Compute displacement arisen from inelastic strain in Hex8 elements. Please see original version for complete details. Arguments x1 , x2 , x3 : observational position q1 , q2 , q3 : Hex8 element position L , T , W : Hex8 element length, thickness and width theta : strike angle epsv** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} G : shear modulus nu : poisson ratio Output A vector of 3 numbers, each represents u_{1} u_{1} , u_{2} u_{2} , u_{3} u_{3} Notice Inplace version: sbarbot_disp_hex8!(u, args...) where u is a vector of 3 numbers. # JuEQ.sbarbot_stress_hex8 \u2014 Method . 1 2 3 4 5 6 sbarbot_stress_hex8 ( x1 :: R , x2 :: R , x3 :: R , q1 :: R , q2 :: R , q3 :: R , L :: R , T :: R , W :: R , theta :: R , epsv11p :: R , epsv12p :: R , epsv13p :: R , epsv22p :: R , epsv23p :: R , epsv33p :: R , G :: R , nu :: R , ) where R Compute stress arisen from inelastic strain in Hex8 elements. Please see original version for complete details. Arguments The same as sbarbot_disp_hex8 Output A vector of 6 numbers, each represents \u03c3_{11} \u03c3_{11} , \u03c3_{12} \u03c3_{12} , \u03c3_{13} \u03c3_{13} , \u03c3_{22} \u03c3_{22} , \u03c3_{23} \u03c3_{23} , \u03c3_{33} \u03c3_{33} Notice Inplace version: sbarbot_stress_hex8!(u, args...) where u is a vector of 6 numbers. # JuEQ.sbarbot_disp_tet4 \u2014 Method . 1 2 3 4 sbarbot_disp_tet4 ( quadrature :: Q , x1 :: R , x2 :: R , x3 :: R , A :: U , B :: U , C :: U , D :: U , e11 :: R , e12 :: R , e13 :: R , e22 :: R , e23 :: R , e33 :: R , nu :: R ) where { R , U , Q } Compute displacement arisen from inelastic strain in Tet4 elements. Please see original version for complete details. Arguments quadrature : quadrature rule for integration, see FastGaussQuadrature.jl x1 , x2 , x3 : observational position A , B , C , D : a list of 3 numbers for each, each of which represents coordinates of the vertex epsv** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} nu : poisson ratio Output A vector of 3 numbers, each represents u_{1} u_{1} , u_{2} u_{2} , u_{3} u_{3} Notice Inplace version: sbarbot_disp_tet4!(u, args...) where u is a vector of 3 numbers. # JuEQ.sbarbot_stress_tet4 \u2014 Method . 1 2 3 4 sbarbot_stress_tet4 ( quadrature :: Q , x1 :: R , x2 :: R , x3 :: R , A :: U , B :: U , C :: U , D :: U , e11 :: R , e12 :: R , e13 :: R , e22 :: R , e23 :: R , e33 :: R , G :: R , nu :: R ) where { R , U , Q } Compute stress arisen from inelastic strain in Tet4 elements. Please see original version for complete details. Arguments quadrature : quadrature rule for integration, see FastGaussQuadrature.jl x1 , x2 , x3 : observational position A , B , C , D : a list of 3 numbers for each, each of which represents coordinates of the vertex epsv** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} G : shear modulus nu : poisson ratio Output A vector of 6 numbers, each represents \u03c3_{11} \u03c3_{11} , \u03c3_{12} \u03c3_{12} , \u03c3_{13} \u03c3_{13} , \u03c3_{22} \u03c3_{22} , \u03c3_{23} \u03c3_{23} , \u03c3_{33} \u03c3_{33} Notice Inplace version: sbarbot_stress_tet4!(u, args...) where u is a vector of 6 numbers. References \u00b6 Okada, Y. (1992). Internal deformation due to shear and tensile faults in a half-space. Bulletin of the Seismological Society of America, 82(2), 1018\u20131040. Barbot, S., Moore, J. D. P., & Lambert, V. (2017). Displacement and Stress Associated with Distributed Anelastic Deformation in a Half\u2010Space. Bulletin of the Seismological Society of America, 107(2), 821\u2013855. https://doi.org/10.1785/0120160237 Barbot, S. (2018). Deformation of a Half\u2010Space from Anelastic Strain Confined in a Tetrahedral Volume. Bulletin of the Seismological Society of America, 108(5A), 2687\u20132712. https://doi.org/10.1785/0120180058","title":"Greens Function"},{"location":"interface_greensfun/#greens-function","text":"The interactions among fault patches, asthenosphere elements as well as between fault and asthenosphere are computed via convolution of Green's Function. Currently supported Green's Function: 1D elastic line dislocation 2D elastic rectangular dislocation 3D inelastic strain in Hex8 or Tet4 elements Other types, such as 2D inelastic (plane stress or antiplane stress), curved dislocation, are WIP. Also notice that coordinate system in dc3d is different from sbarbot_disp_hex8 , sbarbot_disp_tet4 or their auxiliary stress/strain computing function.","title":"Green's Function"},{"location":"interface_greensfun/#public-interface","text":"# JuEQ.cat_greensfun \u2014 Method . 1 cat_greensfun ( ee :: AbstractArray , ev :: NTuple , ve :: NTuple , vv :: NTuple ) Concatenate tuple of matrix or tuple of tuple of matrix which arrange them in a way to update traction/stress rate using only one BLAS call. It does nothing to the elastic Green's function and specifically used for the outputs from okada_stress_gf_tensor and sbarbot_stress_gf_tensor . Arguments ee : traction Green's function within the elastic fault ev : stress Green's function from elastic fault to inelastic asthenosphere ve : traction Green's function inelastic asthenosphere to elastic fault vv : stress Green's function within inelastic asthenosphere # JuEQ.okada_stress_gf_tensor \u2014 Method . 1 2 okada_stress_gf_tensor ( mf :: RectOkadaMesh , ma :: SBarbotMeshEntity { 3 }, \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; kwargs ... ) where { T <: Real , I <: Integer } Compute stress Green's function from RectOkadaMesh to SBarbotTet4MeshEntity or SBarbotHex8MeshEntity Arguments mf::RectOkadaMesh : mesh of fault ma::SBarbotMeshEntity{3} : mesh of asthenosphere \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() Output The output is a tuple of 6 matrix, each corresponds \u03c3_{xx} \u03c3_{xx} , \u03c3_{xy} \u03c3_{xy} , \u03c3_{xz} \u03c3_{xz} , \u03c3_{yy} \u03c3_{yy} , \u03c3_{yz} \u03c3_{yz} , \u03c3_{zz} \u03c3_{zz} # JuEQ.okada_stress_gf_tensor \u2014 Method . 1 okada_stress_gf_tensor ( mesh :: LineOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; kwargs ... ) where T Compute traction Green function in 1-D elastic fault in LineOkadaMesh . Arguments mesh::LineOkadaMesh : the line mesh coupled with dc3d \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments ax_ratio::Real : ratio of along-strike to along-downdip, default is 12.5 # JuEQ.okada_stress_gf_tensor \u2014 Method . 1 2 okada_stress_gf_tensor ( mesh :: RectOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: FlatPlaneFault ; fourier_domain = true , kwargs ... ) where T Compute traction Green's function in 2-D elastic fault in RectOkadaMesh . Translational symmetry is considered. Arguments mesh::RectOkadaMesh : the line mesh coupled with dc3d \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() KWARGS Arguments fourier_domain::Bool : whether or not transform the tensor to fourier domain nrept::Integer : number of periodic summation is performed buffer_ratio::Real : ratio of length of buffer zone (along-strike) to that of fault (along-strike) It is recommended to set at least 1 for strike-slip fault for mimicing zero-dislocation at ridge on both sides. # JuEQ.sbarbot_stress_gf_tensor \u2014 Method . 1 2 sbarbot_stress_gf_tensor ( ma :: SBarbotMeshEntity { 3 }, mf :: RectOkadaMesh , \u03bb :: T , \u03bc :: T , ft :: PlaneFault , comp :: NTuple { N , Symbol }; kwargs ... ) where { T , N } Compute traction Green's function from SBarbotTet4MeshEntity or SBarbotHex8MeshEntity to RectOkadaMesh Arguments ma::SBarbotMeshEntity{3} : asthenosphere mesh mf::RectOkadaMesh : fault mesh \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus ft::FlatPlaneFault : fault type, either DIPPING() or STRIKING() comp : the strain component(s) to be considered. Either a singleton of :xx , :xy , :xz , :yy , :yz , :zz or tuple of a few ones Output A tuple of n n matrix, each represents interaction from one strain to the traction on fault # JuEQ.sbarbot_stress_gf_tensor \u2014 Method . 1 2 sbarbot_stress_gf_tensor ( ma :: SBarbotMeshEntity { 3 }, \u03bb :: T , \u03bc :: T , comp :: NTuple { N , Symbol }; kwargs ... ) where { T , N } Compute stress Green's function within SBarbotTet4MeshEntity or SBarbotHex8MeshEntity Arguments ma::SBarbotMeshEntity{3} : asthenosphere mesh \u03bb::T : Lam\u00e9's first parameter \u03bc::T : shear modulus comp : the strain component(s) to be considered. Either a singleton of :xx , :xy , :xz , :yy , :yz , :zz or tuple of a few ones Output A tuple of n n tuple of matrix, each tuple represents interaction from one strain to the stress components, each of which is a matrix, within asthenosphere # JuEQ.dc3d \u2014 Method . 1 2 3 dc3d ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al :: Union { A , SubArray }, aw :: Union { A , SubArray }, disl :: A ) where { T <: Number , A <: AbstractVecOrMat { T }} Calculate displacements and gradient of displacements due to a rectangular dislocation in an elastic isotropic halfspace. Please see dc3d for details. Also this fault coordinate system is widely used in this package. Arguments x , y , z : observational position \u03b1 : elastic constant dep : depth of fault origin dip : dip angle in degree al : a vector of 2 numbers, indicating along strike (x-axis) spanning aw : a vector of 2 numbers, indicating along downdip (y-z plane) spanning disl : a vector of 3 numbers, indicating dislocation in along-strike, along-downdip and tensile respectively. Output A vector of 12 numbers, each is u_{x} u_{x} , u_{y} u_{y} , u_{z} u_{z} , u_{x,x} u_{x,x} , u_{y,x} u_{y,x} , u_{z,x} u_{z,x} , u_{x,y} u_{x,y} , u_{y,y} u_{y,y} , u_{z,y} u_{z,y} , u_{x,z} u_{x,z} u_{y,z} u_{y,z} , u_{z,z} u_{z,z} . # JuEQ.sbarbot_disp_hex8 \u2014 Method . 1 2 3 4 5 6 sbarbot_disp_hex8 ( x1 :: R , x2 :: R , x3 :: R , q1 :: R , q2 :: R , q3 :: R , L :: R , T :: R , W :: R , theta :: R , epsv11p :: R , epsv12p :: R , epsv13p :: R , epsv22p :: R , epsv23p :: R , epsv33p :: R , G :: R , nu :: R , ) where R Compute displacement arisen from inelastic strain in Hex8 elements. Please see original version for complete details. Arguments x1 , x2 , x3 : observational position q1 , q2 , q3 : Hex8 element position L , T , W : Hex8 element length, thickness and width theta : strike angle epsv** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} G : shear modulus nu : poisson ratio Output A vector of 3 numbers, each represents u_{1} u_{1} , u_{2} u_{2} , u_{3} u_{3} Notice Inplace version: sbarbot_disp_hex8!(u, args...) where u is a vector of 3 numbers. # JuEQ.sbarbot_stress_hex8 \u2014 Method . 1 2 3 4 5 6 sbarbot_stress_hex8 ( x1 :: R , x2 :: R , x3 :: R , q1 :: R , q2 :: R , q3 :: R , L :: R , T :: R , W :: R , theta :: R , epsv11p :: R , epsv12p :: R , epsv13p :: R , epsv22p :: R , epsv23p :: R , epsv33p :: R , G :: R , nu :: R , ) where R Compute stress arisen from inelastic strain in Hex8 elements. Please see original version for complete details. Arguments The same as sbarbot_disp_hex8 Output A vector of 6 numbers, each represents \u03c3_{11} \u03c3_{11} , \u03c3_{12} \u03c3_{12} , \u03c3_{13} \u03c3_{13} , \u03c3_{22} \u03c3_{22} , \u03c3_{23} \u03c3_{23} , \u03c3_{33} \u03c3_{33} Notice Inplace version: sbarbot_stress_hex8!(u, args...) where u is a vector of 6 numbers. # JuEQ.sbarbot_disp_tet4 \u2014 Method . 1 2 3 4 sbarbot_disp_tet4 ( quadrature :: Q , x1 :: R , x2 :: R , x3 :: R , A :: U , B :: U , C :: U , D :: U , e11 :: R , e12 :: R , e13 :: R , e22 :: R , e23 :: R , e33 :: R , nu :: R ) where { R , U , Q } Compute displacement arisen from inelastic strain in Tet4 elements. Please see original version for complete details. Arguments quadrature : quadrature rule for integration, see FastGaussQuadrature.jl x1 , x2 , x3 : observational position A , B , C , D : a list of 3 numbers for each, each of which represents coordinates of the vertex epsv** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} nu : poisson ratio Output A vector of 3 numbers, each represents u_{1} u_{1} , u_{2} u_{2} , u_{3} u_{3} Notice Inplace version: sbarbot_disp_tet4!(u, args...) where u is a vector of 3 numbers. # JuEQ.sbarbot_stress_tet4 \u2014 Method . 1 2 3 4 sbarbot_stress_tet4 ( quadrature :: Q , x1 :: R , x2 :: R , x3 :: R , A :: U , B :: U , C :: U , D :: U , e11 :: R , e12 :: R , e13 :: R , e22 :: R , e23 :: R , e33 :: R , G :: R , nu :: R ) where { R , U , Q } Compute stress arisen from inelastic strain in Tet4 elements. Please see original version for complete details. Arguments quadrature : quadrature rule for integration, see FastGaussQuadrature.jl x1 , x2 , x3 : observational position A , B , C , D : a list of 3 numbers for each, each of which represents coordinates of the vertex epsv** : strain components, each is \u03f5_{11} \u03f5_{11} , \u03f5_{12} \u03f5_{12} , \u03f5_{13} \u03f5_{13} , \u03f5_{22} \u03f5_{22} , \u03f5_{23} \u03f5_{23} , \u03f5_{33} \u03f5_{33} G : shear modulus nu : poisson ratio Output A vector of 6 numbers, each represents \u03c3_{11} \u03c3_{11} , \u03c3_{12} \u03c3_{12} , \u03c3_{13} \u03c3_{13} , \u03c3_{22} \u03c3_{22} , \u03c3_{23} \u03c3_{23} , \u03c3_{33} \u03c3_{33} Notice Inplace version: sbarbot_stress_tet4!(u, args...) where u is a vector of 6 numbers.","title":"Public Interface"},{"location":"interface_greensfun/#references","text":"Okada, Y. (1992). Internal deformation due to shear and tensile faults in a half-space. Bulletin of the Seismological Society of America, 82(2), 1018\u20131040. Barbot, S., Moore, J. D. P., & Lambert, V. (2017). Displacement and Stress Associated with Distributed Anelastic Deformation in a Half\u2010Space. Bulletin of the Seismological Society of America, 107(2), 821\u2013855. https://doi.org/10.1785/0120160237 Barbot, S. (2018). Deformation of a Half\u2010Space from Anelastic Strain Confined in a Tetrahedral Volume. Bulletin of the Seismological Society of America, 108(5A), 2687\u20132712. https://doi.org/10.1785/0120180058","title":"References"},{"location":"interface_mesh/","text":"Mesh \u00b6 This package provides some buildin structured mesh functionality and some data structures coupled with existing Green's functions where users could explore external mesh tools. This package also provide rich utilities based on Gmsh . To use them, 1 2 3 pkg > add GmshTools julia > using JuEQ julia > using GmshTools Users are encouraged to read Gmsh Julia API for more comprehensive operations. Public Interface \u00b6 # JuEQ.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ) Generate LineOkadaMesh Arguments \u03be : downdip length \u0394\u03be : downdip interval dip : dipping angle # JuEQ.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ) Generate RectOkadaMesh Arguments x : along strike length \u03be : downdip length \u0394x : along strike interval \u0394\u03be : downdip interval dip : dipping angle # JuEQ.gen_gmsh_mesh \u2014 Method . 1 gen_gmsh_mesh ( mf :: OkadaMesh ; kwargs ... ) Generate an equivalent unstructured mesh as mf::OkadaMesh Arguments mf::OkadaMesh : the structured mesh kwargs... : stay the same as other methods for gen_gmsh_mesh # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 3 4 5 gen_gmsh_mesh ( mf :: RectOkadaMesh , :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Generate a mesh combinating RectOkadaMesh and BoxHexExtrudeFromSurface mesh for asthenosphere. The first argument is the corresponding RectOkadaMesh , the rest ones stay the same. # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 3 4 gen_gmsh_mesh ( :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Gernate a box for Asthenosphere using 8-node hexahedron elements (via setting transfinite curve). Arguments llx , lly , llz : coordinates of low-left corner on the top surface dx , dy , dz : x-, y-, z-extension nx , ny : number of cells along x-, y-axis rfx , rfy : refinement coefficients along x-, y-axis using Bump algorithm, please refer gmsh.model.geo.mesh.setTransfiniteCurve rfzn : number of cells along z-axis, please refer numElements in gmsh.model.geo.extrude rfzh : accumulated height of cells along z-axis, please refer heights in gmsh.model.geo.extrude # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 gen_gmsh_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ; filename :: AbstractString = \"temp.msh\" , reg :: Integer = 1 ) where T Generate equivalent LineOkadaMesh via Gmsh buildin engine. Extra Arguments filename::AbstractString=\"temp.msh\" : name of the generated mesh file. The file ext will be automatically handled by Gmsh. reg::Integer=1 : the starting tag for entity of any dimension The rest arguments stay the same as gen_mesh . # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 gen_gmsh_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ; filename :: AbstractString = \"temp.msh\" , reg :: Integer = 1 ) where T Generate equivalent RectOkadaMesh via Gmsh buildin engine. Extra Arguments filename::AbstractString=\"temp.msh\" : name of the generated mesh file. The file ext will be automatically handled by Gmsh. reg::Integer=1 : the starting tag for entity of any dimension The rest arguments stay the same as gen_mesh . # JuEQ.gmsh_vtk_output_cache \u2014 Method . 1 gmsh_vtk_output_cache ( file :: AbstractString , phydim :: I , phytag :: I ) where I <: Integer Create cache of unstructured mesh for VTK output. Arguments file::AbstractString : mesh file phydim : physical group dimension, which you will querry phytag : physical group tag associated with phydim . If smaller than 0, retrieve all entities in physical group whose dimension is phydim . If in this case, only one such entity, binded with that physical group, shall exist. If you would like to write multi-block data, create VTK output caches for each physical group. # JuEQ.gmsh_vtk_output_cache \u2014 Method . 1 gmsh_vtk_output_cache ( file :: AbstractString , mf :: OkadaMesh { N }, phytag :: Integer =- 1 , datatype = Float64 ) where N Create cache of structured OkadaMesh for VTK output, which handles the data mapping from structured data to unstructured mesh. It's worth mention that currently WriteVTK cannot write inclined plane in 3D space. As a workround, it seeks transfering from Gmsh unstructured (transfinite) mesh. Arguments file::AbstractString : mesh file containing fault mesh (transfinite) mf::OkadaMesh{N} : equivalent structured mesh, must match unstructured mesh in the file above phytag::Integer=-1 : physical group tag associated with fault mesh in the mesh file. If smaller than 0, retrieve all entities in physical group whose dimension is determined by mf . If in this case, only one such entity, assumed to be the fault, shall exist. datatype=Float64 : data type for temporary array storing the mapped data # JuEQ.read_gmsh_mesh \u2014 Method . 1 2 read_gmsh_mesh ( :: Val { : SBarbotHex8 }, f :: AbstractString ; phytag :: Integer =- 1 , rotate :: Number = 0.0 , reverse = false , check = false ) Read the mesh and construct mesh entity infomation for SBarbot Hex8 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 3-dimensional entities. If in this case, your mesh must contain only one element type. rotate : the angle of strike direction, see sbarbot_disp_hex8! . If your meshing box isn't parallel to x, y-axis, your must provide your strike angle manually. By default, the strike angle is zero reverse : if true , reverse the along-x, y-node tag during read. By default, 1\u21924 in x-axis, 1\u21922 in y-axis, 1\u21925 in z-axis check : if true , check that number of distinctive q1 equals that of x1 , same for q2 and x2 at orthogonal direction, which should hold for transfinite mesh. Notice This function can only be used for Hex8 element with each element lying parallel to z-axis. The check procedure is not complete for arbitrary strike angle (0 < \u03b8 < 90). The user should take a close look on the node ordering for one element to ensure the x-, y-extent are correctly resolved by change reverse accordingly. # JuEQ.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : SBarbotTet4 }, f :: AbstractString ; phytag :: Integer =- 1 ) Read the mesh and construct mesh entity infomation for SBarbot Tet4 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 3-dimensional entities. If in this case, your mesh must contain only one element type. # JuEQ.DIPPING \u2014 Type . Dipping, indicate dislocation occurs at y-z plane in dc3d use. # JuEQ.STRIKING \u2014 Type . Striking, indicate dislocation occurs at x-direction in dc3d use. # JuEQ.compose \u2014 Method . 1 compose ( me :: AbstractMesh , me :: SBarbotMeshEntity { N }) Create a composite space consisting of both fault mesh and asthenosphere mesh. Arguments me::AbstractMesh : fault mesh me::SBarbotMeshEntity{N} : asthenosphere mesh References \u00b6 Geuzaine, C., & Remacle, J.-F. (2009). Gmsh: A 3-D finite element mesh generator with built-in pre- and post-processing facilities. International Journal for Numerical Methods in Engineering, 79(11), 1309\u20131331. https://doi.org/10.1002/nme.2579","title":"Mesh"},{"location":"interface_mesh/#mesh","text":"This package provides some buildin structured mesh functionality and some data structures coupled with existing Green's functions where users could explore external mesh tools. This package also provide rich utilities based on Gmsh . To use them, 1 2 3 pkg > add GmshTools julia > using JuEQ julia > using GmshTools Users are encouraged to read Gmsh Julia API for more comprehensive operations.","title":"Mesh"},{"location":"interface_mesh/#public-interface","text":"# JuEQ.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ) Generate LineOkadaMesh Arguments \u03be : downdip length \u0394\u03be : downdip interval dip : dipping angle # JuEQ.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ) Generate RectOkadaMesh Arguments x : along strike length \u03be : downdip length \u0394x : along strike interval \u0394\u03be : downdip interval dip : dipping angle # JuEQ.gen_gmsh_mesh \u2014 Method . 1 gen_gmsh_mesh ( mf :: OkadaMesh ; kwargs ... ) Generate an equivalent unstructured mesh as mf::OkadaMesh Arguments mf::OkadaMesh : the structured mesh kwargs... : stay the same as other methods for gen_gmsh_mesh # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 3 4 5 gen_gmsh_mesh ( mf :: RectOkadaMesh , :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Generate a mesh combinating RectOkadaMesh and BoxHexExtrudeFromSurface mesh for asthenosphere. The first argument is the corresponding RectOkadaMesh , the rest ones stay the same. # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 3 4 gen_gmsh_mesh ( :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Gernate a box for Asthenosphere using 8-node hexahedron elements (via setting transfinite curve). Arguments llx , lly , llz : coordinates of low-left corner on the top surface dx , dy , dz : x-, y-, z-extension nx , ny : number of cells along x-, y-axis rfx , rfy : refinement coefficients along x-, y-axis using Bump algorithm, please refer gmsh.model.geo.mesh.setTransfiniteCurve rfzn : number of cells along z-axis, please refer numElements in gmsh.model.geo.extrude rfzh : accumulated height of cells along z-axis, please refer heights in gmsh.model.geo.extrude # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 gen_gmsh_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ; filename :: AbstractString = \"temp.msh\" , reg :: Integer = 1 ) where T Generate equivalent LineOkadaMesh via Gmsh buildin engine. Extra Arguments filename::AbstractString=\"temp.msh\" : name of the generated mesh file. The file ext will be automatically handled by Gmsh. reg::Integer=1 : the starting tag for entity of any dimension The rest arguments stay the same as gen_mesh . # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 gen_gmsh_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ; filename :: AbstractString = \"temp.msh\" , reg :: Integer = 1 ) where T Generate equivalent RectOkadaMesh via Gmsh buildin engine. Extra Arguments filename::AbstractString=\"temp.msh\" : name of the generated mesh file. The file ext will be automatically handled by Gmsh. reg::Integer=1 : the starting tag for entity of any dimension The rest arguments stay the same as gen_mesh . # JuEQ.gmsh_vtk_output_cache \u2014 Method . 1 gmsh_vtk_output_cache ( file :: AbstractString , phydim :: I , phytag :: I ) where I <: Integer Create cache of unstructured mesh for VTK output. Arguments file::AbstractString : mesh file phydim : physical group dimension, which you will querry phytag : physical group tag associated with phydim . If smaller than 0, retrieve all entities in physical group whose dimension is phydim . If in this case, only one such entity, binded with that physical group, shall exist. If you would like to write multi-block data, create VTK output caches for each physical group. # JuEQ.gmsh_vtk_output_cache \u2014 Method . 1 gmsh_vtk_output_cache ( file :: AbstractString , mf :: OkadaMesh { N }, phytag :: Integer =- 1 , datatype = Float64 ) where N Create cache of structured OkadaMesh for VTK output, which handles the data mapping from structured data to unstructured mesh. It's worth mention that currently WriteVTK cannot write inclined plane in 3D space. As a workround, it seeks transfering from Gmsh unstructured (transfinite) mesh. Arguments file::AbstractString : mesh file containing fault mesh (transfinite) mf::OkadaMesh{N} : equivalent structured mesh, must match unstructured mesh in the file above phytag::Integer=-1 : physical group tag associated with fault mesh in the mesh file. If smaller than 0, retrieve all entities in physical group whose dimension is determined by mf . If in this case, only one such entity, assumed to be the fault, shall exist. datatype=Float64 : data type for temporary array storing the mapped data # JuEQ.read_gmsh_mesh \u2014 Method . 1 2 read_gmsh_mesh ( :: Val { : SBarbotHex8 }, f :: AbstractString ; phytag :: Integer =- 1 , rotate :: Number = 0.0 , reverse = false , check = false ) Read the mesh and construct mesh entity infomation for SBarbot Hex8 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 3-dimensional entities. If in this case, your mesh must contain only one element type. rotate : the angle of strike direction, see sbarbot_disp_hex8! . If your meshing box isn't parallel to x, y-axis, your must provide your strike angle manually. By default, the strike angle is zero reverse : if true , reverse the along-x, y-node tag during read. By default, 1\u21924 in x-axis, 1\u21922 in y-axis, 1\u21925 in z-axis check : if true , check that number of distinctive q1 equals that of x1 , same for q2 and x2 at orthogonal direction, which should hold for transfinite mesh. Notice This function can only be used for Hex8 element with each element lying parallel to z-axis. The check procedure is not complete for arbitrary strike angle (0 < \u03b8 < 90). The user should take a close look on the node ordering for one element to ensure the x-, y-extent are correctly resolved by change reverse accordingly. # JuEQ.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : SBarbotTet4 }, f :: AbstractString ; phytag :: Integer =- 1 ) Read the mesh and construct mesh entity infomation for SBarbot Tet4 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If smaller than 0 , retrieve all elements in all 3-dimensional entities. If in this case, your mesh must contain only one element type. # JuEQ.DIPPING \u2014 Type . Dipping, indicate dislocation occurs at y-z plane in dc3d use. # JuEQ.STRIKING \u2014 Type . Striking, indicate dislocation occurs at x-direction in dc3d use. # JuEQ.compose \u2014 Method . 1 compose ( me :: AbstractMesh , me :: SBarbotMeshEntity { N }) Create a composite space consisting of both fault mesh and asthenosphere mesh. Arguments me::AbstractMesh : fault mesh me::SBarbotMeshEntity{N} : asthenosphere mesh","title":"Public Interface"},{"location":"interface_mesh/#references","text":"Geuzaine, C., & Remacle, J.-F. (2009). Gmsh: A 3-D finite element mesh generator with built-in pre- and post-processing facilities. International Journal for Numerical Methods in Engineering, 79(11), 1309\u20131331. https://doi.org/10.1002/nme.2579","title":"References"},{"location":"interface_property/","text":"Simulation Properties \u00b6 We attribute one struct of all necessary properties for each type of simulation objections. Public Interface \u00b6 # JuEQ.SingleDofRSFProperty \u2014 Type . System property for single degree of freedom under rate-state friction. Fields a : contrib from velocity b : contrib from state L : critical distance k : spring stiffness \u03c3 : effective normal stress \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # JuEQ.ElasticRSFProperty \u2014 Type . System property for multiple fault patches under rate-state friction. Fields a : contrib from velocity b : contrib from state L : critical distance \u03c3 : effective normal stress \u03bb : Lam\u00e9 first constants \u03bc : Lam\u00e9 second constants \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # JuEQ.DislocationCreepProperty \u2014 Type . System properties for plastic deformation of dislocation creep . Please refer (Hirth & Kohlstedt, 2003) for concrete units of each factor. Fields A : prefactor n : power law stress exponent fH\u20820 : water content r : water fugacity exponent \u03b1 : melting constant \u03d5 : melting fraction Q : activation energy P : pressure \u03a9 : activation volume T : temperature source # JuEQ.DiffusionCreepProperty \u2014 Type . System properties for plastic deformation of diffusion creep . Please refer (Hirth & Kohlstedt, 2003) for concrete units of each factor. Fields A : prefactor d : grain size m : grain size exponent fH\u20820 : water content r : water fugacity exponent \u03b1 : melting constant \u03d5 : melting fraction Q : activation energy P : pressure \u03a9 : activation volume T : temperature source # JuEQ.PeierlsProperty \u2014 Type . System properties for plastic deformation of Peierls Mechanisms . Not implemented yet. # JuEQ.CompositePlasticDeformationProperty \u2014 Type . Compose all three type of plastic deformation and other strain-related system properties, see (Kohlstedt & Hansen, 2015) . Each field is the overall equivalent factor not dependent on stress. Fields disl : dislocation creep n : stress exponent in dislocation creep diff : diffusion creep peie : Peierls mechanisms d\u03f5ref : reference strain rate whose length must equal strain components considered source # JuEQ.ViscoelasticMaxwellProperty \u2014 Type . Composite property for viscoelastic rheology of maxwell representation. Fields pe::ElasticRSFProperty : elastic rate-and-state system property pv::CompositePlasticDeformationProperty : composite plastic deformation system property # JuEQ.compose \u2014 Method . 1 compose ( pe :: ElasticRSFProperty { T }, d\u03f5ref , pvs ... ) where T Create maxwell viscoelastic system given both elastic and plastic properties. Arguments pe::ElasticRSFProperty{T} : elastic rate-and-state system property d\u03f5ref : reference strain rate whose length must equal strain components considered pvs... : different type of plastic deformation system properties but no more than three # JuEQ.composite_factor \u2014 Method . 1 composite_factor ( pv :: PlasticDeformationProperty ) Compute an equivalent factor for levarage recomputing during ODE solving. Arguments pv::PlasticDeformationProperty : plastic deformation system property","title":"Simulation Property"},{"location":"interface_property/#simulation-properties","text":"We attribute one struct of all necessary properties for each type of simulation objections.","title":"Simulation Properties"},{"location":"interface_property/#public-interface","text":"# JuEQ.SingleDofRSFProperty \u2014 Type . System property for single degree of freedom under rate-state friction. Fields a : contrib from velocity b : contrib from state L : critical distance k : spring stiffness \u03c3 : effective normal stress \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # JuEQ.ElasticRSFProperty \u2014 Type . System property for multiple fault patches under rate-state friction. Fields a : contrib from velocity b : contrib from state L : critical distance \u03c3 : effective normal stress \u03bb : Lam\u00e9 first constants \u03bc : Lam\u00e9 second constants \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # JuEQ.DislocationCreepProperty \u2014 Type . System properties for plastic deformation of dislocation creep . Please refer (Hirth & Kohlstedt, 2003) for concrete units of each factor. Fields A : prefactor n : power law stress exponent fH\u20820 : water content r : water fugacity exponent \u03b1 : melting constant \u03d5 : melting fraction Q : activation energy P : pressure \u03a9 : activation volume T : temperature source # JuEQ.DiffusionCreepProperty \u2014 Type . System properties for plastic deformation of diffusion creep . Please refer (Hirth & Kohlstedt, 2003) for concrete units of each factor. Fields A : prefactor d : grain size m : grain size exponent fH\u20820 : water content r : water fugacity exponent \u03b1 : melting constant \u03d5 : melting fraction Q : activation energy P : pressure \u03a9 : activation volume T : temperature source # JuEQ.PeierlsProperty \u2014 Type . System properties for plastic deformation of Peierls Mechanisms . Not implemented yet. # JuEQ.CompositePlasticDeformationProperty \u2014 Type . Compose all three type of plastic deformation and other strain-related system properties, see (Kohlstedt & Hansen, 2015) . Each field is the overall equivalent factor not dependent on stress. Fields disl : dislocation creep n : stress exponent in dislocation creep diff : diffusion creep peie : Peierls mechanisms d\u03f5ref : reference strain rate whose length must equal strain components considered source # JuEQ.ViscoelasticMaxwellProperty \u2014 Type . Composite property for viscoelastic rheology of maxwell representation. Fields pe::ElasticRSFProperty : elastic rate-and-state system property pv::CompositePlasticDeformationProperty : composite plastic deformation system property # JuEQ.compose \u2014 Method . 1 compose ( pe :: ElasticRSFProperty { T }, d\u03f5ref , pvs ... ) where T Create maxwell viscoelastic system given both elastic and plastic properties. Arguments pe::ElasticRSFProperty{T} : elastic rate-and-state system property d\u03f5ref : reference strain rate whose length must equal strain components considered pvs... : different type of plastic deformation system properties but no more than three # JuEQ.composite_factor \u2014 Method . 1 composite_factor ( pv :: PlasticDeformationProperty ) Compute an equivalent factor for levarage recomputing during ODE solving. Arguments pv::PlasticDeformationProperty : plastic deformation system property","title":"Public Interface"},{"location":"interface_rheology/","text":"Rheology \u00b6 This package implements plastic deformation as the key for modeling asthenosphere dynamics. Public Interface \u00b6 # JuEQ.DiffusionCreep \u2014 Type . \\dot{\u03f5} = A \u03c3\u2032 d^{-m} f_{\\mathrm{H}_{2}\\mathrm{O}} ^{r} \\exp{(\u03b1\u03d5)} \\exp{(- \\frac{Q + PV}{RT})} \\dot{\u03f5} = A \u03c3\u2032 d^{-m} f_{\\mathrm{H}_{2}\\mathrm{O}} ^{r} \\exp{(\u03b1\u03d5)} \\exp{(- \\frac{Q + PV}{RT})} # JuEQ.DislocationCreep \u2014 Type . \\dot{\u03f5} = A \u03c4^{n-1} \u03c3\u2032 f_{\\mathrm{H}_{2}\\mathrm{O}} ^{r} \\exp{(\u03b1\u03d5)} \\exp{(- \\frac{Q + PV}{RT})} \\dot{\u03f5} = A \u03c4^{n-1} \u03c3\u2032 f_{\\mathrm{H}_{2}\\mathrm{O}} ^{r} \\exp{(\u03b1\u03d5)} \\exp{(- \\frac{Q + PV}{RT})} # JuEQ.Peierls \u2014 Type . \\dot{\u03f5} = \\dot{\u03f5_{P}}\\left(\\frac{\u03c3}{G}\\right)^{2} \\exp{\\left(-\\frac{\u0394F_{k}^{o}}{RT}\\left(1 - \\left(\\frac{\u03c3}{\u03c3_{P}}\\right)^{r}\\right)^{s}\\right)} \\dot{\u03f5} = \\dot{\u03f5_{P}}\\left(\\frac{\u03c3}{G}\\right)^{2} \\exp{\\left(-\\frac{\u0394F_{k}^{o}}{RT}\\left(1 - \\left(\\frac{\u03c3}{\u03c3_{P}}\\right)^{r}\\right)^{s}\\right)} References \u00b6 Hirth, G., & Kohlstedt, D. (2003). Rheology of the Upper Mantle and the Mantle Wedge: A View from the Experimentalists. In Inside the Subduction Factory (pp. 83\u2013105). American Geophysical Union (AGU). https://doi.org/10.1029/138GM06 Karato, S. (2010). Rheology of the Earth\u2019s mantle: A historical review. Gondwana Research, 18(1), 17\u201345. https://doi.org/10.1016/j.gr.2010.03.004 Kohlstedt, D. L., & Hansen, L. N. (2015). 2.18 - Constitutive Equations, Rheological Behavior, and Viscosity of Rocks. In G. Schubert (Ed.), Treatise on Geophysics (Second Edition) (pp. 441\u2013472). Oxford: Elsevier. https://doi.org/10.1016/B978-0-444-53802-4.00042-7","title":"Rheology"},{"location":"interface_rheology/#rheology","text":"This package implements plastic deformation as the key for modeling asthenosphere dynamics.","title":"Rheology"},{"location":"interface_rheology/#public-interface","text":"# JuEQ.DiffusionCreep \u2014 Type . \\dot{\u03f5} = A \u03c3\u2032 d^{-m} f_{\\mathrm{H}_{2}\\mathrm{O}} ^{r} \\exp{(\u03b1\u03d5)} \\exp{(- \\frac{Q + PV}{RT})} \\dot{\u03f5} = A \u03c3\u2032 d^{-m} f_{\\mathrm{H}_{2}\\mathrm{O}} ^{r} \\exp{(\u03b1\u03d5)} \\exp{(- \\frac{Q + PV}{RT})} # JuEQ.DislocationCreep \u2014 Type . \\dot{\u03f5} = A \u03c4^{n-1} \u03c3\u2032 f_{\\mathrm{H}_{2}\\mathrm{O}} ^{r} \\exp{(\u03b1\u03d5)} \\exp{(- \\frac{Q + PV}{RT})} \\dot{\u03f5} = A \u03c4^{n-1} \u03c3\u2032 f_{\\mathrm{H}_{2}\\mathrm{O}} ^{r} \\exp{(\u03b1\u03d5)} \\exp{(- \\frac{Q + PV}{RT})} # JuEQ.Peierls \u2014 Type . \\dot{\u03f5} = \\dot{\u03f5_{P}}\\left(\\frac{\u03c3}{G}\\right)^{2} \\exp{\\left(-\\frac{\u0394F_{k}^{o}}{RT}\\left(1 - \\left(\\frac{\u03c3}{\u03c3_{P}}\\right)^{r}\\right)^{s}\\right)} \\dot{\u03f5} = \\dot{\u03f5_{P}}\\left(\\frac{\u03c3}{G}\\right)^{2} \\exp{\\left(-\\frac{\u0394F_{k}^{o}}{RT}\\left(1 - \\left(\\frac{\u03c3}{\u03c3_{P}}\\right)^{r}\\right)^{s}\\right)}","title":"Public Interface"},{"location":"interface_rheology/#references","text":"Hirth, G., & Kohlstedt, D. (2003). Rheology of the Upper Mantle and the Mantle Wedge: A View from the Experimentalists. In Inside the Subduction Factory (pp. 83\u2013105). American Geophysical Union (AGU). https://doi.org/10.1029/138GM06 Karato, S. (2010). Rheology of the Earth\u2019s mantle: A historical review. Gondwana Research, 18(1), 17\u201345. https://doi.org/10.1016/j.gr.2010.03.004 Kohlstedt, D. L., & Hansen, L. N. (2015). 2.18 - Constitutive Equations, Rheological Behavior, and Viscosity of Rocks. In G. Schubert (Ed.), Treatise on Geophysics (Second Edition) (pp. 441\u2013472). Oxford: Elsevier. https://doi.org/10.1016/B978-0-444-53802-4.00042-7","title":"References"},{"location":"interface_visualize/","text":"Visualize \u00b6 This package provides some utilities for writing results to VTK (vts, vti, vtu, vtm, pvd, etc...) file for postprocessing with Paraview . Data cache for writing results are also implemented where users could explore other meshing tools. Public Interface \u00b6 # JuEQ.vtk_output \u2014 Method . 1 2 vtk_output ( f , u :: AbstractVector { <: AbstractVecOrMat }, ustr :: AbstractVector { <: AbstractString }, cache :: ParaviewOutputCache ) Write results to single-block VTK file. Arguments f : output file name u::AbstractVector{<:AbstractArray} , list of results to be written ustr::AbstractVector{<:AbstractString} : list results names to be assigned cache : cache of data conversion, cell information and nodes information # JuEQ.vtk_output \u2014 Method . 1 2 vtk_output ( f , t :: AbstractVector , u :: AbstractVector { <: AbstractVecOrMat }, ustr :: AbstractVector { <: AbstractString }, cache :: ParaviewOutputCache ) Write time-series results to single-block paraview collection file. Arguments f : output file name t::AbstractVector : time stamp vector u::AbstractVector{<:AbstractArray} , list of results to be written ustr::AbstractVector{<:AbstractString} : list results names to be assigned cache : cache of data conversion, cell information and nodes information # JuEQ.vtm_output \u2014 Method . 1 vtm_output ( f , u , ustr , cache :: ParaviewOutputCache ) Write results to multiple-block VTM file. Arguments f : output file name u , list of block to be written, each contains a list of results in that block ustr : list of block to be assigned, each contains a list of results names to data in that block cache : list cache corresponding to each block # JuEQ.vtm_output \u2014 Method . 1 vtm_output ( f , t , u , ustr , cache :: ParaviewOutputCache ) Write results to multiple-block paraview collection file. Arguments f : output file name t::AbstractVector : time stamp vector u , list of different block data to be written, each contains a list of results in that block ustr : list of block names to be assigned, each contains a list of results names to data in that block cache : list cache corresponding to each block","title":"Visualize"},{"location":"interface_visualize/#visualize","text":"This package provides some utilities for writing results to VTK (vts, vti, vtu, vtm, pvd, etc...) file for postprocessing with Paraview . Data cache for writing results are also implemented where users could explore other meshing tools.","title":"Visualize"},{"location":"interface_visualize/#public-interface","text":"# JuEQ.vtk_output \u2014 Method . 1 2 vtk_output ( f , u :: AbstractVector { <: AbstractVecOrMat }, ustr :: AbstractVector { <: AbstractString }, cache :: ParaviewOutputCache ) Write results to single-block VTK file. Arguments f : output file name u::AbstractVector{<:AbstractArray} , list of results to be written ustr::AbstractVector{<:AbstractString} : list results names to be assigned cache : cache of data conversion, cell information and nodes information # JuEQ.vtk_output \u2014 Method . 1 2 vtk_output ( f , t :: AbstractVector , u :: AbstractVector { <: AbstractVecOrMat }, ustr :: AbstractVector { <: AbstractString }, cache :: ParaviewOutputCache ) Write time-series results to single-block paraview collection file. Arguments f : output file name t::AbstractVector : time stamp vector u::AbstractVector{<:AbstractArray} , list of results to be written ustr::AbstractVector{<:AbstractString} : list results names to be assigned cache : cache of data conversion, cell information and nodes information # JuEQ.vtm_output \u2014 Method . 1 vtm_output ( f , u , ustr , cache :: ParaviewOutputCache ) Write results to multiple-block VTM file. Arguments f : output file name u , list of block to be written, each contains a list of results in that block ustr : list of block to be assigned, each contains a list of results names to data in that block cache : list cache corresponding to each block # JuEQ.vtm_output \u2014 Method . 1 vtm_output ( f , t , u , ustr , cache :: ParaviewOutputCache ) Write results to multiple-block paraview collection file. Arguments f : output file name t::AbstractVector : time stamp vector u , list of different block data to be written, each contains a list of results in that block ustr : list of block names to be assigned, each contains a list of results names to data in that block cache : list cache corresponding to each block","title":"Public Interface"},{"location":"examples/generated/bp1/","text":"Note This example is from Benchmark Problem 1 (hence referred as BP1). First, we load the package 1 2 using JuEQ using Plots The prerequisite parameters in this benchmark are list below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ms2mmyr = 365 * 86400 * 1e3 # convert velocity from m/s to mm/yr \u03c1 = 2670.0 # density [kg/m\u00b3] vs = 3464.0 # shear wave velocity [m/s] \u03c30 = 500.0 # effective normal stress [bar] a0 = 0.010 # frictional paramter `a` in vw zone amax = 0.025 # frictional paramter `a` in vs zone b0 = 0.015 # frictional paramter `b` L0 = 8.0 # critical distance [mm] vpl = 1e-9 * ms2mmyr # plate rate [mm/yr] vinit = 1e-9 * ms2mmyr # initial velocity [mm/yr] v0 = 1e-6 * ms2mmyr # reference velocity [mm/yr] f0 = 0.6 # reference frictional coefficient H = 15.0 # vw zone [km] h = 3.0 # vw-vs changing zone [km] Wf = 40.0 # fault depth [km] \u0394z = 100.0e-3 # grid size interval [km] tf = 200.0 ; nothing # simulation time [yr] Warning Make sure your units are consistent across the whole variable space. Then we arrive at some parameters that are implicit by above: 1 2 3 4 \u03bc = vs ^ 2 * \u03c1 / 1e5 / 1e6 # shear modulus [bar\u00b7km/mm] \u03bb = \u03bc # poisson material \u03b7 = \u03bc / 2 ( vs * 1e-3 * 365 * 86400 ) ngrid = round ( Int , Wf / \u0394z ); nothing # number of grids First, set up a fault type which is strike-slip, and create a fault mesh by specifying depth and the desired discretization interval. 1 2 ft = STRIKING () mesh = gen_mesh ( Val ( : LineOkada ), 40.0 , \u0394z , 90.0 ); nothing Computing the Green's function for this setting. 1 gf = okada_stress_gf_tensor ( mesh , \u03bb , \u03bc , ft ); nothing Then, provide the material properties w.r.t. our 'fault space'. 1 2 3 4 5 6 7 a = a0 .* ones ( mesh . n\u03be ) a [ - mesh . z .\u2265 ( H + h )] .= amax a [ H .< - mesh . z .< H + h ] .= a0 .+ ( amax - a0 ) / ( h / \u0394z ) * collect ( 1 : Int ( h / \u0394z )) b = b0 .* ones ( mesh . n\u03be ) L = L0 .* ones ( mesh . n\u03be ) \u03c3 = \u03c30 .* ones ( mesh . n\u03be ) prop = ElasticRSFProperty ( a = a , b = b , L = L , \u03c3 = \u03c3 , \u03bb = \u03bb , \u03bc = \u03bc , vpl = vpl , f0 = f0 , v0 = v0 , \u03b7 = \u03b7 ); nothing Next, construct the initial condition and ODE problem using Okada's Green's function. 1 2 3 4 5 6 \u03c40 = \u03c30 * amax * asinh ( vinit / 2 v0 * exp (( f0 + b0 * log ( v0 / vinit )) / amax )) + \u03b7 * vinit \u03c4z = fill ( \u03c40 , size ( mesh . z )) \u03b8z = @ . L / v0 * exp ( a / b0 * log ( 2 v0 / vinit * sinh (( \u03c4z - \u03b7 * vinit ) / a / \u03c3 )) - f0 / b0 ) vz = fill ( vinit , size ( mesh . \u03be )) u0 = ArrayPartition ( vz , \u03b8z ) prob = assemble ( mesh , gf , prop , u0 , ( 0.0 , tf )); nothing Check our depth profile now. 1 plot ( a .- b , mesh . z , label = \"a - b\" , yflip = true , ylabel = \"Depth (km)\" ) -0.003 0.000 0.003 0.006 0.009 -40 -30 -20 -10 0 Depth (km) a - b Afterwards, solve ODE thanks to DifferentialEquations.jl 1 sol = solve ( prob , TsitPap8 (), reltol = 1e-6 , abstol = 1e-6 ); nothing Tip Raise the accuracy option or switch to other algorithms if you get instability when solving these ODEs. Finally, check the results. The first event happens at around 196 year: 1 2 maxv = max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , xlims = ( 190 , 200 ), label = \"\" ) 190.0 192.5 195.0 197.5 200.0 -8 -6 -4 -2 0 Time (year) Max Velocity (log10 (m/s)) Note Click here for the slip evolution over 3000 years simulation. It may need some time to load the page. This page was generated using Literate.jl .","title":"Example 1D"},{"location":"examples/generated/otfsync/","text":"Note This example is adapted from Wei, 2016 AGU Tip It will automatically use parallel scheme if nprocs() \u2242\u0338 1 when building stiffness tensor. To do so: 1 2 3 using Distributed addprocs ( 4 ); # add # of cores you desire @everywhere using JuEQ First, list all the essential parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 using JuEQ using Plots ms2mmyr = 365 * 86400 * 1e3 \u03c1 = 2670.0 # kg/m\u00b3 cs = 3044.0 # m/s vpl = 100.0 # mm/yr v0 = 3.2e4 # mm/yr f0 = 0.6 ; \u03bc = 0.3 # Bar\u00b7km/mm \u03bb = \u03bc # poisson material \u03b1 = ( \u03bb + \u03bc ) / ( \u03bb + 2 \u03bc ) \u03b7 = \u03bc / 2 ( cs * 1e-3 * 365 * 86400 ); nothing # Bar\u00b7yr/mm First, create a fault mesh, specify fault type and compute the Green's function. 1 2 3 ft = STRIKING () mesh = gen_mesh ( Val ( : RectOkada ), 80. , 10. , 0.5 , 0.5 , 90.0 ) gf = okada_stress_gf_tensor ( mesh , \u03bb , \u03bc , ft ; buffer_ratio = 1 ); nothing Next, establish frictional and fault space parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 a = ones ( mesh . nx , mesh . n\u03be ) .* 0.015 b = ones ( mesh . nx , mesh . n\u03be ) .* 0.0115 L = ones ( mesh . nx , mesh . n\u03be ) .* 12.0 left_patch = @ . - 25. \u2264 mesh . x \u2264 - 5. right_patch = @ . 5. \u2264 mesh . x \u2264 25. vert_patch = @ . - 6. \u2264 mesh . z \u2264 - 1 b [ xor . ( left_patch , right_patch ), vert_patch ] .= 0.0185 \u03c3max = 500. \u03c3 = [ min ( \u03c3max , 15. + 180. * z ) for z in - mesh . z ] \u03c3 = Matrix ( repeat ( \u03c3 , 1 , mesh . nx ) ' ) prop = ElasticRSFProperty ( a = a , b = b , L = L , \u03c3 = \u03c3 , \u03bb = \u03bb , \u03bc = \u03bc , vpl = vpl , f0 = f0 , v0 = v0 , \u03b7 = \u03b7 ); nothing Make sure our profile match our expectation: 1 2 3 4 5 6 7 8 9 10 11 12 13 p1 = plot (( a .- b ) ' , seriestype =: heatmap , xticks = ( collect ( 1 : 40 : mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"a-b\" , ); p2 = heatmap ( \u03c3 ' , xticks = ( collect ( 1 : 40 : mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \" \\\\ sigma\" ); plot ( p1 , p2 , layout = ( 2 , 1 )) -40 -20 0 20 40 0 5 10 15 20 a-b - 0.003 - 0.002 - 0.001 0 0.001 0.002 0.003 -40 -20 0 20 40 0 5 10 15 20 \u03c3 100 150 200 250 300 350 400 450 500 Then, provide the initial condition and assemble the ODEs: 1 2 3 4 vinit = vpl .* ones ( mesh . nx , mesh . n\u03be ) \u03b80 = L ./ vinit ./ 1.1 u0 = ArrayPartition ( vinit , \u03b80 ) prob = assemble ( mesh , gf , prop , u0 , ( 0. , 18. )); nothing Tip It is recommended (from Yajing Liu's personal communication) to add buffer zones adjacent the horizontal edges to immitate zero dislocation at the ridge region. Basically, it affects how the stiffness tensor are periodically summed. To what extent it alters the results remains further testing. Under the hood, it shall impose buffer areas on both sides of along-strike, each of which has a length of bufferratio/2*fa[:x] . Thus, the stiffness contributions falling into those buffer zone shall be neglected, which is equivalent to impose zero-slip correspondingly. Afterwards, solve ODEs problem: 1 sol = solve ( prob , VCABM5 (), reltol = 1e-5 , abstol = 1e-3 ); nothing Last, take a look at the max velocity time series: 1 2 maxv = JuEQ . max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , label = \"\" ) 0 5 10 15 -8 -7 -6 -5 -4 -3 -2 Time (year) Max Velocity (log10 (m/s)) And view some snapshots of ruptures (quasi-dynamic) patterns: 1 2 3 4 5 6 7 ind = argmax ( maxv ) myplot = ( ind ) -> heatmap ( log10 . ( sol . u [ ind ] . x [ 1 ] ./ ms2mmyr ) ' , xticks = ( collect ( 1 : 40 : mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"t = $ ( sol . t [ ind ]) \" ) snaps = myplot ( ind + 300 ) plot ( snaps ) -40 -20 0 20 40 0 5 10 15 20 t = 14.899140595654924 - 8.0 - 7.5 - 7.0 - 6.5 - 6.0 - 5.5 This page was generated using Literate.jl .","title":"Example 2D"}]}