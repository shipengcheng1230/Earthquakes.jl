{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JuEQ.jl Documentation \u00b6 Overview \u00b6 This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Law Boundary Element Method (Quasi-dynamic) Features to be implemented: Viscoelastic relaxation Fully elastodynamics Finite element method Installation \u00b6 Get the latest version with Julia's package manager: 1 ( v1 . 1 ) pkg > add https :// github . com / shipengcheng1230 / JuEQ . jl To load the package: 1 using JuEQ","title":"Home"},{"location":"#jueqjl-documentation","text":"","title":"JuEQ.jl Documentation"},{"location":"#overview","text":"This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Law Boundary Element Method (Quasi-dynamic) Features to be implemented: Viscoelastic relaxation Fully elastodynamics Finite element method","title":"Overview"},{"location":"#installation","text":"Get the latest version with Julia's package manager: 1 ( v1 . 1 ) pkg > add https :// github . com / shipengcheng1230 / JuEQ . jl To load the package: 1 using JuEQ","title":"Installation"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2018 Shi Pengcheng Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"private_interface/","text":"Private Interface \u00b6 Index \u00b6 JuEQ.parameters JuEQ.LineOkadaMesh JuEQ.OkadaFaultSpace JuEQ.OkadaGFAllocFFTConv JuEQ.OkadaGFAllocMatrix JuEQ.RectOkadaMesh JuEQ.SBarbotHex8MeshEntity JuEQ.SBarbotTet4MeshEntity JuEQ.dv_dt JuEQ.dv_d\u03b8_dt JuEQ.dv_d\u03b8_dt! JuEQ.d\u03c4_dt JuEQ.d\u03c4_dt! JuEQ.d\u03c4_dt! JuEQ.geo_box_extruded_from_surfaceXY JuEQ.geo_line JuEQ.geo_okada_line JuEQ.geo_okada_rect JuEQ.geo_rect_x JuEQ.okada_gf_periodic_bc! JuEQ.@gen_shared_chunk_call Interfaces \u00b6 # JuEQ.LineOkadaMesh \u2014 Type . Generate a uniform line mesh in accordance with dc3d usage, i.e the line sits at y-z plane, started from (0, 0, 0) and extended into negative half space. # JuEQ.OkadaFaultSpace \u2014 Type . Okada fault space encapsulating mesh and fault type # JuEQ.OkadaGFAllocFFTConv \u2014 Type . Allocation for computing stress rate in 2-D elastic fault. # JuEQ.OkadaGFAllocMatrix \u2014 Type . Allocation for computing stress rate in 1-D elastic fault. # JuEQ.RectOkadaMesh \u2014 Type . Generate a uniform rectangular mesh in accordance with dc3d usage, i.e the rectangular sits parallel to x-axis, top edge starts from z = 0 and centered at x = 0. The geometry extends into negative half space and rotate around the pivot of (y=0, z=0). # JuEQ.SBarbotHex8MeshEntity \u2014 Type . Mesh entities of Hex8 for using strain-stress green's function. source # JuEQ.SBarbotTet4MeshEntity \u2014 Type . Mesh entities of Tet4 for using strain-stress green's function. source # JuEQ.dv_dt \u2014 Method . Derivative of velocity in quai-dynamic rate-and-state governing equation. # JuEQ.dv_d\u03b8_dt! \u2014 Method . In-place version of derivative of velocity and state for a block of fault patches. This only supports single state variable. # JuEQ.dv_d\u03b8_dt \u2014 Method . Out-place version of derivative of velocity (or you may call it slip rate) and state (the state in rate-and-state friction) for single degree of freedom system. This for now only support single state variable, which is most-widely used. # JuEQ.d\u03c4_dt! \u2014 Method . Stress rate in 1-D elastic plane. # JuEQ.d\u03c4_dt! \u2014 Method . Stress rate in 2-D elastic plane. Using FFT to convolving translational symmetric tensor. # JuEQ.d\u03c4_dt \u2014 Method . Just Hook's law. # JuEQ.geo_box_extruded_from_surfaceXY \u2014 Method . Code snippet for adding box extruded from surface (x-y \u2191 z). # JuEQ.geo_line \u2014 Method . Code snippet for adding a line from (x, y, z) -> (x+dx, y+dy, z+dz). # JuEQ.geo_okada_line \u2014 Method . Code snippet for adding LineOkadaMesh . # JuEQ.geo_okada_rect \u2014 Method . Code snippet for adding RectOkadaMesh . # JuEQ.geo_rect_x \u2014 Method . Code snippet for adding a rectangular parallel to x-axis with topleft at (x, y, z), length of dx and width of hypot(dy, dz) . # JuEQ.okada_gf_periodic_bc! \u2014 Method . Periodic summation of green's function. lrept represents jumping periodic block for simulating locked region at along-strike edge. nrept represents number of blocks to be summed. # JuEQ.parameters \u2014 Constant . Global settings. # JuEQ.@gen_shared_chunk_call \u2014 Macro . A general pattern parallel SharedArray computation. See here for an example.","title":"Private"},{"location":"private_interface/#private-interface","text":"","title":"Private Interface"},{"location":"private_interface/#index","text":"JuEQ.parameters JuEQ.LineOkadaMesh JuEQ.OkadaFaultSpace JuEQ.OkadaGFAllocFFTConv JuEQ.OkadaGFAllocMatrix JuEQ.RectOkadaMesh JuEQ.SBarbotHex8MeshEntity JuEQ.SBarbotTet4MeshEntity JuEQ.dv_dt JuEQ.dv_d\u03b8_dt JuEQ.dv_d\u03b8_dt! JuEQ.d\u03c4_dt JuEQ.d\u03c4_dt! JuEQ.d\u03c4_dt! JuEQ.geo_box_extruded_from_surfaceXY JuEQ.geo_line JuEQ.geo_okada_line JuEQ.geo_okada_rect JuEQ.geo_rect_x JuEQ.okada_gf_periodic_bc! JuEQ.@gen_shared_chunk_call","title":"Index"},{"location":"private_interface/#interfaces","text":"# JuEQ.LineOkadaMesh \u2014 Type . Generate a uniform line mesh in accordance with dc3d usage, i.e the line sits at y-z plane, started from (0, 0, 0) and extended into negative half space. # JuEQ.OkadaFaultSpace \u2014 Type . Okada fault space encapsulating mesh and fault type # JuEQ.OkadaGFAllocFFTConv \u2014 Type . Allocation for computing stress rate in 2-D elastic fault. # JuEQ.OkadaGFAllocMatrix \u2014 Type . Allocation for computing stress rate in 1-D elastic fault. # JuEQ.RectOkadaMesh \u2014 Type . Generate a uniform rectangular mesh in accordance with dc3d usage, i.e the rectangular sits parallel to x-axis, top edge starts from z = 0 and centered at x = 0. The geometry extends into negative half space and rotate around the pivot of (y=0, z=0). # JuEQ.SBarbotHex8MeshEntity \u2014 Type . Mesh entities of Hex8 for using strain-stress green's function. source # JuEQ.SBarbotTet4MeshEntity \u2014 Type . Mesh entities of Tet4 for using strain-stress green's function. source # JuEQ.dv_dt \u2014 Method . Derivative of velocity in quai-dynamic rate-and-state governing equation. # JuEQ.dv_d\u03b8_dt! \u2014 Method . In-place version of derivative of velocity and state for a block of fault patches. This only supports single state variable. # JuEQ.dv_d\u03b8_dt \u2014 Method . Out-place version of derivative of velocity (or you may call it slip rate) and state (the state in rate-and-state friction) for single degree of freedom system. This for now only support single state variable, which is most-widely used. # JuEQ.d\u03c4_dt! \u2014 Method . Stress rate in 1-D elastic plane. # JuEQ.d\u03c4_dt! \u2014 Method . Stress rate in 2-D elastic plane. Using FFT to convolving translational symmetric tensor. # JuEQ.d\u03c4_dt \u2014 Method . Just Hook's law. # JuEQ.geo_box_extruded_from_surfaceXY \u2014 Method . Code snippet for adding box extruded from surface (x-y \u2191 z). # JuEQ.geo_line \u2014 Method . Code snippet for adding a line from (x, y, z) -> (x+dx, y+dy, z+dz). # JuEQ.geo_okada_line \u2014 Method . Code snippet for adding LineOkadaMesh . # JuEQ.geo_okada_rect \u2014 Method . Code snippet for adding RectOkadaMesh . # JuEQ.geo_rect_x \u2014 Method . Code snippet for adding a rectangular parallel to x-axis with topleft at (x, y, z), length of dx and width of hypot(dy, dz) . # JuEQ.okada_gf_periodic_bc! \u2014 Method . Periodic summation of green's function. lrept represents jumping periodic block for simulating locked region at along-strike edge. nrept represents number of blocks to be summed. # JuEQ.parameters \u2014 Constant . Global settings. # JuEQ.@gen_shared_chunk_call \u2014 Macro . A general pattern parallel SharedArray computation. See here for an example.","title":"Interfaces"},{"location":"public_interface/","text":"Public Interface \u00b6 Index \u00b6 JuEQ.CForm JuEQ.DIPPING JuEQ.DieterichStateLaw JuEQ.ElasticRSFProperty JuEQ.PrzStateLaw JuEQ.RForm JuEQ.RuinaStateLaw JuEQ.STRIKING JuEQ.SingleDofRSFProperty JuEQ.StateEvolutionLaw JuEQ.assemble JuEQ.assemble JuEQ.assemble JuEQ.dc3d JuEQ.fault JuEQ.fault JuEQ.friction JuEQ.gen_alloc JuEQ.gen_alloc JuEQ.gen_gmsh_mesh JuEQ.gen_gmsh_mesh JuEQ.gen_gmsh_mesh JuEQ.gen_gmsh_mesh JuEQ.gen_mesh JuEQ.gen_mesh JuEQ.indice2tag JuEQ.indice2tag JuEQ.max_velocity JuEQ.mmapsave JuEQ.okada_disp_gf_tensor JuEQ.okada_disp_gf_tensor JuEQ.read_gmsh_mesh JuEQ.read_gmsh_mesh JuEQ.save_prop JuEQ.sbarbot_disp_hex8! JuEQ.sbarbot_disp_tet4! JuEQ.@h5savecallback JuEQ.@read_prop JuEQ.@save_prop Interfaces \u00b6 # JuEQ.CForm \u2014 Type . Conventional form, see friction # JuEQ.DIPPING \u2014 Type . Dipping, indicate dislocation occurs at y-z plane in dc3d use. # JuEQ.DieterichStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}$ # JuEQ.ElasticRSFProperty \u2014 Type . System property for multiple fault patches under rate-state friction. a : contrib from velocity b : contrib from state L : critical distance \u03c3 : effective normal stress \u03bb : Lam\u00e9 first constants \u03bc : Lam\u00e9 second constants \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # JuEQ.PrzStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - (\\frac{V \u03b8}{2L})^2$ # JuEQ.RForm \u2014 Type . Regularized form, see friction # JuEQ.RuinaStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\frac{V \u03b8}{L}}$ # JuEQ.STRIKING \u2014 Type . Striking, indicate dislocation occurs at x-direction in dc3d use. # JuEQ.SingleDofRSFProperty \u2014 Type . System property for single degree of freedom under rate-state friction. a : contrib from velocity b : contrib from state L : critical distance k : spring stiffness \u03c3 : effective normal stress \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # JuEQ.StateEvolutionLaw \u2014 Type . Currently support: DieterichStateLaw RuinaStateLaw PrzStateLaw # JuEQ.assemble \u2014 Method . Assemble the homogeneous elastic system, given green's function gf::AbstractArray without recomputing. # JuEQ.assemble \u2014 Method . 1 assemble ( fs :: OkadaFaultSpace , p :: ElasticRSFProperty , u0 :: AbstractArray , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (), kwargs ... ) Assemble the ODEProblem for elastic fault using okada's green's function. Arguments fs::OkadaFaultSpace : fault space containing fault plane mesh and fault type p::ElasticRSFProperty : all system properties u0::AbstractArray : initial condition tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # JuEQ.assemble \u2014 Method . 1 assemble ( p :: SingleDofRSFProperty , u0 :: AbstractArray , tspan :: NTuple ; flf :: FrictionLawForm = CForm (), se :: StateEvolutionLaw = DieterichStateLaw ()) Assemble the ODEProblem for single degree of freedom system. Arguments p::SingleDofRSFProperty : all system properties u0::AbstractArray : initial condition tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # JuEQ.dc3d \u2014 Method . Calculate displacements and gradient of displacements due to a dislocation in an elastic isotropic halfspace. See dc3d for details. test/test_okada.dat is obtained using DC3dfortran An example wrapper for DC3D in julia as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function dc3d_fortran ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al1 :: T , al2 :: T , aw1 :: T , aw2 :: T , disl1 :: T , disl2 :: T , disl3 :: T ) where { T <: AbstractFloat } # initial return values # `RefValue{T}` may be also viable other than `Array{T, 1}` ux = Array { Float64 }( 1 ) uy = Array { Float64 }( 1 ) uz = Array { Float64 }( 1 ) uxx = Array { Float64 }( 1 ) uyx = Array { Float64 }( 1 ) uzx = Array { Float64 }( 1 ) uxy = Array { Float64 }( 1 ) uyy = Array { Float64 }( 1 ) uzy = Array { Float64 }( 1 ) uxz = Array { Float64 }( 1 ) uyz = Array { Float64 }( 1 ) uzz = Array { Float64 }( 1 ) iret = Array { Int64 }( 1 ) # call okada's code which is renamed as \"__dc3d__\" (see binding rename shown below) # input args tuple must be syntactically written instead of a variable assigned # macros could be used to simplify this in the future ccall (( : __dc3d__ , \"dc3d.so\" ), Void , ( Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ref { Int64 }, ), \u03b1 , x , y , z , dep , dip , al1 , al2 , aw1 , aw2 , disl1 , disl2 , disl3 , ux , uy , uz , uxx , uyx , uzx , uxy , uyy , uzy , uxz , uyz , uzz , iret , ) # results valid iff iret[1] == 0 return ( iret [ 1 ], ux [ 1 ], uy [ 1 ], uz [ 1 ], uxx [ 1 ], uyx [ 1 ], uzx [ 1 ], uxy [ 1 ], uyy [ 1 ], uzy [ 1 ], uxz [ 1 ], uyz [ 1 ], uzz [ 1 ] ) end The corresponding fortran module is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 MODULE okada USE , INTRINSIC :: iso_c_binding IMPLICIT NONE CONTAINS SUBROUTINE dc3d_wrapper (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) BIND ( C , NAME = '__dc3d__' ) REAL * 8 :: & & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz INTEGER * 8 :: iret CALL dc3d (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) END SUBROUTINE dc3d_wrapper END MODULE okada A sample of makefile is as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Build Okada's code for calculating deformation due to a fault model # CC = gfortran CFLAGS = -fPIC -w -O3 LDFLAGS = -shared SRCS = dc3d.f okada.f90 OBJS = $( SRCS:.c = .o ) TARGET = dc3d.so $(TARGET) : $( OBJS ) $( CC ) $( CFLAGS ) $( LDFLAGS ) -o $( TARGET ) $( OBJS ) # JuEQ.fault \u2014 Method . Generate fault space encapsulating LineOkadaMesh and fault type ft . # JuEQ.fault \u2014 Method . Generate fault space encapsulating RectOkadaMesh and fault type ft . # JuEQ.friction \u2014 Method . 1 friction ( :: FrictionLawForm , v :: T , \u03b8 :: T , L :: T , a :: T , b :: T , f0 :: T , v0 :: T ) where { T <: Number } Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} # JuEQ.gen_alloc \u2014 Method . Generate 1-D computation allocation for computing stress rate. # JuEQ.gen_alloc \u2014 Method . Generate 2-D computation allocation for computing stress rate. # JuEQ.gen_gmsh_mesh \u2014 Method . Adding a combination of RectOkadaMesh and BoxHexExtrudeFromSurface mesh for asthenosphere. # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 3 4 gen_gmsh_mesh ( :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Gernate a box for Asthenosphere using 8-node hexahedron elements (via setting transfinite curve). Arguments llx , lly , llz : coordinates of low-left corner on the top surface dx , dy , dz : x-, y-, z-extension nx , ny : number of cells along x-, y-axis rfx , rfy : refinement coefficients along x-, y-axis using [\"Bump\"] algorithm, please refer gmsh.model.geo.mesh.setTransfiniteCurve rfzn : number of cells along z-axis, please refer numElements in gmsh.model.geo.extrude rfzh : accumulated height of cells along z-axis, please refer heights in gmsh.model.geo.extrude # JuEQ.gen_gmsh_mesh \u2014 Method . Generate equivalent LineTopCenterMesh via Gmsh buildin engine. # JuEQ.gen_gmsh_mesh \u2014 Method . Generate equivalent RectTopCenterMesh via Gmsh buildin engine. # JuEQ.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ) Generate LineOkadaMesh Arguments \u03be : downdip length \u0394\u03be : downdip interval dip : dipping angle # JuEQ.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ) Generate RectOkadaMesh Arguments x : along strike length \u03be : downdip length \u0394x : along strike interval \u0394\u03be : downdip interval dip : dipping angle # JuEQ.indice2tag \u2014 Method . Compute [i] => tag from LineOkadaMesh to unstructured mesh file. # JuEQ.indice2tag \u2014 Method . Compute [i,j] => tag from RectOkadaMesh to unstructured mesh file. # JuEQ.max_velocity \u2014 Method . 1 max_velocity ( t :: AbstractVector , u :: AbstractArray , getu :: Function ) Return max velocity across the fault at each time step. A number of convenient interfaces for common output are implemented. Arguments t::AbstractVector : vector of time steps u::AbstractArray : array of solution getu::Function : method for retrieving velocity section at each time step # JuEQ.mmapsave \u2014 Method . 1 DECallbackSaveToFile ( iot :: IOStream , iou :: IOStream ) Construct a functional callback to write ODESolution ( t & u ) into file. The reason to separate t and u is for more easily reshape u w.r.t grids specification. It right now falls on users' memory on what the type of solution is for accurately retrieving results. Arguments iot::IOStream : stream pointing to solution of time iou::IOStream : stream pointing to solution of domain Note It is strongly not recommended to use \"skipping\" scheme (by defining thrd and dts(a) for each case) when solution is too oscillated. # JuEQ.okada_disp_gf_tensor \u2014 Method . Okada green's function in 1-D elastic fault in LineOkadaMesh . # JuEQ.okada_disp_gf_tensor \u2014 Method . Okada green's function in 2-D elastic fault in RectOkadaMesh . Translational symmetry is considered. # JuEQ.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : SBarbotHex8 }, f :: AbstractString ; phytag :: Integer =- 1 , rotate :: Number = 0.0 , reverse = false , check = false ) Read the mesh and construct mesh entity infomation for SBarbot Hex8 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If < 0, retrieve all elements in all 3-dimensional entities. rotate : the angle of strike direction, see sbarbot_disp_hex8! reverse : if true , reverse the along-x, y-node tag during read. By default, 1\u21924 in x-axis, 1\u21922 in y-axis, 1\u21925 in z-axis check : if true , check that number of distinctive q1 equals that of x1 , same for q2 and x2 at orthogonal direction, which should hold for transfinite mesh. Notice This function can only be used for Hex8 element with each element lying parallel to z-axis. The check procedure is not complete for arbitrary strike angle (0 < \u03b8 < 90). The user should take a close look on the node ordering for one element to ensure the x-, y-extent are correctly resolved by change reverse accordingly. # JuEQ.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : SBarbotTet4 }, f :: AbstractString ; phytag :: Integer =- 1 ) Read the mesh and construct mesh entity infomation for SBarbot Tet4 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If < 0, retrieve all elements in all 3-dimensional entities. # JuEQ.save_prop \u2014 Method . Store property in HDF5. # JuEQ.sbarbot_disp_hex8! \u2014 Method . copyright: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 https://bitbucket.org/sbarbot N (x1) / /| strike (theta) E (x2) q1,q2,q3 ->@--------------------------+ | w | + | i | / | d | / s | t | / s | h | / e | |/ n +--------------------------+ k : l e n g t h / c | / i : / h | / t : / | + Z (x3) # JuEQ.sbarbot_disp_tet4! \u2014 Method . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 / North ( x1 ) / surface / -------------+-------------- East ( x2 ) /| / | + A / | / . | / . | / . | / . |/ + B / . | /| / | / : . | / | / | / : . | / /| | / . : | +------|---------------+ C : D # JuEQ.@h5savecallback \u2014 Macro . 1 @h5savecallback ( filename , tend , nsteps , usize , T ) Construct a FunctionCallingCallback for incrementally stored output into HDF5 file. It is suggested to use this macro at top-level scope since it contains eval . Arguments filename : file name to be stored tend : end time of simulation nsteps : after nsteps steps, a saving operation is performed otherwise caching them T : type of stored data # JuEQ.@read_prop \u2014 Macro . Read property stored in HDF5. # JuEQ.@save_prop \u2014 Macro . Store property in HDF5.","title":"Public"},{"location":"public_interface/#public-interface","text":"","title":"Public Interface"},{"location":"public_interface/#index","text":"JuEQ.CForm JuEQ.DIPPING JuEQ.DieterichStateLaw JuEQ.ElasticRSFProperty JuEQ.PrzStateLaw JuEQ.RForm JuEQ.RuinaStateLaw JuEQ.STRIKING JuEQ.SingleDofRSFProperty JuEQ.StateEvolutionLaw JuEQ.assemble JuEQ.assemble JuEQ.assemble JuEQ.dc3d JuEQ.fault JuEQ.fault JuEQ.friction JuEQ.gen_alloc JuEQ.gen_alloc JuEQ.gen_gmsh_mesh JuEQ.gen_gmsh_mesh JuEQ.gen_gmsh_mesh JuEQ.gen_gmsh_mesh JuEQ.gen_mesh JuEQ.gen_mesh JuEQ.indice2tag JuEQ.indice2tag JuEQ.max_velocity JuEQ.mmapsave JuEQ.okada_disp_gf_tensor JuEQ.okada_disp_gf_tensor JuEQ.read_gmsh_mesh JuEQ.read_gmsh_mesh JuEQ.save_prop JuEQ.sbarbot_disp_hex8! JuEQ.sbarbot_disp_tet4! JuEQ.@h5savecallback JuEQ.@read_prop JuEQ.@save_prop","title":"Index"},{"location":"public_interface/#interfaces","text":"# JuEQ.CForm \u2014 Type . Conventional form, see friction # JuEQ.DIPPING \u2014 Type . Dipping, indicate dislocation occurs at y-z plane in dc3d use. # JuEQ.DieterichStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}$ # JuEQ.ElasticRSFProperty \u2014 Type . System property for multiple fault patches under rate-state friction. a : contrib from velocity b : contrib from state L : critical distance \u03c3 : effective normal stress \u03bb : Lam\u00e9 first constants \u03bc : Lam\u00e9 second constants \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # JuEQ.PrzStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - (\\frac{V \u03b8}{2L})^2$ # JuEQ.RForm \u2014 Type . Regularized form, see friction # JuEQ.RuinaStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\frac{V \u03b8}{L}}$ # JuEQ.STRIKING \u2014 Type . Striking, indicate dislocation occurs at x-direction in dc3d use. # JuEQ.SingleDofRSFProperty \u2014 Type . System property for single degree of freedom under rate-state friction. a : contrib from velocity b : contrib from state L : critical distance k : spring stiffness \u03c3 : effective normal stress \u03b7 : radiation damping vpl : plate rate f0 = 0.6: ref. frictional coeff v0 = 1e-6: ref. velocity source # JuEQ.StateEvolutionLaw \u2014 Type . Currently support: DieterichStateLaw RuinaStateLaw PrzStateLaw # JuEQ.assemble \u2014 Method . Assemble the homogeneous elastic system, given green's function gf::AbstractArray without recomputing. # JuEQ.assemble \u2014 Method . 1 assemble ( fs :: OkadaFaultSpace , p :: ElasticRSFProperty , u0 :: AbstractArray , tspan :: NTuple { 2 }; flf :: FrictionLawForm = RForm (), se :: StateEvolutionLaw = DieterichStateLaw (), kwargs ... ) Assemble the ODEProblem for elastic fault using okada's green's function. Arguments fs::OkadaFaultSpace : fault space containing fault plane mesh and fault type p::ElasticRSFProperty : all system properties u0::AbstractArray : initial condition tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # JuEQ.assemble \u2014 Method . 1 assemble ( p :: SingleDofRSFProperty , u0 :: AbstractArray , tspan :: NTuple ; flf :: FrictionLawForm = CForm (), se :: StateEvolutionLaw = DieterichStateLaw ()) Assemble the ODEProblem for single degree of freedom system. Arguments p::SingleDofRSFProperty : all system properties u0::AbstractArray : initial condition tspan::NTuple : time span for simulation flf::FrictionLawForm : form of friction law, either CForm or RForm se::StateEvolutionLaw : state evolutional law, see StateEvolutionLaw # JuEQ.dc3d \u2014 Method . Calculate displacements and gradient of displacements due to a dislocation in an elastic isotropic halfspace. See dc3d for details. test/test_okada.dat is obtained using DC3dfortran An example wrapper for DC3D in julia as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function dc3d_fortran ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al1 :: T , al2 :: T , aw1 :: T , aw2 :: T , disl1 :: T , disl2 :: T , disl3 :: T ) where { T <: AbstractFloat } # initial return values # `RefValue{T}` may be also viable other than `Array{T, 1}` ux = Array { Float64 }( 1 ) uy = Array { Float64 }( 1 ) uz = Array { Float64 }( 1 ) uxx = Array { Float64 }( 1 ) uyx = Array { Float64 }( 1 ) uzx = Array { Float64 }( 1 ) uxy = Array { Float64 }( 1 ) uyy = Array { Float64 }( 1 ) uzy = Array { Float64 }( 1 ) uxz = Array { Float64 }( 1 ) uyz = Array { Float64 }( 1 ) uzz = Array { Float64 }( 1 ) iret = Array { Int64 }( 1 ) # call okada's code which is renamed as \"__dc3d__\" (see binding rename shown below) # input args tuple must be syntactically written instead of a variable assigned # macros could be used to simplify this in the future ccall (( : __dc3d__ , \"dc3d.so\" ), Void , ( Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ref { Int64 }, ), \u03b1 , x , y , z , dep , dip , al1 , al2 , aw1 , aw2 , disl1 , disl2 , disl3 , ux , uy , uz , uxx , uyx , uzx , uxy , uyy , uzy , uxz , uyz , uzz , iret , ) # results valid iff iret[1] == 0 return ( iret [ 1 ], ux [ 1 ], uy [ 1 ], uz [ 1 ], uxx [ 1 ], uyx [ 1 ], uzx [ 1 ], uxy [ 1 ], uyy [ 1 ], uzy [ 1 ], uxz [ 1 ], uyz [ 1 ], uzz [ 1 ] ) end The corresponding fortran module is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 MODULE okada USE , INTRINSIC :: iso_c_binding IMPLICIT NONE CONTAINS SUBROUTINE dc3d_wrapper (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) BIND ( C , NAME = '__dc3d__' ) REAL * 8 :: & & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz INTEGER * 8 :: iret CALL dc3d (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) END SUBROUTINE dc3d_wrapper END MODULE okada A sample of makefile is as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Build Okada's code for calculating deformation due to a fault model # CC = gfortran CFLAGS = -fPIC -w -O3 LDFLAGS = -shared SRCS = dc3d.f okada.f90 OBJS = $( SRCS:.c = .o ) TARGET = dc3d.so $(TARGET) : $( OBJS ) $( CC ) $( CFLAGS ) $( LDFLAGS ) -o $( TARGET ) $( OBJS ) # JuEQ.fault \u2014 Method . Generate fault space encapsulating LineOkadaMesh and fault type ft . # JuEQ.fault \u2014 Method . Generate fault space encapsulating RectOkadaMesh and fault type ft . # JuEQ.friction \u2014 Method . 1 friction ( :: FrictionLawForm , v :: T , \u03b8 :: T , L :: T , a :: T , b :: T , f0 :: T , v0 :: T ) where { T <: Number } Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} # JuEQ.gen_alloc \u2014 Method . Generate 1-D computation allocation for computing stress rate. # JuEQ.gen_alloc \u2014 Method . Generate 2-D computation allocation for computing stress rate. # JuEQ.gen_gmsh_mesh \u2014 Method . Adding a combination of RectOkadaMesh and BoxHexExtrudeFromSurface mesh for asthenosphere. # JuEQ.gen_gmsh_mesh \u2014 Method . 1 2 3 4 gen_gmsh_mesh ( :: Val { : BoxHexByExtrude }, llx :: T , lly :: T , llz :: T , dx :: T , dy :: T , dz :: T , nx :: I , ny :: I , rfx :: T , rfy :: T , rfzn :: AbstractVector , rfzh :: AbstractVector ; filename :: AbstractString = \"temp.msh\" ) where { T , I } Gernate a box for Asthenosphere using 8-node hexahedron elements (via setting transfinite curve). Arguments llx , lly , llz : coordinates of low-left corner on the top surface dx , dy , dz : x-, y-, z-extension nx , ny : number of cells along x-, y-axis rfx , rfy : refinement coefficients along x-, y-axis using [\"Bump\"] algorithm, please refer gmsh.model.geo.mesh.setTransfiniteCurve rfzn : number of cells along z-axis, please refer numElements in gmsh.model.geo.extrude rfzh : accumulated height of cells along z-axis, please refer heights in gmsh.model.geo.extrude # JuEQ.gen_gmsh_mesh \u2014 Method . Generate equivalent LineTopCenterMesh via Gmsh buildin engine. # JuEQ.gen_gmsh_mesh \u2014 Method . Generate equivalent RectTopCenterMesh via Gmsh buildin engine. # JuEQ.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : LineOkada }, \u03be :: T , \u0394\u03be :: T , dip :: T ) Generate LineOkadaMesh Arguments \u03be : downdip length \u0394\u03be : downdip interval dip : dipping angle # JuEQ.gen_mesh \u2014 Method . 1 gen_mesh ( :: Val { : RectOkada }, x :: T , \u03be :: T , \u0394x :: T , \u0394\u03be :: T , dip :: T ) Generate RectOkadaMesh Arguments x : along strike length \u03be : downdip length \u0394x : along strike interval \u0394\u03be : downdip interval dip : dipping angle # JuEQ.indice2tag \u2014 Method . Compute [i] => tag from LineOkadaMesh to unstructured mesh file. # JuEQ.indice2tag \u2014 Method . Compute [i,j] => tag from RectOkadaMesh to unstructured mesh file. # JuEQ.max_velocity \u2014 Method . 1 max_velocity ( t :: AbstractVector , u :: AbstractArray , getu :: Function ) Return max velocity across the fault at each time step. A number of convenient interfaces for common output are implemented. Arguments t::AbstractVector : vector of time steps u::AbstractArray : array of solution getu::Function : method for retrieving velocity section at each time step # JuEQ.mmapsave \u2014 Method . 1 DECallbackSaveToFile ( iot :: IOStream , iou :: IOStream ) Construct a functional callback to write ODESolution ( t & u ) into file. The reason to separate t and u is for more easily reshape u w.r.t grids specification. It right now falls on users' memory on what the type of solution is for accurately retrieving results. Arguments iot::IOStream : stream pointing to solution of time iou::IOStream : stream pointing to solution of domain Note It is strongly not recommended to use \"skipping\" scheme (by defining thrd and dts(a) for each case) when solution is too oscillated. # JuEQ.okada_disp_gf_tensor \u2014 Method . Okada green's function in 1-D elastic fault in LineOkadaMesh . # JuEQ.okada_disp_gf_tensor \u2014 Method . Okada green's function in 2-D elastic fault in RectOkadaMesh . Translational symmetry is considered. # JuEQ.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : SBarbotHex8 }, f :: AbstractString ; phytag :: Integer =- 1 , rotate :: Number = 0.0 , reverse = false , check = false ) Read the mesh and construct mesh entity infomation for SBarbot Hex8 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If < 0, retrieve all elements in all 3-dimensional entities. rotate : the angle of strike direction, see sbarbot_disp_hex8! reverse : if true , reverse the along-x, y-node tag during read. By default, 1\u21924 in x-axis, 1\u21922 in y-axis, 1\u21925 in z-axis check : if true , check that number of distinctive q1 equals that of x1 , same for q2 and x2 at orthogonal direction, which should hold for transfinite mesh. Notice This function can only be used for Hex8 element with each element lying parallel to z-axis. The check procedure is not complete for arbitrary strike angle (0 < \u03b8 < 90). The user should take a close look on the node ordering for one element to ensure the x-, y-extent are correctly resolved by change reverse accordingly. # JuEQ.read_gmsh_mesh \u2014 Method . 1 read_gmsh_mesh ( :: Val { : SBarbotTet4 }, f :: AbstractString ; phytag :: Integer =- 1 ) Read the mesh and construct mesh entity infomation for SBarbot Tet4 Green's function use. Arguments f : mesh file name phytag : physical tag for targeting volume entity. If < 0, retrieve all elements in all 3-dimensional entities. # JuEQ.save_prop \u2014 Method . Store property in HDF5. # JuEQ.sbarbot_disp_hex8! \u2014 Method . copyright: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 https://bitbucket.org/sbarbot N (x1) / /| strike (theta) E (x2) q1,q2,q3 ->@--------------------------+ | w | + | i | / | d | / s | t | / s | h | / e | |/ n +--------------------------+ k : l e n g t h / c | / i : / h | / t : / | + Z (x3) # JuEQ.sbarbot_disp_tet4! \u2014 Method . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 / North ( x1 ) / surface / -------------+-------------- East ( x2 ) /| / | + A / | / . | / . | / . | / . |/ + B / . | /| / | / : . | / | / | / : . | / /| | / . : | +------|---------------+ C : D # JuEQ.@h5savecallback \u2014 Macro . 1 @h5savecallback ( filename , tend , nsteps , usize , T ) Construct a FunctionCallingCallback for incrementally stored output into HDF5 file. It is suggested to use this macro at top-level scope since it contains eval . Arguments filename : file name to be stored tend : end time of simulation nsteps : after nsteps steps, a saving operation is performed otherwise caching them T : type of stored data # JuEQ.@read_prop \u2014 Macro . Read property stored in HDF5. # JuEQ.@save_prop \u2014 Macro . Store property in HDF5.","title":"Interfaces"},{"location":"quasi_dynamic_intro/","text":"Quasi-dynamic Simulation using BEM \u00b6 Basic Theory \u00b6 The governing equation is that at every time step, shear stress across the fault plane equals to frictional force plus a radiation damping term for approximating wave propagation effect: \u03c4 = \u03c3f + \u03b7V Here $\u03bc$ is shear stress across the fault plain. Using Okada's dislocation theory , it can be shown as: \u03c4 = \\mathrm{K} \u2297 \u03b4 where $\\mathrm{K}$ is the so-called stiffness tensor, depicting relationship between displacements at one position regarding to dislocations somewhere else. $\u03b4$ is the dislocation, i.e. displacement at everywhere on the fault. $\u2297$ denotes tensor contraction. Back to $f$, we use rate-and-state frictional law to calculate its value, specifically as below: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} where $f_0$ and $V_0$ are reference friction coefficient and velocity, $V$ and $\u03b8$ are velocity and state variable based on which frictional force is. $a$ and $b$ are two frictional parameters denoting contributions each of which comes from velocity and state variable respectively. $L$ is critical distance after which frictional force return to new steady state. Sometimes people use regularized form to avoid infinity when $V \u2248 0$, namely: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} There are many state evolution law that describes how state variable $\u03b8$ changes with time, one of which that most widely used is Dieterich law: \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} Further, $\u03b7$ is a damping coefficient whose value is often chosen as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity and $\u03c3$ is the effective normal stress. To simulate how fault evolves with time, we then take the derivative of the governing equation: \\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\frac{\\mathrm{d} f(V, \u03b8)}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\mathrm{d} f}{\\mathrm{d} V} \\frac{\\mathrm{d} V}{\\mathrm{d} t} + \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} Thus we arrive at: \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} - \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t}}{\\frac{\\mathrm{d} f}{\\mathrm{d} V} + \u03b7} where $\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\mathrm{K} \u2297 (\\mathrm{V_{pl}} - V)$ where $\\mathrm{V_{pl}}$ is the plate rate. Note The direction of relative velocity, namely $\\mathrm{V_{pl} - V}$, must be in accordance to the direction of $\\mathrm{K}$ which, here, we use the same meaning as Rice, J. (1993). Hence, with both derivatives of velocity $V$ and state variable $\u03b8$, we are able to discover how fault evolves with various parameters settings.","title":"Basic Theory"},{"location":"quasi_dynamic_intro/#quasi-dynamic-simulation-using-bem","text":"","title":"Quasi-dynamic Simulation using BEM"},{"location":"quasi_dynamic_intro/#basic-theory","text":"The governing equation is that at every time step, shear stress across the fault plane equals to frictional force plus a radiation damping term for approximating wave propagation effect: \u03c4 = \u03c3f + \u03b7V Here $\u03bc$ is shear stress across the fault plain. Using Okada's dislocation theory , it can be shown as: \u03c4 = \\mathrm{K} \u2297 \u03b4 where $\\mathrm{K}$ is the so-called stiffness tensor, depicting relationship between displacements at one position regarding to dislocations somewhere else. $\u03b4$ is the dislocation, i.e. displacement at everywhere on the fault. $\u2297$ denotes tensor contraction. Back to $f$, we use rate-and-state frictional law to calculate its value, specifically as below: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} where $f_0$ and $V_0$ are reference friction coefficient and velocity, $V$ and $\u03b8$ are velocity and state variable based on which frictional force is. $a$ and $b$ are two frictional parameters denoting contributions each of which comes from velocity and state variable respectively. $L$ is critical distance after which frictional force return to new steady state. Sometimes people use regularized form to avoid infinity when $V \u2248 0$, namely: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} There are many state evolution law that describes how state variable $\u03b8$ changes with time, one of which that most widely used is Dieterich law: \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} Further, $\u03b7$ is a damping coefficient whose value is often chosen as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity and $\u03c3$ is the effective normal stress. To simulate how fault evolves with time, we then take the derivative of the governing equation: \\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\frac{\\mathrm{d} f(V, \u03b8)}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\mathrm{d} f}{\\mathrm{d} V} \\frac{\\mathrm{d} V}{\\mathrm{d} t} + \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} Thus we arrive at: \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} - \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t}}{\\frac{\\mathrm{d} f}{\\mathrm{d} V} + \u03b7} where $\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\mathrm{K} \u2297 (\\mathrm{V_{pl}} - V)$ where $\\mathrm{V_{pl}}$ is the plate rate. Note The direction of relative velocity, namely $\\mathrm{V_{pl} - V}$, must be in accordance to the direction of $\\mathrm{K}$ which, here, we use the same meaning as Rice, J. (1993). Hence, with both derivatives of velocity $V$ and state variable $\u03b8$, we are able to discover how fault evolves with various parameters settings.","title":"Basic Theory"},{"location":"references/","text":"Acknowledgements & References \u00b6 Acknowledgements \u00b6 The simulation of episodic seismic and slow slip events using boundary-element-method is largely benifit from Yajing Liu original Fortran code. References \u00b6 Please consider to cite the following papers if you find this package useful. Boundary element method (quasi-dynamic) \u00b6 Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., & Rice, J. R. (2005). Aseismic slip transients emerge spontaneously in three-dimensional rate and state modeling of subduction earthquake sequences. Journal of Geophysical Research: Solid Earth, 110(B8). https://doi.org/10.1029/2004JB003424","title":"References"},{"location":"references/#acknowledgements-references","text":"","title":"Acknowledgements &amp; References"},{"location":"references/#acknowledgements","text":"The simulation of episodic seismic and slow slip events using boundary-element-method is largely benifit from Yajing Liu original Fortran code.","title":"Acknowledgements"},{"location":"references/#references","text":"Please consider to cite the following papers if you find this package useful.","title":"References"},{"location":"references/#boundary-element-method-quasi-dynamic","text":"Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., & Rice, J. R. (2005). Aseismic slip transients emerge spontaneously in three-dimensional rate and state modeling of subduction earthquake sequences. Journal of Geophysical Research: Solid Earth, 110(B8). https://doi.org/10.1029/2004JB003424","title":"Boundary element method (quasi-dynamic)"},{"location":"examples/generated/bp1/","text":"Note This example is from Benchmark Problem 1 (hence referred as BP1). First, we load the package 1 2 using JuEQ using Plots The prerequisite parameters in this benchmark are list below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ms2mmyr = 365 * 86400 * 1e3 # convert velocity from m/s to mm/yr \u03c1 = 2670.0 # density [kg/m\u00b3] vs = 3464.0 # shear wave velocity [m/s] \u03c30 = 500.0 # effective normal stress [bar] a0 = 0.010 # frictional paramter `a` in vw zone amax = 0.025 # frictional paramter `a` in vs zone b0 = 0.015 # frictional paramter `b` L0 = 8.0 # critical distance [mm] vpl = 1e-9 * ms2mmyr # plate rate [mm/yr] vinit = 1e-9 * ms2mmyr # initial velocity [mm/yr] v0 = 1e-6 * ms2mmyr # reference velocity [mm/yr] f0 = 0.6 # reference frictional coefficient H = 15.0 # vw zone [km] h = 3.0 # vw-vs changing zone [km] Wf = 40.0 # fault depth [km] \u0394z = 100.0e-3 # grid size interval [km] tf = 200.0 ; # simulation time [yr] nothing Warning Make sure your units are consistent across the whole variable space. Then we arrive at some parameters that are implicit by above: 1 2 3 4 5 \u03bc = vs ^ 2 * \u03c1 / 1e5 / 1e6 # shear modulus [bar\u00b7km/mm] \u03bb = \u03bc # poisson material \u03b7 = \u03bc / 2 ( vs * 1e-3 * 365 * 86400 ) ngrid = round ( Int , Wf / \u0394z ); # number of grids nothing First, create a fault space by specifying fault type, depth and with the desired discretization interval. Tip Here, we do not need to provide dip for strike-slip fault as it automatically choose 90 . See fault . 1 2 fa = fault ( Val ( : LineOkada ), STRIKING (), 40.0 , \u0394z ) nothing Then, provide the material properties w.r.t. our 'fault space'. 1 2 3 4 5 6 7 8 a = a0 .* ones ( fa . mesh . n\u03be ) a [ - fa . mesh . z .\u2265 ( H + h )] .= amax a [ H .< - fa . mesh . z .< H + h ] .= a0 .+ ( amax - a0 ) / ( h / \u0394z ) * collect ( 1 : Int ( h / \u0394z )) b = b0 .* ones ( fa . mesh . n\u03be ) L = L0 .* ones ( fa . mesh . n\u03be ) \u03c3 = \u03c30 .* ones ( fa . mesh . n\u03be ) prop = ElasticRSFProperty ( a = a , b = b , L = L , \u03c3 = \u03c3 , \u03bb = \u03bb , \u03bc = \u03bc , vpl = vpl , f0 = f0 , v0 = v0 , \u03b7 = \u03b7 ) nothing Next, construct the initial condition and ODE problem using Okada's Green's function. 1 2 3 4 5 6 7 \u03c40 = \u03c30 * amax * asinh ( vinit / 2 v0 * exp (( f0 + b0 * log ( v0 / vinit )) / amax )) + \u03b7 * vinit \u03c4z = fill ( \u03c40 , size ( fa . mesh . z )) \u03b8z = @ . L / v0 * exp ( a / b0 * log ( 2 v0 / vinit * sinh (( \u03c4z - \u03b7 * vinit ) / a / \u03c3 )) - f0 / b0 ) vz = fill ( vinit , size ( fa . mesh . \u03be )) u0 = hcat ( vz , \u03b8z ); prob , = assemble ( fa , prop , u0 , ( 0.0 , tf )) nothing 1 2 3 Computing green's function ... 29%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f | ETA: 0:00:01\u001b[K Computing green's function ... 92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | ETA: 0:00:00\u001b[K Computing green's function ...100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| Time: 0:00:01\u001b[K Check our depth profile now. 1 plot ([ a , b ], fa . mesh . z , label = [ \"a\" , \"b\" ], yflip = true , ylabel = \"Depth (km)\" ) 0.012 0.015 0.018 0.021 0.024 -40 -30 -20 -10 0 Depth (km) a b Afterwards, solve ODE thanks to DifferentialEquations.jl 1 2 sol = solve ( prob , Tsit5 (), reltol = 1e-6 , abstol = 1e-6 ) nothing Tip Raise the accuracy option or switch to other algorithms if you get instability when solving these ODEs. Finally, check the results. The first event happens at around 196 year: 1 2 maxv = JuEQ . max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , xlims = ( 190 , 200 ), label = \"\" ) 190.0 192.5 195.0 197.5 200.0 -8 -6 -4 -2 0 Time (year) Max Velocity (log10 (m/s)) Note Click here for the slip evolution over 3000 years simulation. It may need some time to load the page. This page was generated using Literate.jl .","title":"Example 1D"},{"location":"examples/generated/otfsync/","text":"Note This example is adapted from Wei, 2016 AGU Tip It will automatically use parallel scheme if nprocs() \u2242\u0338 1 when building stiffness tensor. To do so: 1 2 3 using Distributed addprocs ( 4 ); # add # of cores you desire using JuEQ First, list all the essential parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 using JuEQ using Plots ms2mmyr = 365 * 86400 * 1e3 \u03c1 = 2670.0 # kg/m\u00b3 cs = 3044.0 # m/s vpl = 100.0 # mm/yr v0 = 3.2e4 # mm/yr f0 = 0.6 ; \u03bc = 0.3 # Bar\u00b7km/mm \u03bb = \u03bc # poisson material \u03b1 = ( \u03bb + \u03bc ) / ( \u03bb + 2 \u03bc ) \u03b7 = \u03bc / 2 ( cs * 1e-3 * 365 * 86400 ) # Bar\u00b7yr/mm nothing First, create a fault space. 1 2 fa = fault ( Val ( : RectOkada ), STRIKING (), 80. , 10. , 0.5 , 0.5 ) nothing Next, establish frictional and fault space parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a = ones ( fa . mesh . nx , fa . mesh . n\u03be ) .* 0.015 b = ones ( fa . mesh . nx , fa . mesh . n\u03be ) .* 0.0115 L = ones ( fa . mesh . nx , fa . mesh . n\u03be ) .* 12.0 left_patch = @ . - 25. \u2264 fa . mesh . x \u2264 - 5. right_patch = @ . 5. \u2264 fa . mesh . x \u2264 25. vert_patch = @ . - 6. \u2264 fa . mesh . z \u2264 - 1 b [ xor . ( left_patch , right_patch ), vert_patch ] .= 0.0185 \u03c3max = 500. \u03c3 = [ min ( \u03c3max , 15. + 180. * z ) for z in - fa . mesh . \u03be ] \u03c3 = Matrix ( repeat ( \u03c3 , 1 , fa . mesh . nx ) ' ) prop = ElasticRSFProperty ( a = a , b = b , L = L , \u03c3 = \u03c3 , \u03bb = \u03bb , \u03bc = \u03bc , vpl = vpl , f0 = f0 , v0 = v0 , \u03b7 = \u03b7 ) nothing Make sure our profile match our expectation: 1 2 3 4 5 6 7 8 9 10 11 12 13 p1 = plot (( a .- b ) ' , seriestype =: heatmap , xticks = ( collect ( 1 : 40 : fa . mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : fa . mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"a-b\" , ); p2 = heatmap ( \u03c3 ' , xticks = ( collect ( 1 : 40 : fa . mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : fa . mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \" \\\\ sigma\" ); plot ( p1 , p2 , layout = ( 2 , 1 )) -40 -20 0 20 40 0 5 10 15 20 a-b - 0.003 - 0.002 - 0.001 0 0.001 0.002 0.003 -40 -20 0 20 40 0 5 10 15 20 \u03c3 100 150 200 250 300 350 400 450 500 Then, provide the initial condition and assemble the ODEs: 1 2 3 4 5 vinit = vpl .* ones ( fa . mesh . nx , fa . mesh . n\u03be ) \u03b80 = L ./ vinit ./ 1.1 u0 = cat ( vinit , \u03b80 , dims = 3 ) prob , = assemble ( fa , prop , u0 , ( 0. , 18. ); buffer_ratio = 1 ) nothing 1 2 3 4 5 6 Computing green's function ... 19%|\u2588\u2588\u2588\u2589 | ETA: 0:00:02\u001b[K Computing green's function ... 39%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | ETA: 0:00:02\u001b[K Computing green's function ... 59%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | ETA: 0:00:01\u001b[K Computing green's function ... 80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | ETA: 0:00:01\u001b[K Computing green's function ...100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| ETA: 0:00:00\u001b[K Computing green's function ...100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| Time: 0:00:03\u001b[K Tip It is recommended (from Yajing Liu's personal communication) to add buffer zones adjacent the horizontal edges to immitate zero dislocation at the ridge region. Basically, it affects how the stiffness tensor are periodically summed. To what extent it alters the results remains further testing. Under the hood, it shall impose buffer areas on both sides of along-strike, each of which has a length of bufferratio/2*fa[:x] . Thus, the stiffness contributions falling into those buffer zone shall be neglected, which is equivalent to impose zero-slip correspondingly. Afterwards, solve ODEs problem: 1 2 sol = solve ( prob , Tsit5 (), reltol = 1e-6 , abstol = 1e-6 ) nothing Last, take a look at the max velocity time series: 1 2 maxv = JuEQ . max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , label = \"\" ) 0 5 10 15 -8 -7 -6 -5 -4 -3 -2 Time (year) Max Velocity (log10 (m/s)) And view some snapshots of ruptures (quasi-dynamic) patterns: 1 2 3 4 5 6 7 ind = argmax ( maxv ) myplot = ( ind ) -> heatmap ( log10 . ( sol . u [ ind ][ : , : , 1 ] ./ ms2mmyr ) ' , xticks = ( collect ( 1 : 40 : fa . mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : fa . mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"t = $ ( sol . t [ ind ]) \" ) snaps = myplot ( ind + 300 ) plot ( snaps ) -40 -20 0 20 40 0 5 10 15 20 t = 14.913521453799977 - 8.25 - 8.00 - 7.75 - 7.50 - 7.25 - 7.00 - 6.75 - 6.50 - 6.25 This page was generated using Literate.jl .","title":"Example 2D"}]}