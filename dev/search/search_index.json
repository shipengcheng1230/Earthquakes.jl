{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JuEQ.jl Documentation \u00b6 Overview \u00b6 This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Law Boundary Element Method (Quasi-dynamic) Features to be implemented: Viscoelastic relaxation Fully elastodynamics Finite element method Installation \u00b6 Get the latest version with Julia's package manager: 1 ( v1 . 1 ) pkg > add https :// github . com / shipengcheng1230 / JuEQ . jl To load the package: 1 using JuEQ","title":"Home"},{"location":"#jueqjl-documentation","text":"","title":"JuEQ.jl Documentation"},{"location":"#overview","text":"This is a suite for numerically simulating earthquake sequences in Julia . The purpose of this package is to provide efficient Julia implementations for simulations in the field of earthquake physics. Features of this package currently: Rate-State Friction Law Boundary Element Method (Quasi-dynamic) Features to be implemented: Viscoelastic relaxation Fully elastodynamics Finite element method","title":"Overview"},{"location":"#installation","text":"Get the latest version with Julia's package manager: 1 ( v1 . 1 ) pkg > add https :// github . com / shipengcheng1230 / JuEQ . jl To load the package: 1 using JuEQ","title":"Installation"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2018 Shi Pengcheng Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"private_interface/","text":"Private Interface \u00b6 Index \u00b6 Interfaces \u00b6","title":"Private"},{"location":"private_interface/#private-interface","text":"","title":"Private Interface"},{"location":"private_interface/#index","text":"","title":"Index"},{"location":"private_interface/#interfaces","text":"","title":"Interfaces"},{"location":"public_interface/","text":"Public Interface \u00b6 Index \u00b6 JuEQ.DieterichStateLaw JuEQ.PrzStateLaw JuEQ.RuinaStateLaw JuEQ.dc3d JuEQ.friction JuEQ.max_velocity JuEQ.mmapsave JuEQ.sbarbot_disp_quad8! JuEQ.sbarbot_disp_tet4! Interfaces \u00b6 # JuEQ.DieterichStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}$ # JuEQ.PrzStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - (\\frac{V \u03b8}{2L})^2$ # JuEQ.RuinaStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\frac{V \u03b8}{L}}$ # JuEQ.dc3d \u2014 Method . Calculate displacements and gradient of displacements due to a dislocation in an elastic isotropic halfspace. See dc3d for details. test/test_okada.dat is obtained using DC3dfortran An example wrapper for DC3D in julia as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function dc3d_fortran ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al1 :: T , al2 :: T , aw1 :: T , aw2 :: T , disl1 :: T , disl2 :: T , disl3 :: T ) where { T <: AbstractFloat } # initial return values # `RefValue{T}` may be also viable other than `Array{T, 1}` ux = Array { Float64 }( 1 ) uy = Array { Float64 }( 1 ) uz = Array { Float64 }( 1 ) uxx = Array { Float64 }( 1 ) uyx = Array { Float64 }( 1 ) uzx = Array { Float64 }( 1 ) uxy = Array { Float64 }( 1 ) uyy = Array { Float64 }( 1 ) uzy = Array { Float64 }( 1 ) uxz = Array { Float64 }( 1 ) uyz = Array { Float64 }( 1 ) uzz = Array { Float64 }( 1 ) iret = Array { Int64 }( 1 ) # call okada's code which is renamed as \"__dc3d__\" (see binding rename shown below) # input args tuple must be syntactically written instead of a variable assigned # macros could be used to simplify this in the future ccall (( : __dc3d__ , \"dc3d.so\" ), Void , ( Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ref { Int64 }, ), \u03b1 , x , y , z , dep , dip , al1 , al2 , aw1 , aw2 , disl1 , disl2 , disl3 , ux , uy , uz , uxx , uyx , uzx , uxy , uyy , uzy , uxz , uyz , uzz , iret , ) # results valid iff iret[1] == 0 return ( iret [ 1 ], ux [ 1 ], uy [ 1 ], uz [ 1 ], uxx [ 1 ], uyx [ 1 ], uzx [ 1 ], uxy [ 1 ], uyy [ 1 ], uzy [ 1 ], uxz [ 1 ], uyz [ 1 ], uzz [ 1 ] ) end The corresponding fortran module is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 MODULE okada USE , INTRINSIC :: iso_c_binding IMPLICIT NONE CONTAINS SUBROUTINE dc3d_wrapper (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) BIND ( C , NAME = '__dc3d__' ) REAL * 8 :: & & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz INTEGER * 8 :: iret CALL dc3d (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) END SUBROUTINE dc3d_wrapper END MODULE okada A sample of makefile is as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Build Okada's code for calculating deformation due to a fault model # CC = gfortran CFLAGS = -fPIC -w -O3 LDFLAGS = -shared SRCS = dc3d.f okada.f90 OBJS = $( SRCS:.c = .o ) TARGET = dc3d.so $(TARGET) : $( OBJS ) $( CC ) $( CFLAGS ) $( LDFLAGS ) -o $( TARGET ) $( OBJS ) # JuEQ.friction \u2014 Method . 1 friction ( :: FrictionLawForm , v :: T , \u03b8 :: T , L :: T , a :: T , b :: T , f0 :: T , v0 :: T ) where { T <: Number } Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} # JuEQ.max_velocity \u2014 Method . 1 max_velocity ( t :: AbstractVector , u :: AbstractArray , getu :: Function ) Return max velocity across the fault at each time step. A number of convenient interfaces for common output are implemented. Arguments t::AbstractVector : vector of time steps u::AbstractArray : array of solution getu::Function : method for retrieving velocity section at each time step # JuEQ.mmapsave \u2014 Method . 1 DECallbackSaveToFile ( iot :: IOStream , iou :: IOStream ) Construct a functional callback to write ODESolution ( t & u ) into file. The reason to separate t and u is for more easily reshape u w.r.t grids specification. It right now falls on users' memory on what the type of solution is for accurately retrieving results. Arguments iot::IOStream : stream pointing to solution of time iou::IOStream : stream pointing to solution of domain Note It is strongly not recommended to use \"skipping\" scheme (by defining thrd and dts(a) for each case) when solution is too oscillated. # JuEQ.sbarbot_disp_quad8! \u2014 Method . copyright: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 https://bitbucket.org/sbarbot N (x1) / /| strike (theta) E (x2) q1,q2,q3 ->@--------------------------+ | w | + | i | / | d | / s | t | / s | h | / e | |/ n +--------------------------+ k : l e n g t h / c | / i : / h | / t : / | + Z (x3) # JuEQ.sbarbot_disp_tet4! \u2014 Method . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 / North ( x1 ) / surface / -------------+-------------- East ( x2 ) /| / | + A / | / . | / . | / . | / . |/ + B / . | /| / | / : . | / | / | / : . | / /| | / . : | +------|---------------+ C : D","title":"Public"},{"location":"public_interface/#public-interface","text":"","title":"Public Interface"},{"location":"public_interface/#index","text":"JuEQ.DieterichStateLaw JuEQ.PrzStateLaw JuEQ.RuinaStateLaw JuEQ.dc3d JuEQ.friction JuEQ.max_velocity JuEQ.mmapsave JuEQ.sbarbot_disp_quad8! JuEQ.sbarbot_disp_tet4!","title":"Index"},{"location":"public_interface/#interfaces","text":"# JuEQ.DieterichStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L}$ # JuEQ.PrzStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - (\\frac{V \u03b8}{2L})^2$ # JuEQ.RuinaStateLaw \u2014 Type . $\\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = -\\frac{V \u03b8}{L} * \\log{\\frac{V \u03b8}{L}}$ # JuEQ.dc3d \u2014 Method . Calculate displacements and gradient of displacements due to a dislocation in an elastic isotropic halfspace. See dc3d for details. test/test_okada.dat is obtained using DC3dfortran An example wrapper for DC3D in julia as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function dc3d_fortran ( x :: T , y :: T , z :: T , \u03b1 :: T , dep :: T , dip :: T , al1 :: T , al2 :: T , aw1 :: T , aw2 :: T , disl1 :: T , disl2 :: T , disl3 :: T ) where { T <: AbstractFloat } # initial return values # `RefValue{T}` may be also viable other than `Array{T, 1}` ux = Array { Float64 }( 1 ) uy = Array { Float64 }( 1 ) uz = Array { Float64 }( 1 ) uxx = Array { Float64 }( 1 ) uyx = Array { Float64 }( 1 ) uzx = Array { Float64 }( 1 ) uxy = Array { Float64 }( 1 ) uyy = Array { Float64 }( 1 ) uzy = Array { Float64 }( 1 ) uxz = Array { Float64 }( 1 ) uyz = Array { Float64 }( 1 ) uzz = Array { Float64 }( 1 ) iret = Array { Int64 }( 1 ) # call okada's code which is renamed as \"__dc3d__\" (see binding rename shown below) # input args tuple must be syntactically written instead of a variable assigned # macros could be used to simplify this in the future ccall (( : __dc3d__ , \"dc3d.so\" ), Void , ( Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ref { Float64 }, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ptr { Array { Float64 , 1 }}, Ref { Int64 }, ), \u03b1 , x , y , z , dep , dip , al1 , al2 , aw1 , aw2 , disl1 , disl2 , disl3 , ux , uy , uz , uxx , uyx , uzx , uxy , uyy , uzy , uxz , uyz , uzz , iret , ) # results valid iff iret[1] == 0 return ( iret [ 1 ], ux [ 1 ], uy [ 1 ], uz [ 1 ], uxx [ 1 ], uyx [ 1 ], uzx [ 1 ], uxy [ 1 ], uyy [ 1 ], uzy [ 1 ], uxz [ 1 ], uyz [ 1 ], uzz [ 1 ] ) end The corresponding fortran module is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 MODULE okada USE , INTRINSIC :: iso_c_binding IMPLICIT NONE CONTAINS SUBROUTINE dc3d_wrapper (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) BIND ( C , NAME = '__dc3d__' ) REAL * 8 :: & & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz INTEGER * 8 :: iret CALL dc3d (& & alpha , & & x , y , z , & & depth , dip , & & al1 , al2 , & & aw1 , aw2 , & & disl1 , disl2 , disl3 , & & ux , uy , uz , & & uxx , uyx , uzx , & & uxy , uyy , uzy , & & uxz , uyz , uzz , & & iret ) END SUBROUTINE dc3d_wrapper END MODULE okada A sample of makefile is as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Build Okada's code for calculating deformation due to a fault model # CC = gfortran CFLAGS = -fPIC -w -O3 LDFLAGS = -shared SRCS = dc3d.f okada.f90 OBJS = $( SRCS:.c = .o ) TARGET = dc3d.so $(TARGET) : $( OBJS ) $( CC ) $( CFLAGS ) $( LDFLAGS ) -o $( TARGET ) $( OBJS ) # JuEQ.friction \u2014 Method . 1 friction ( :: FrictionLawForm , v :: T , \u03b8 :: T , L :: T , a :: T , b :: T , f0 :: T , v0 :: T ) where { T <: Number } Calculate friction given by the form of fomula as well as other necessary parameters. Conventional Form: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} Regularized Form: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} # JuEQ.max_velocity \u2014 Method . 1 max_velocity ( t :: AbstractVector , u :: AbstractArray , getu :: Function ) Return max velocity across the fault at each time step. A number of convenient interfaces for common output are implemented. Arguments t::AbstractVector : vector of time steps u::AbstractArray : array of solution getu::Function : method for retrieving velocity section at each time step # JuEQ.mmapsave \u2014 Method . 1 DECallbackSaveToFile ( iot :: IOStream , iou :: IOStream ) Construct a functional callback to write ODESolution ( t & u ) into file. The reason to separate t and u is for more easily reshape u w.r.t grids specification. It right now falls on users' memory on what the type of solution is for accurately retrieving results. Arguments iot::IOStream : stream pointing to solution of time iou::IOStream : stream pointing to solution of domain Note It is strongly not recommended to use \"skipping\" scheme (by defining thrd and dts(a) for each case) when solution is too oscillated. # JuEQ.sbarbot_disp_quad8! \u2014 Method . copyright: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 https://bitbucket.org/sbarbot N (x1) / /| strike (theta) E (x2) q1,q2,q3 ->@--------------------------+ | w | + | i | / | d | / s | t | / s | h | / e | |/ n +--------------------------+ k : l e n g t h / c | / i : / h | / t : / | + Z (x3) # JuEQ.sbarbot_disp_tet4! \u2014 Method . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 / North ( x1 ) / surface / -------------+-------------- East ( x2 ) /| / | + A / | / . | / . | / . | / . |/ + B / . | /| / | / : . | / | / | / : . | / /| | / . : | +------|---------------+ C : D","title":"Interfaces"},{"location":"quasi_dynamic_intro/","text":"Quasi-dynamic Simulation using BEM \u00b6 Basic Theory \u00b6 The governing equation is that at every time step, shear stress across the fault plane equals to frictional force plus a radiation damping term for approximating wave propagation effect: \u03c4 = \u03c3f + \u03b7V Here $\u03bc$ is shear stress across the fault plain. Using Okada's dislocation theory , it can be shown as: \u03c4 = \\mathrm{K} \u2297 \u03b4 where $\\mathrm{K}$ is the so-called stiffness tensor, depicting relationship between displacements at one position regarding to dislocations somewhere else. $\u03b4$ is the dislocation, i.e. displacement at everywhere on the fault. $\u2297$ denotes tensor contraction. Back to $f$, we use rate-and-state frictional law to calculate its value, specifically as below: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} where $f_0$ and $V_0$ are reference friction coefficient and velocity, $V$ and $\u03b8$ are velocity and state variable based on which frictional force is. $a$ and $b$ are two frictional parameters denoting contributions each of which comes from velocity and state variable respectively. $L$ is critical distance after which frictional force return to new steady state. Sometimes people use regularized form to avoid infinity when $V \u2248 0$, namely: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} There are many state evolution law that describes how state variable $\u03b8$ changes with time, one of which that most widely used is Dieterich law: \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} Further, $\u03b7$ is a damping coefficient whose value is often chosen as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity and $\u03c3$ is the effective normal stress. To simulate how fault evolves with time, we then take the derivative of the governing equation: \\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\frac{\\mathrm{d} f(V, \u03b8)}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\mathrm{d} f}{\\mathrm{d} V} \\frac{\\mathrm{d} V}{\\mathrm{d} t} + \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} Thus we arrive at: \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} - \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t}}{\\frac{\\mathrm{d} f}{\\mathrm{d} V} + \u03b7} where $\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\mathrm{K} \u2297 (\\mathrm{V_{pl}} - V)$ where $\\mathrm{V_{pl}}$ is the plate rate. Note The direction of relative velocity, namely $\\mathrm{V_{pl} - V}$, must be in accordance to the direction of $\\mathrm{K}$ which, here, we use the same meaning as Rice, J. (1993). Hence, with both derivatives of velocity $V$ and state variable $\u03b8$, we are able to discover how fault evolves with various parameters settings.","title":"Basic Theory"},{"location":"quasi_dynamic_intro/#quasi-dynamic-simulation-using-bem","text":"","title":"Quasi-dynamic Simulation using BEM"},{"location":"quasi_dynamic_intro/#basic-theory","text":"The governing equation is that at every time step, shear stress across the fault plane equals to frictional force plus a radiation damping term for approximating wave propagation effect: \u03c4 = \u03c3f + \u03b7V Here $\u03bc$ is shear stress across the fault plain. Using Okada's dislocation theory , it can be shown as: \u03c4 = \\mathrm{K} \u2297 \u03b4 where $\\mathrm{K}$ is the so-called stiffness tensor, depicting relationship between displacements at one position regarding to dislocations somewhere else. $\u03b4$ is the dislocation, i.e. displacement at everywhere on the fault. $\u2297$ denotes tensor contraction. Back to $f$, we use rate-and-state frictional law to calculate its value, specifically as below: f(V, \u03b8) = f_0 + a \\ln{\\frac{V}{V_0}} + b \\ln{\\left(\\frac{V_0 \u03b8}{L}\\right)} where $f_0$ and $V_0$ are reference friction coefficient and velocity, $V$ and $\u03b8$ are velocity and state variable based on which frictional force is. $a$ and $b$ are two frictional parameters denoting contributions each of which comes from velocity and state variable respectively. $L$ is critical distance after which frictional force return to new steady state. Sometimes people use regularized form to avoid infinity when $V \u2248 0$, namely: f(V, \u03b8) = a \\sinh ^{-1}{\\left[\\frac{V}{2V_0} \\exp{\\frac{f_0 + b \\ln{\\left(V_0 \u03b8/L\\right)}}{a}}\\right]} There are many state evolution law that describes how state variable $\u03b8$ changes with time, one of which that most widely used is Dieterich law: \\frac{\\mathrm{d}\u03b8}{\\mathrm{d}t} = 1 - \\frac{V \u03b8}{L} Further, $\u03b7$ is a damping coefficient whose value is often chosen as $\u03bc / 2\\mathrm{Vs}$ where $\u03bc$ is shear modulus and $\\mathrm{Vs}$ shear wave velocity and $\u03c3$ is the effective normal stress. To simulate how fault evolves with time, we then take the derivative of the governing equation: \\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\frac{\\mathrm{d} f(V, \u03b8)}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\mathrm{d} f}{\\mathrm{d} V} \\frac{\\mathrm{d} V}{\\mathrm{d} t} + \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t} + \u03b7 \\frac{\\mathrm{d} V}{\\mathrm{d} t} Thus we arrive at: \\frac{\\mathrm{d} V}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} - \\frac{\\mathrm{d} f}{\\mathrm{d} \u03b8} \\frac{\\mathrm{d} \u03b8}{\\mathrm{d} t}}{\\frac{\\mathrm{d} f}{\\mathrm{d} V} + \u03b7} where $\\frac{\\mathrm{d} \u03c4}{\\mathrm{d} t} = \\mathrm{K} \u2297 (\\mathrm{V_{pl}} - V)$ where $\\mathrm{V_{pl}}$ is the plate rate. Note The direction of relative velocity, namely $\\mathrm{V_{pl} - V}$, must be in accordance to the direction of $\\mathrm{K}$ which, here, we use the same meaning as Rice, J. (1993). Hence, with both derivatives of velocity $V$ and state variable $\u03b8$, we are able to discover how fault evolves with various parameters settings.","title":"Basic Theory"},{"location":"references/","text":"Acknowledgements & References \u00b6 Acknowledgements \u00b6 The simulation of episodic seismic and slow slip events using boundary-element-method is largely benifit from Yajing Liu original Fortran code. References \u00b6 Please consider to cite the following papers if you find this package useful. Boundary element method (quasi-dynamic) \u00b6 Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., & Rice, J. R. (2005). Aseismic slip transients emerge spontaneously in three-dimensional rate and state modeling of subduction earthquake sequences. Journal of Geophysical Research: Solid Earth, 110(B8). https://doi.org/10.1029/2004JB003424","title":"References"},{"location":"references/#acknowledgements-references","text":"","title":"Acknowledgements &amp; References"},{"location":"references/#acknowledgements","text":"The simulation of episodic seismic and slow slip events using boundary-element-method is largely benifit from Yajing Liu original Fortran code.","title":"Acknowledgements"},{"location":"references/#references","text":"Please consider to cite the following papers if you find this package useful.","title":"References"},{"location":"references/#boundary-element-method-quasi-dynamic","text":"Rice, J. (1993). Spatio-temporal complexity of slip on a fault. Journal of Geophysical Research: Solid Earth, 98(B6), 9885\u20139907. https://doi.org/10.1029/93JB00191 Liu, Y., & Rice, J. R. (2005). Aseismic slip transients emerge spontaneously in three-dimensional rate and state modeling of subduction earthquake sequences. Journal of Geophysical Research: Solid Earth, 110(B8). https://doi.org/10.1029/2004JB003424","title":"Boundary element method (quasi-dynamic)"},{"location":"examples/generated/bp1/","text":"Note This example is from Benchmark Problem 1 (hence referred as BP1). First, we load the package 1 2 using JuEQ using Plots The prerequisite parameters in this benchmark are list below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ms2mmyr = 365 * 86400 * 1e3 # convert velocity from m/s to mm/yr \u03c1 = 2670.0 # density [kg/m\u00b3] vs = 3464.0 # shear wave velocity [m/s] \u03c30 = 500.0 # effective normal stress [bar] a0 = 0.010 # frictional paramter `a` in vw zone amax = 0.025 # frictional paramter `a` in vs zone b0 = 0.015 # frictional paramter `b` L0 = 8.0 # critical distance [mm] vpl = 1e-9 * ms2mmyr # plate rate [mm/yr] vinit = 1e-9 * ms2mmyr # initial velocity [mm/yr] v0 = 1e-6 * ms2mmyr # reference velocity [mm/yr] f0 = 0.6 # reference frictional coefficient H = 15.0 # vw zone [km] h = 3.0 # vw-vs changing zone [km] Wf = 40.0 # fault depth [km] \u0394z = 100.0e-3 # grid size interval [km] tf = 200.0 ; # simulation time [yr] nothing Warning Make sure your units are consistent across the whole variable space. Then we arrive at some parameters that are implicit by above: 1 2 3 4 5 \u03bc = vs ^ 2 * \u03c1 / 1e5 / 1e6 # shear modulus [bar\u00b7km/mm] \u03bb = \u03bc # poisson material \u03b7 = \u03bc / 2 ( vs * 1e-3 * 365 * 86400 ) ngrid = round ( Int , Wf / \u0394z ); # number of grids nothing First, create a fault space by specifying fault type, depth and with the desired discretization interval. Tip Here, we do not need to provide dip for strike-slip fault as it automatically choose 90 . See fault . 1 2 fa = fault ( Val ( : topcenter ), STRIKING (), 40.0 , \u0394z ) nothing Then, provide the material properties w.r.t. our 'fault space'. 1 2 3 4 5 6 7 8 a = a0 .* ones ( fa . mesh . n\u03be ) a [ - fa . mesh . z .\u2265 ( H + h )] .= amax a [ H .< - fa . mesh . z .< H + h ] .= a0 .+ ( amax - a0 ) / ( h / \u0394z ) * collect ( 1 : Int ( h / \u0394z )) b = b0 .* ones ( fa . mesh . n\u03be ) L = L0 .* ones ( fa . mesh . n\u03be ) \u03c3 = \u03c30 .* ones ( fa . mesh . n\u03be ) prop = ElasticRSFProperties ( a = a , b = b , L = L , \u03c3 = \u03c3 , \u03bb = \u03bb , \u03bc = \u03bc , vpl = vpl , f0 = f0 , v0 = v0 , \u03b7 = \u03b7 ) nothing Next, construct the initial condition and ODE problem using Okada's Green's function. 1 2 3 4 5 6 7 \u03c40 = \u03c30 * amax * asinh ( vinit / 2 v0 * exp (( f0 + b0 * log ( v0 / vinit )) / amax )) + \u03b7 * vinit \u03c4z = fill ( \u03c40 , size ( fa . mesh . z )) \u03b8z = @ . L / v0 * exp ( a / b0 * log ( 2 v0 / vinit * sinh (( \u03c4z - \u03b7 * vinit ) / a / \u03c3 )) - f0 / b0 ) vz = fill ( vinit , size ( fa . mesh . \u03be )) u0 = hcat ( vz , \u03b8z ); prob , = assemble ( fa , prop , u0 , ( 0.0 , tf )) nothing 1 2 3 Computing green's function ... 32%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b | ETA: 0:00:01\u001b[K Computing green's function ... 92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | ETA: 0:00:00\u001b[K Computing green's function ...100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| Time: 0:00:01\u001b[K Check our depth profile now. 1 plot ([ a , b ], fa . mesh . z , label = [ \"a\" , \"b\" ], yflip = true , ylabel = \"Depth (km)\" ) 0.012 0.015 0.018 0.021 0.024 -40 -30 -20 -10 0 Depth (km) a b Afterwards, solve ODE thanks to DifferentialEquations.jl 1 2 sol = solve ( prob , Tsit5 (), reltol = 1e-6 , abstol = 1e-6 ) nothing Tip Raise the accuracy option or switch to other algorithms if you get instability when solving these ODEs. Finally, check the results. The first event happens at around 196 year: 1 2 maxv = JuEQ . max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , xlims = ( 190 , 200 ), label = \"\" ) 190.0 192.5 195.0 197.5 200.0 -8 -6 -4 -2 0 Time (year) Max Velocity (log10 (m/s)) Note Click here for the slip evolution over 3000 years simulation. It may need some time to load the page. This page was generated using Literate.jl .","title":"Example 1D"},{"location":"examples/generated/otfsync/","text":"Note This example is adapted from Wei, 2016 AGU Tip It will automatically use parallel scheme if nprocs() \u2242\u0338 1 when building stiffness tensor. To do so: 1 2 3 using Distributed addprocs ( 4 ); # add # of cores you desire using JuEQ First, list all the essential parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 using JuEQ using Plots ms2mmyr = 365 * 86400 * 1e3 \u03c1 = 2670.0 # kg/m\u00b3 cs = 3044.0 # m/s vpl = 100.0 # mm/yr v0 = 3.2e4 # mm/yr f0 = 0.6 ; \u03bc = 0.3 # Bar\u00b7km/mm \u03bb = \u03bc # poisson material \u03b1 = ( \u03bb + \u03bc ) / ( \u03bb + 2 \u03bc ) \u03b7 = \u03bc / 2 ( cs * 1e-3 * 365 * 86400 ) # Bar\u00b7yr/mm nothing First, create a fault space. 1 2 fa = fault ( Val ( : topcenter ), STRIKING (), 80. , 10. , 0.5 , 0.5 ) nothing Next, establish frictional and fault space parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a = ones ( fa . mesh . nx , fa . mesh . n\u03be ) .* 0.015 b = ones ( fa . mesh . nx , fa . mesh . n\u03be ) .* 0.0115 L = ones ( fa . mesh . nx , fa . mesh . n\u03be ) .* 12.0 left_patch = @ . - 25. \u2264 fa . mesh . x \u2264 - 5. right_patch = @ . 5. \u2264 fa . mesh . x \u2264 25. vert_patch = @ . - 6. \u2264 fa . mesh . z \u2264 - 1 b [ xor . ( left_patch , right_patch ), vert_patch ] .= 0.0185 \u03c3max = 500. \u03c3 = [ min ( \u03c3max , 15. + 180. * z ) for z in - fa . mesh . \u03be ] \u03c3 = Matrix ( repeat ( \u03c3 , 1 , fa . mesh . nx ) ' ) prop = ElasticRSFProperties ( a = a , b = b , L = L , \u03c3 = \u03c3 , \u03bb = \u03bb , \u03bc = \u03bc , vpl = vpl , f0 = f0 , v0 = v0 , \u03b7 = \u03b7 ) nothing Make sure our profile match our expectation: 1 2 3 4 5 6 7 8 9 10 11 12 13 p1 = plot (( a .- b ) ' , seriestype =: heatmap , xticks = ( collect ( 1 : 40 : fa . mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : fa . mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"a-b\" , ); p2 = heatmap ( \u03c3 ' , xticks = ( collect ( 1 : 40 : fa . mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : fa . mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \" \\\\ sigma\" ); plot ( p1 , p2 , layout = ( 2 , 1 )) -40 -20 0 20 40 0 5 10 15 20 a-b - 0.003 - 0.002 - 0.001 0 0.001 0.002 0.003 -40 -20 0 20 40 0 5 10 15 20 \u03c3 100 150 200 250 300 350 400 450 500 Then, provide the initial condition and assemble the ODEs: 1 2 3 4 5 vinit = vpl .* ones ( fa . mesh . nx , fa . mesh . n\u03be ) \u03b80 = L ./ vinit ./ 1.1 u0 = cat ( vinit , \u03b80 , dims = 3 ) prob , = assemble ( fa , prop , u0 , ( 0. , 18. ); buffer_ratio = 1 ) nothing 1 2 3 4 5 6 7 8 9 Computing green's function ... 12%|\u2588\u2588\u258c | ETA: 0:00:04\u001b[K Computing green's function ... 21%|\u2588\u2588\u2588\u2588\u258c | ETA: 0:00:04\u001b[K Computing green's function ... 29%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f | ETA: 0:00:04\u001b[K Computing green's function ... 41%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | ETA: 0:00:03\u001b[K Computing green's function ... 53%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | ETA: 0:00:02\u001b[K Computing green's function ... 65%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | ETA: 0:00:02\u001b[K Computing green's function ... 77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | ETA: 0:00:01\u001b[K Computing green's function ... 89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | ETA: 0:00:00\u001b[K Computing green's function ...100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| Time: 0:00:04\u001b[K Tip It is recommended (from Yajing Liu's personal communication) to add buffer zones adjacent the horizontal edges to immitate zero dislocation at the ridge region. Basically, it affects how the stiffness tensor are periodically summed. To what extent it alters the results remains further testing. Under the hood, it shall impose buffer areas on both sides of along-strike, each of which has a length of bufferratio/2*fa[:x] . Thus, the stiffness contributions falling into those buffer zone shall be neglected, which is equivalent to impose zero-slip correspondingly. Afterwards, solve ODEs problem: 1 2 sol = solve ( prob , Tsit5 (), reltol = 1e-6 , abstol = 1e-6 ) nothing Last, take a look at the max velocity time series: 1 2 maxv = JuEQ . max_velocity ( sol ) plot ( sol . t , log10 . ( maxv / ms2mmyr ), xlabel = \"Time (year)\" , ylabel = \"Max Velocity (log10 (m/s))\" , label = \"\" ) 0 5 10 15 -8 -7 -6 -5 -4 -3 -2 Time (year) Max Velocity (log10 (m/s)) And view some snapshots of ruptures (quasi-dynamic) patterns: 1 2 3 4 5 6 7 ind = argmax ( maxv ) myplot = ( ind ) -> heatmap ( log10 . ( sol . u [ ind ][ : , : , 1 ] ./ ms2mmyr ) ' , xticks = ( collect ( 1 : 40 : fa . mesh . nx + 1 ), [ - 40 , - 20 , 0 , 20 , 40 ]), yticks = ( collect ( 1 : 5 : fa . mesh . n\u03be + 1 ), [ 0 , 5 , 10 , 15 , 20 ]), yflip = true , color =: isolum , aspect_ratio = 2 , title = \"t = $ ( sol . t [ ind ]) \" ) snaps = myplot ( ind + 300 ) plot ( snaps ) -40 -20 0 20 40 0 5 10 15 20 t = 14.913521453799442 - 8.25 - 8.00 - 7.75 - 7.50 - 7.25 - 7.00 - 6.75 - 6.50 - 6.25 This page was generated using Literate.jl .","title":"Example 2D"}]}